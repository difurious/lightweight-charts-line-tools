diff --git a/src/api/chart-api.ts b/src/api/chart-api.ts
index 40a40b9..93972bb 100644
--- a/src/api/chart-api.ts
+++ b/src/api/chart-api.ts
@@ -1,4 +1,4 @@
-import { ChartWidget, MouseEventParamsImpl, MouseEventParamsImplSupplier } from '../gui/chart-widget';
+import { ChartWidget, LineToolsAfterEditEventParamsImpl, LineToolsAfterEditEventParamsImplSupplier, LineToolsDoubleClickEventParamsImpl, LineToolsDoubleClickEventParamsImplSupplier, MouseEventParamsImpl, MouseEventParamsImplSupplier } from '../gui/chart-widget';
 
 import { ensureDefined } from '../helpers/assertions';
 import { Delegate } from '../helpers/delegate';
@@ -8,8 +8,9 @@ import { clone, DeepPartial, isBoolean, merge } from '../helpers/strict-type-che
 import { BarPrice, BarPrices } from '../model/bar';
 import { ChartOptions, ChartOptionsInternal } from '../model/chart-model';
 import { ColorType } from '../model/layout-options';
-import { LineToolPoint } from '../model/line-tool';
+import { LineTool, LineToolExport, LineToolPoint } from '../model/line-tool';
 import { LineToolOptionsMap, LineToolPartialOptionsMap, LineToolType } from '../model/line-tool-options';
+import { Pane } from '../model/pane';
 import { Series } from '../model/series';
 import {
 	AreaSeriesOptions,
@@ -34,8 +35,7 @@ import {
 import { CandlestickSeriesApi } from './candlestick-series-api';
 import { DataUpdatesConsumer, SeriesDataItemTypeMap } from './data-consumer';
 import { DataLayer, DataUpdateResponse, SeriesChanges } from './data-layer';
-import { IChartApi, MouseEventHandler, MouseEventParams } from './ichart-api';
-import { ILineToolApi } from './iline-tool-api';
+import { IChartApi, LineToolsAfterEditEventHandler, LineToolsAfterEditEventParams, LineToolsDoubleClickEventHandler, LineToolsDoubleClickEventParams, MouseEventHandler, MouseEventParams } from './ichart-api';
 import { IPriceScaleApi } from './iprice-scale-api';
 import { ISeriesApi } from './iseries-api';
 import { ITimeScaleApi } from './itime-scale-api';
@@ -164,6 +164,8 @@ export class ChartApi implements IChartApi, DataUpdatesConsumer<SeriesType> {
 
 	private readonly _clickedDelegate: Delegate<MouseEventParams> = new Delegate();
 	private readonly _crosshairMovedDelegate: Delegate<MouseEventParams> = new Delegate();
+	private readonly _lineToolsDoubleClickDelegate: Delegate<LineToolsDoubleClickEventParams> = new Delegate();
+	private readonly _lineToolsAfterEditDelegate: Delegate<LineToolsAfterEditEventParams> = new Delegate();
 
 	private readonly _timeScaleApi: TimeScaleApi;
 
@@ -191,13 +193,41 @@ export class ChartApi implements IChartApi, DataUpdatesConsumer<SeriesType> {
 			this
 		);
 
+		this._chartWidget.lineToolsDoubleClick().subscribe(
+			(paramSupplier: LineToolsDoubleClickEventParamsImplSupplier) => {
+				if (this._lineToolsDoubleClickDelegate.hasListeners()) {
+					this._lineToolsDoubleClickDelegate.fire(this._convertLineToolsDoubleClickParams(paramSupplier()));
+				}
+			},
+			this
+		);
+
+		this._chartWidget.lineToolsAfterEdit().subscribe(
+			(paramSupplier: LineToolsAfterEditEventParamsImplSupplier) => {
+				if (this._lineToolsAfterEditDelegate.hasListeners()) {
+					this._lineToolsAfterEditDelegate.fire(this._convertLineToolsAfterEditParams(paramSupplier()));
+				}
+			},
+			this
+		);
+
 		const model = this._chartWidget.model();
 		this._timeScaleApi = new TimeScaleApi(model, this._chartWidget.timeAxisWidget());
 	}
 
+	public setCrossHairXY(x: number, y: number, visible: boolean): void {
+		this._chartWidget.paneWidgets()[0].setCrossHair(x, y, visible);
+	}
+
+	public clearCrossHair(): void {
+		this._chartWidget.paneWidgets()[0].clearCrossHair();
+	}
+
 	public remove(): void {
 		this._chartWidget.clicked().unsubscribeAll(this);
 		this._chartWidget.crosshairMoved().unsubscribeAll(this);
+		this._chartWidget.lineToolsDoubleClick().unsubscribeAll(this);
+		this._chartWidget.lineToolsAfterEdit().unsubscribeAll(this);
 
 		this._timeScaleApi.destroy();
 		this._chartWidget.destroy();
@@ -207,6 +237,8 @@ export class ChartApi implements IChartApi, DataUpdatesConsumer<SeriesType> {
 
 		this._clickedDelegate.destroy();
 		this._crosshairMovedDelegate.destroy();
+		this._lineToolsDoubleClickDelegate.destroy();
+		this._lineToolsAfterEditDelegate.destroy();
 		this._dataLayer.destroy();
 	}
 
@@ -313,7 +345,7 @@ export class ChartApi implements IChartApi, DataUpdatesConsumer<SeriesType> {
 		this._seriesMapReversed.delete(series);
 	}
 
-	public addLineTool<T extends LineToolType>(name: T, points: LineToolPoint[], options?: LineToolPartialOptionsMap[T]): ILineToolApi<T> {
+	public addLineTool<T extends LineToolType>(name: T, points: LineToolPoint[], options?: LineToolPartialOptionsMap[T]): LineToolApi<T> {
 		const strictOptions = merge(clone(LineToolsOptionDefaults[name]), options || {}) as LineToolOptionsMap[T];
 		const tool = this._chartWidget.model().createLineTool(name, strictOptions, points);
 		return new LineToolApi<T>(tool);
@@ -323,6 +355,102 @@ export class ChartApi implements IChartApi, DataUpdatesConsumer<SeriesType> {
 		this._chartWidget.model().lineToolCreator().setActiveLineTool(name, options);
 	}
 
+	public removeLineToolsById(ids: string[]): void {
+		if (Array.isArray(ids)) {
+			const pane = this._getPane();
+			if (pane === null) { return; }
+			ids.forEach((id: string) => {
+				const lineToolToRemove = pane.getLineTool(id);
+				if (lineToolToRemove === null) {
+					return;
+				}
+				pane.removeDataSource(lineToolToRemove);
+			});
+			pane.recalculate();
+		}
+		return;
+	}
+
+	public getSelectedLineTools(): string {
+		let lineToolsOptions: LineToolExport<LineToolType>[] = [];
+		const pane = this._getPane();
+		if (pane === null) { return JSON.stringify(lineToolsOptions); }
+		const selectedLineTools = pane.getSelectedLineTools();
+		if (selectedLineTools.length > 0) {
+			lineToolsOptions = selectedLineTools.map((l: LineTool<LineToolType>) => l.exportLineToolToLineToolExport());
+		}
+		return JSON.stringify(lineToolsOptions);
+	}
+
+	public removeSelectedLineTools(): void {
+		const pane = this._getPane();
+		if (pane === null) { return; }
+		const selectedLineTools = pane.getSelectedLineTools();
+		if (selectedLineTools.length > 0) {
+			selectedLineTools.forEach((line: LineTool<LineToolType>) => { pane.removeDataSource(line); });
+			pane.recalculate();
+		}
+	}
+
+	public removeAllLineTools(): void {
+		const pane = this._getPane();
+		if (pane === null) { return; }
+		const selectedLineTools = pane.getAllLineTools();
+		if (selectedLineTools.length > 0) {
+			selectedLineTools.forEach((line: LineTool<LineToolType>) => { pane.removeDataSource(line); });
+			pane.recalculate();
+		}
+	}
+
+	public exportLineTools(): string {
+		let lineToolsOptions: LineToolExport<LineToolType>[] = [];
+		const pane = this._getPane();
+		if (pane === null) {
+			return JSON.stringify(lineToolsOptions);
+		}
+		const lineTools = pane.getAllLineTools();
+		if (lineTools.length > 0) {
+			lineToolsOptions = lineTools.map((l: LineTool<LineToolType>) => l.exportLineToolToLineToolExport());
+		}
+		return JSON.stringify(lineToolsOptions);
+	}
+
+	public importLineTools(json: string): boolean {
+		if (json === 'undefined' || !json) {
+			return false;
+		}
+		const lineTools = JSON.parse(json) as LineToolExport<LineToolType>[];
+
+		lineTools.forEach((line: LineToolExport<LineToolType>) => {
+			const lineToolApi = this.addLineTool<LineToolType>(line.toolType, line.points, line.options);
+			lineToolApi.lineTool.setId(line.id);
+		});
+
+		const pane = this._getPane();
+		if (pane !== null) {
+			pane.recalculate();
+		}
+		return true;
+	}
+
+	public applyLineToolOptions(newLineTool: LineToolExport<LineToolType>): boolean {
+		const pane = this._getPane();
+		if (pane === null) {
+			return false;
+		}
+
+		const lineTool = pane.getLineTool(newLineTool.id);
+		if (lineTool === null) {
+			return false;
+		}
+
+		lineTool.setPoints(newLineTool.points);
+		const lineToolApi = new LineToolApi(lineTool);
+		lineToolApi.applyOptions(newLineTool.options);
+
+		return true;
+	}
+
 	public applyNewData<TSeriesType extends SeriesType>(series: Series<TSeriesType>, data: SeriesDataItemTypeMap[TSeriesType][]): void {
 		this._sendUpdateToChart(this._dataLayer.setSeriesData(series, data));
 	}
@@ -347,6 +475,22 @@ export class ChartApi implements IChartApi, DataUpdatesConsumer<SeriesType> {
 		this._crosshairMovedDelegate.unsubscribe(handler);
 	}
 
+	public subscribeLineToolsDoubleClick(handler: LineToolsDoubleClickEventHandler): void {
+		this._lineToolsDoubleClickDelegate.subscribe(handler);
+	}
+
+	public unsubscribeLineToolsDoubleClick(handler: LineToolsDoubleClickEventHandler): void {
+		this._lineToolsDoubleClickDelegate.unsubscribe(handler);
+	}
+
+	public subscribeLineToolsAfterEdit(handler: LineToolsAfterEditEventHandler): void {
+		this._lineToolsAfterEditDelegate.subscribe(handler);
+	}
+
+	public unsubscribeLineToolsAfterEdit(handler: LineToolsAfterEditEventHandler): void {
+		this._lineToolsAfterEditDelegate.unsubscribe(handler);
+	}
+
 	public priceScale(priceScaleId?: string): IPriceScaleApi {
 		if (priceScaleId === undefined) {
 			warn('Using ChartApi.priceScale() method without arguments has been deprecated, pass valid price scale id instead');
@@ -385,6 +529,10 @@ export class ChartApi implements IChartApi, DataUpdatesConsumer<SeriesType> {
 		return ensureDefined(this._seriesMapReversed.get(series));
 	}
 
+	private _getPane(): Pane | null {
+		return this._chartWidget.model().getActivePane();
+	}
+
 	private _convertMouseParams(param: MouseEventParamsImpl): MouseEventParams {
 		const seriesPrices = new Map<ISeriesApi<SeriesType>, BarPrice | BarPrices>();
 		param.seriesPrices.forEach((price: BarPrice | BarPrices, series: Series) => {
@@ -401,4 +549,17 @@ export class ChartApi implements IChartApi, DataUpdatesConsumer<SeriesType> {
 			seriesPrices,
 		};
 	}
+
+	private _convertLineToolsDoubleClickParams(param: LineToolsDoubleClickEventParamsImpl): LineToolsDoubleClickEventParams {
+		return {
+			selectedLineTool: param.selectedLineTool,
+		};
+	}
+
+	private _convertLineToolsAfterEditParams(param: LineToolsAfterEditEventParamsImpl): LineToolsAfterEditEventParams {
+		return {
+			selectedLineTool: param.selectedLineTool,
+			stage: param.stage,
+		};
+	}
 }
diff --git a/src/api/ichart-api.ts b/src/api/ichart-api.ts
index d34cfa1..9138e99 100644
--- a/src/api/ichart-api.ts
+++ b/src/api/ichart-api.ts
@@ -2,7 +2,7 @@ import { DeepPartial } from '../helpers/strict-type-checks';
 
 import { BarPrice, BarPrices } from '../model/bar';
 import { ChartOptions } from '../model/chart-model';
-import { LineToolPoint } from '../model/line-tool';
+import { LineToolExport, LineToolPoint } from '../model/line-tool';
 import { LineToolPartialOptionsMap, LineToolType } from '../model/line-tool-options';
 import { Point } from '../model/point';
 import { SeriesMarker } from '../model/series-markers';
@@ -61,6 +61,19 @@ export interface MouseEventParams {
  */
 export type MouseEventHandler = (param: MouseEventParams) => void;
 
+export interface LineToolsDoubleClickEventParams {
+	selectedLineTool: LineToolExport<LineToolType>;
+}
+
+export interface LineToolsAfterEditEventParams {
+	selectedLineTool: LineToolExport<LineToolType>;
+	stage: string;
+}
+
+export type LineToolsDoubleClickEventHandler = (param: LineToolsDoubleClickEventParams) => void;
+
+export type LineToolsAfterEditEventHandler = (param: LineToolsAfterEditEventParams) => void;
+
 /**
  * The main interface of a single chart.
  */
@@ -161,6 +174,41 @@ export interface IChartApi {
 	 */
 	setActiveLineTool<T extends LineToolType>(name: T, options: LineToolPartialOptionsMap[T]): void;
 
+	/**
+     * Remove a LineTool by its ID.
+     */
+	removeLineToolsById(ids: string[]): void;
+
+	/**
+     * Get the currently selected LineTool(s), return JSON string of them.
+     */
+	getSelectedLineTools(): void;
+
+	/**
+     * Remove the currently selected LineTool only.
+     */
+	removeSelectedLineTools(): void;
+
+    /**
+     * Remove All LineTools that have been drawn.
+     */
+	removeAllLineTools(): void;
+
+    /**
+     * Export all LineTools that have been drawn to a JSON string.  This export can be used with importLineTools(JSONstring) if you want to import them in the future
+     */
+	exportLineTools(): void;
+
+    /**
+     * Import a JSON string to recreate all LineTools that have previously been exported using exportLineTools().
+     */
+	importLineTools(json: string): boolean;
+
+    /**
+     * Apply new provided options to lineTool specified in the id field.
+     */
+	applyLineToolOptions(newLineTool: LineToolExport<LineToolType>): boolean;
+
 	/**
 	 * Removes a series of any type. This is an irreversible operation, you cannot do anything with the series after removing it.
 	 *
@@ -220,6 +268,10 @@ export interface IChartApi {
 	 */
 	subscribeCrosshairMove(handler: MouseEventHandler): void;
 
+	setCrossHairXY(x: number, y: number, visible: boolean): void;
+
+	clearCrossHair(): void;
+
 	/**
 	 * Unsubscribe a handler that was previously subscribed using {@link subscribeCrosshairMove}.
 	 *
@@ -231,6 +283,34 @@ export interface IChartApi {
 	 */
 	unsubscribeCrosshairMove(handler: MouseEventHandler): void;
 
+	/**
+	 * Adds a subscription to receive notifications on linetools being double clicked
+	 *
+	 * @param handler - handler (function) to be called on double click
+	 */
+	subscribeLineToolsDoubleClick(handler: LineToolsDoubleClickEventHandler): void;
+
+	/**
+	 * Removes linetools being double clicked subscription
+	 *
+	 * @param handler - previously subscribed handler
+	 */
+	unsubscribeLineToolsDoubleClick(handler: LineToolsDoubleClickEventHandler): void;
+
+	/**
+	 * Adds a subscription to receive notifications on linetools after finishing editing a line tool
+	 *
+	 * @param handler - handler (function) to be called after line tool was finished editing
+	 */
+	subscribeLineToolsAfterEdit(handler: LineToolsAfterEditEventHandler): void;
+
+	/**
+	 * Removes linetools notifications on linetools after finishing editing a line tool
+	 *
+	 * @param handler - previously subscribed handler
+	 */
+	unsubscribeLineToolsAfterEdit(handler: LineToolsAfterEditEventHandler): void;
+
 	/**
 	 * Returns API to manipulate a price scale.
 	 *
diff --git a/src/api/line-tool-api.ts b/src/api/line-tool-api.ts
index 88b9ee1..2c255bd 100644
--- a/src/api/line-tool-api.ts
+++ b/src/api/line-tool-api.ts
@@ -6,10 +6,10 @@ import { LineToolOptionsMap, LineToolPartialOptionsMap, LineToolType } from '../
 import { ILineToolApi } from './iline-tool-api';
 
 export class LineToolApi<TLineToolType extends LineToolType> implements ILineToolApi<TLineToolType> {
-	protected _lineTool: LineTool<TLineToolType>;
+	public lineTool: LineTool<TLineToolType>;
 
 	public constructor(lineTool: LineTool<TLineToolType>) {
-		this._lineTool = lineTool;
+		this.lineTool = lineTool;
 	}
 
 	public setPoints(points: LineToolPoint[]): void {
@@ -17,14 +17,14 @@ export class LineToolApi<TLineToolType extends LineToolType> implements ILineToo
 	}
 
 	public applyOptions(options: LineToolPartialOptionsMap[TLineToolType]): void {
-		this._lineTool.applyOptions(options);
+		this.lineTool.applyOptions(options);
 	}
 
 	public options(): Readonly<LineToolOptionsMap[TLineToolType]> {
-		return clone(this._lineTool.options());
+		return clone(this.lineTool.options());
 	}
 
 	public toolType(): LineToolType {
-		return this._lineTool.toolType();
+		return this.lineTool.toolType();
 	}
 }
diff --git a/src/api/options/crosshair-options-defaults.ts b/src/api/options/crosshair-options-defaults.ts
index 42dc8ea..1829b81 100644
--- a/src/api/options/crosshair-options-defaults.ts
+++ b/src/api/options/crosshair-options-defaults.ts
@@ -19,5 +19,7 @@ export const crosshairOptionsDefaults: CrosshairOptions = {
 		labelBackgroundColor: '#4c525e',
 	},
 	mode: CrosshairMode.Magnet,
+	// testing to try and get graphics tests to pass, the crosshair magnet is messing them up
 	magnetThreshold: 14,
+	// magnetThreshold: 1000000,
 };
diff --git a/src/api/options/line-tools-options-defaults.ts b/src/api/options/line-tools-options-defaults.ts
index c3cc48c..4c11033 100644
--- a/src/api/options/line-tools-options-defaults.ts
+++ b/src/api/options/line-tools-options-defaults.ts
@@ -15,11 +15,12 @@ export const TextDefaults: TextOptions = {
 	forceCalculateMaxLineWidth: false,
 	alignment: TextAlignment.Left,
 	font: { family: defaultFontFamily, color: '#2962ff', size: 12, bold: false, italic: false },
-	box: { scale: 1, angle: 0, alignment: { vertical: BoxVerticalAlignment.Bottom, horizontal: BoxHorizontalAlignment.Left } },
+	box: { scale: 1, angle: 0, alignment: { vertical: BoxVerticalAlignment.Top, horizontal: BoxHorizontalAlignment.Left } },
 };
 
 export const TrendLineOptionDefaults: TrendLineToolOptions = {
 	visible: true,
+	editable: true,
 	line: {
 		width: 1,
 		color: '#2962ff',
@@ -32,6 +33,7 @@ export const TrendLineOptionDefaults: TrendLineToolOptions = {
 
 export const HorizontalLineOptionDefaults: HorizontalLineToolOptions = {
 	visible: true,
+	editable: true,
 	line: {
 		width: 1,
 		color: '#2962ff',
@@ -44,6 +46,7 @@ export const HorizontalLineOptionDefaults: HorizontalLineToolOptions = {
 
 export const ParallelChannelOptionDefaults: ParallelChannelToolOptions = {
 	visible: true,
+	editable: true,
 	showMiddleLine: true,
 	extend: { left: false, right: false },
 	background: { color: applyAlpha('#2962ff', 0.2) },
@@ -53,25 +56,27 @@ export const ParallelChannelOptionDefaults: ParallelChannelToolOptions = {
 
 export const FibRetracementOptionDefaults: FibRetracementToolOptions = {
 	visible: true,
+	editable: true,
 	extend: { left: false, right: false },
 	line: { width: 1, style: LineStyle.Solid },
 	levels: [
-        { color: '#787b86', coeff: 0 },
-        { color: '#f23645', coeff: 0.236 },
-        { color: '#81c784', coeff: 0.382 },
-        { color: '#4caf50', coeff: 0.5 },
-        { color: '#089981', coeff: 0.618 },
-        { color: '#64b5f6', coeff: 0.786 },
-        { color: '#787b86', coeff: 1 },
-        { color: '#2962ff', coeff: 1.618 },
-        { color: '#f23645', coeff: 2.618 },
-        { color: '#9c27b0', coeff: 3.618 },
-        { color: '#e91e63', coeff: 4.236 },
+        { color: '#787b86', coeff: 0, opacity: 0 },
+        { color: '#f23645', coeff: 0.236, opacity: 0 },
+        { color: '#81c784', coeff: 0.382, opacity: 0 },
+        { color: '#4caf50', coeff: 0.5, opacity: 0 },
+        { color: '#089981', coeff: 0.618, opacity: 0 },
+        { color: '#64b5f6', coeff: 0.786, opacity: 0 },
+        { color: '#787b86', coeff: 1, opacity: 0 },
+        { color: '#2962ff', coeff: 1.618, opacity: 0 },
+        { color: '#f23645', coeff: 2.618, opacity: 0 },
+        { color: '#9c27b0', coeff: 3.618, opacity: 0 },
+        { color: '#e91e63', coeff: 4.236, opacity: 0 },
 	],
 };
 
 export const BrushOptionDefaults: BrushToolOptions = {
 	visible: true,
+	editable: true,
 	line: {
 		width: 1,
 		color: '#00bcd4',
@@ -83,6 +88,7 @@ export const BrushOptionDefaults: BrushToolOptions = {
 
 export const RectangleOptionDefaults: RectangleToolOptions = {
 	visible: true,
+	editable: true,
 	rectangle: {
 		extend: { left: false, right: false },
 		background: { color: applyAlpha('#9c27b0', 0.2) },
@@ -93,6 +99,7 @@ export const RectangleOptionDefaults: RectangleToolOptions = {
 
 export const TriangleOptionDefaults: TriangleToolOptions = {
 	visible: true,
+	editable: true,
 	triangle: {
 		background: { color: applyAlpha('#f57c00', 0.2) },
 		border: { width: 1, style: LineStyle.Solid, color: '#f57c00' },
@@ -101,12 +108,14 @@ export const TriangleOptionDefaults: TriangleToolOptions = {
 
 export const VerticalLineOptionDefaults: VerticalLineToolOptions = {
 	visible: true,
+	editable: true,
 	text: TextDefaults,
 	line: { width: 1, color: '#2962ff', style: LineStyle.Solid },
 };
 
 export const PathOptionDefaults: PathToolOptions = {
 	visible: true,
+	editable: true,
 	line: {
 		width: 1,
 		color: '#2962ff',
@@ -117,16 +126,19 @@ export const PathOptionDefaults: PathToolOptions = {
 
 export const CrossLineOptionDefaults: CrossLineToolOptions = {
 	visible: true,
+	editable: true,
 	line: { width: 1, color: '#2962ff', style: LineStyle.Solid },
 };
 
 export const HighlighterOptionDefaults: HighlighterToolOptions = {
 	visible: true,
+	editable: true,
 	line: { color: applyAlpha('#f23645', 0.15) },
 };
 
 export const TextOptionDefaults: TextToolOptions = {
 	visible: true,
+	editable: true,
 	text: merge(clone(TextDefaults), { value: 'Text' }) as TextOptions,
 };
 
diff --git a/src/api/options/price-line-options-defaults.ts b/src/api/options/price-line-options-defaults.ts
index ebe6533..dcb1b3d 100644
--- a/src/api/options/price-line-options-defaults.ts
+++ b/src/api/options/price-line-options-defaults.ts
@@ -9,4 +9,6 @@ export const priceLineOptionsDefaults: PriceLineOptions = {
 	lineVisible: true,
 	axisLabelVisible: true,
 	title: '',
+	ray: false,
+	rayStart: 0,
 };
diff --git a/src/gui/chart-widget.ts b/src/gui/chart-widget.ts
index d6a85d3..79f2a8e 100644
--- a/src/gui/chart-widget.ts
+++ b/src/gui/chart-widget.ts
@@ -14,6 +14,8 @@ import {
 	TimeScaleInvalidation,
 	TimeScaleInvalidationType,
 } from '../model/invalidate-mask';
+import { LineToolExport } from '../model/line-tool';
+import { LineToolType } from '../model/line-tool-options';
 import { Point } from '../model/point';
 import { PriceAxisPosition } from '../model/price-scale';
 import { Series } from '../model/series';
@@ -34,6 +36,19 @@ export interface MouseEventParamsImpl {
 
 export type MouseEventParamsImplSupplier = () => MouseEventParamsImpl;
 
+export interface LineToolsDoubleClickEventParamsImpl {
+	selectedLineTool: LineToolExport<LineToolType>;
+}
+
+export interface LineToolsAfterEditEventParamsImpl {
+	selectedLineTool: LineToolExport<LineToolType>;
+	stage: string;
+}
+
+export type LineToolsDoubleClickEventParamsImplSupplier = () => LineToolsDoubleClickEventParamsImpl;
+
+export type LineToolsAfterEditEventParamsImplSupplier = () => LineToolsAfterEditEventParamsImpl;
+
 export class ChartWidget implements IDestroyable {
 	private readonly _options: ChartOptionsInternal;
 	private _paneWidgets: PaneWidget[] = [];
@@ -51,6 +66,8 @@ export class ChartWidget implements IDestroyable {
 	private _drawPlanned: boolean = false;
 	private _clicked: Delegate<MouseEventParamsImplSupplier> = new Delegate();
 	private _crosshairMoved: Delegate<MouseEventParamsImplSupplier> = new Delegate();
+	private _lineToolsDoubleClick: Delegate<LineToolsDoubleClickEventParamsImplSupplier> = new Delegate();
+	private _lineToolsAfterEdit: Delegate<LineToolsAfterEditEventParamsImplSupplier> = new Delegate();
 	private _onWheelBound: (event: WheelEvent) => void;
 
 	public constructor(container: HTMLElement, options: ChartOptionsInternal) {
@@ -75,6 +92,8 @@ export class ChartWidget implements IDestroyable {
 			this._options
 		);
 		this.model().crosshairMoved().subscribe(this._onPaneWidgetCrosshairMoved.bind(this), this);
+		this.model().lineToolsDoubleClick().subscribe(this._onLineToolsDoubleClick.bind(this), this);
+		this.model().lineToolsAfterEdit().subscribe(this._onLineToolsAfterEdit.bind(this), this);
 
 		this._timeAxisWidget = new TimeAxisWidget(this);
 		this._tableElement.appendChild(this._timeAxisWidget.getElement());
@@ -134,6 +153,7 @@ export class ChartWidget implements IDestroyable {
 		}
 
 		this._model.crosshairMoved().unsubscribeAll(this);
+		this._model.lineToolsDoubleClick().unsubscribeAll(this);
 		this._model.timeScale().optionsApplied().unsubscribeAll(this);
 		this._model.priceScalesOptionsChanged().unsubscribeAll(this);
 		this._model.destroy();
@@ -219,6 +239,14 @@ export class ChartWidget implements IDestroyable {
 		return this._crosshairMoved;
 	}
 
+	public lineToolsDoubleClick(): ISubscription<LineToolsDoubleClickEventParamsImplSupplier> {
+		return this._lineToolsDoubleClick;
+	}
+
+	public lineToolsAfterEdit(): ISubscription<LineToolsAfterEditEventParamsImplSupplier> {
+		return this._lineToolsAfterEdit;
+	}
+
 	public takeScreenshot(): HTMLCanvasElement {
 		if (this._invalidateMask !== null) {
 			this._drawImpl(this._invalidateMask);
@@ -645,6 +673,19 @@ export class ChartWidget implements IDestroyable {
 		};
 	}
 
+	private _getLineToolsDoubleClickEventParamsImpl(selectedLineTool: LineToolExport<LineToolType>): LineToolsDoubleClickEventParamsImpl {
+		return {
+			selectedLineTool: selectedLineTool,
+		};
+	}
+
+	private _getLineToolsAfterEditEventParamsImpl(selectedLineTool: LineToolExport<LineToolType>, stage: string): LineToolsAfterEditEventParamsImpl {
+		return {
+			selectedLineTool: selectedLineTool,
+			stage: stage,
+		};
+	}
+
 	private _onPaneWidgetClicked(time: TimePointIndex | null, point: Point): void {
 		this._clicked.fire(() => this._getMouseEventParamsImpl(time, point));
 	}
@@ -653,6 +694,14 @@ export class ChartWidget implements IDestroyable {
 		this._crosshairMoved.fire(() => this._getMouseEventParamsImpl(time, point));
 	}
 
+	private _onLineToolsDoubleClick(selectedLineTool: LineToolExport<LineToolType>): void {
+		this._lineToolsDoubleClick.fire(() => this._getLineToolsDoubleClickEventParamsImpl(selectedLineTool));
+	}
+
+	private _onLineToolsAfterEdit(selectedLineTool: LineToolExport<LineToolType>, stage: string): void {
+		this._lineToolsAfterEdit.fire(() => this._getLineToolsAfterEditEventParamsImpl(selectedLineTool, stage));
+	}
+
 	private _updateTimeAxisVisibility(): void {
 		const display = this._options.timeScale.visible ? '' : 'none';
 		this._timeAxisWidget.getElement().style.display = display;
diff --git a/src/gui/mouse-event-handler.ts b/src/gui/mouse-event-handler.ts
index 167e4f5..b47c231 100644
--- a/src/gui/mouse-event-handler.ts
+++ b/src/gui/mouse-event-handler.ts
@@ -13,7 +13,7 @@ export type EmptyCallback = () => void;
 export type PinchEventCallback = (middlePoint: Position, scale: number) => void;
 
 export interface IInputEventListener {
-	onInputEvent(paneWidget: PaneWidget, eventType: InputEventType, event?: TouchMouseEvent): void;
+	onInputEvent(paneWidget: PaneWidget, ctx: CanvasRenderingContext2D, eventType: InputEventType, event?: TouchMouseEvent): void;
 }
 
 // eslint-disable-next-line @typescript-eslint/no-explicit-any
@@ -85,7 +85,7 @@ export interface MouseEventHandlerEventBase {
 	readonly srcType: string;
 
 	consumed?: boolean;
-	
+
 	target: MouseEvent['target'];
 	view: MouseEvent['view'];
 
diff --git a/src/gui/pane-widget.ts b/src/gui/pane-widget.ts
index 05e18dc..b6d552e 100644
--- a/src/gui/pane-widget.ts
+++ b/src/gui/pane-widget.ts
@@ -5,6 +5,7 @@ import { clearRect, clearRectWithGradient, drawScaled } from '../helpers/canvas-
 import { Delegate } from '../helpers/delegate';
 import { IDestroyable } from '../helpers/idestroyable';
 import { ISubscription } from '../helpers/isubscription';
+import { clone } from '../helpers/strict-type-checks';
 
 import { ChartModel, HoveredObject, TrackingModeExitMode } from '../model/chart-model';
 import { Coordinate } from '../model/coordinate';
@@ -265,19 +266,19 @@ export class PaneWidget implements IDestroyable, MouseEventHandlers {
 		if (!this._state) {
 			return;
 		}
-		//this._onMouseEvent();
+		// this._onMouseEvent();
 
 		const x = event.localX;
 		const y = event.localY;
-		
+
 		if (this._preventCrosshairMove()) {
 			this._clearCrosshairPosition();
 		}
 
 		this._setCrosshairPosition(x, y);
 		this._propagateEvent(InputEventType.MouseMove, event);
-		//const hitTest = this.hitTest(x, y);
-		//this._model().setHoveredSource(hitTest && { source: hitTest.source, object: hitTest.object });
+		// const hitTest = this.hitTest(x, y);
+		// this._model().setHoveredSource(hitTest && { source: hitTest.source, object: hitTest.object });
 	}
 
 	public mouseClickEvent(event: MouseEventHandlerMouseEvent): void {
@@ -297,11 +298,33 @@ export class PaneWidget implements IDestroyable, MouseEventHandlers {
 		this._tryExitTrackingMode();
 	}
 
+	public mouseDoubleClickEvent(event: MouseEventHandlerMouseEvent): void {
+		if (this._state === null) {
+			return;
+		}
+		this._onMouseEvent();
+		this._propagateEvent(InputEventType.MouseDoubleClick, event);
+
+		const selectedLineTools = this.state().getSelectedLineTools();
+		if (selectedLineTools.length > 0) {
+			const lineTool = selectedLineTools[0];
+			// While linetool is being created, we don't necessarely want to fire the event.
+			// for instance when finishing creating the path linetool.
+			if (lineTool.creating()) {
+				lineTool.setCreating(false);
+			} else {
+				// create a new lineToolExport to make sure that any change in the lineTool exported in not immediately applied.
+				const selectedLineTool = clone(selectedLineTools[0].exportLineToolToLineToolExport());
+				this._model().fireLineToolsDoubleClick(selectedLineTool);
+			}
+		}
+	}
+
 	public pressedMouseMoveEvent(event: MouseEventHandlerMouseEvent): void {
-		//this._onMouseEvent();
+		// this._onMouseEvent();
 		this._pressedMouseTouchMoveEvent(event);
-		//this._setCrosshairPosition(event.localX, event.localY);
-		//this._propagateEvent(InputEventType.PressedMouseMove, event);
+		// this._setCrosshairPosition(event.localX, event.localY);
+		// this._propagateEvent(InputEventType.PressedMouseMove, event);
 	}
 
 	public mouseUpEvent(event: MouseEventHandlerMouseEvent): void {
@@ -384,7 +407,7 @@ export class PaneWidget implements IDestroyable, MouseEventHandlers {
 			const newX = origPoint.x + (x - this._startTrackPoint.x) as Coordinate;
 			const newY = origPoint.y + (y - this._startTrackPoint.y) as Coordinate;
 			this._setCrosshairPosition(newX, newY);
-			//return;
+			// return;
 		} else if (!this._preventCrosshairMove()) {
 			this._setCrosshairPosition(x, y);
 		}
@@ -519,22 +542,47 @@ export class PaneWidget implements IDestroyable, MouseEventHandlers {
 		return this._rightPriceAxisWidget;
 	}
 
+	public getCrosshairPosition(x: Coordinate, y: Coordinate): void {
+		this._model().setAndSaveCurrentPosition(this._correctXCoord(x), this._correctYCoord(y), ensureNotNull(this._state));
+	}
+
+	public setCrossHair(xx: number, yy: number, visible: boolean): void {
+		if (!this._state) {
+			return;
+		}
+		if (visible) {
+			const x = xx as Coordinate;
+			const y = yy as Coordinate;
+
+			this._setCrosshairPositionNoFire(x, y);
+		} else {
+			this._state.model().setHoveredSource(null);
+			this._clearCrosshairPosition();
+		}
+	}
+
+	public clearCrossHair(): void {
+		this._clearCrosshairPosition();
+	}
+
 	private _propagateEvent(type: InputEventType, event: TouchMouseEvent): void {
 		if (this._state === null) { return; }
 		this.setCursor(PaneCursorType.Crosshair);
 
+		const ctx = getContext2D(this.getImage());
+
 		// if (this._model().lineToolCreator().hasActiveToolLine()) {
-		this._model().lineToolCreator().onInputEvent(this, type, event);
+		this._model().lineToolCreator().onInputEvent(this, ctx, type, event);
 		// }
 
 		const sources = this._state.orderedSources();
 		for (let index = sources.length - 1; index >= 0; index--) {
 			const sourcePane = this._model().paneForSource(sources[index]);
 			if (sourcePane !== null) {
-				const paneViews = sources[index].paneViews(sourcePane as Pane);
+				const paneViews = sources[index].paneViews(sourcePane);
 				paneViews.forEach((pane: IPaneView) => {
 					if (isInputEventListener(pane)) {
-						pane.onInputEvent(this, type, event);
+						pane.onInputEvent(this, ctx, type, event);
 					}
 				});
 			}
@@ -671,7 +719,7 @@ export class PaneWidget implements IDestroyable, MouseEventHandlers {
 	}
 
 	private _preventCrosshairMove(): boolean {
-		return /*trackCrosshairOnlyAfterLongTap && */this._startTrackPoint === null;
+		return /* trackCrosshairOnlyAfterLongTap && */this._startTrackPoint === null;
 	}
 
 	private _preventScroll(event: TouchMouseEvent): boolean {
@@ -694,6 +742,10 @@ export class PaneWidget implements IDestroyable, MouseEventHandlers {
 		this._model().clearCurrentPosition();
 	}
 
+	private _setCrosshairPositionNoFire(x: Coordinate, y: Coordinate): void {
+		this._model().setAndSaveCurrentPositionFire(this._correctXCoord(x), this._correctYCoord(y), false, ensureNotNull(this._state));
+	}
+
 	private _tryExitTrackingMode(): void {
 		if (this._exitTrackingModeOnNextTry) {
 			this._startTrackPoint = null;
@@ -810,7 +862,7 @@ export class PaneWidget implements IDestroyable, MouseEventHandlers {
 			return;
 		}
 
-		const model = this._model();		
+		const model = this._model();
 		const x = event.localX;
 		const y = event.localY;
 
@@ -821,7 +873,7 @@ export class PaneWidget implements IDestroyable, MouseEventHandlers {
 			const newX = (origPoint.x + (x - this._startTrackPoint.x)) as Coordinate;
 			const newY = (origPoint.y + (y - this._startTrackPoint.y)) as Coordinate;
 			this._setCrosshairPosition(newX, newY);
-		//} else if (!this._preventCrosshairMove()) { // in case of mouse event, always return false in drawings repo
+		// } else if (!this._preventCrosshairMove()) { // in case of mouse event, always return false in drawings repo
 		} else {
 			this._setCrosshairPosition(x, y);
 		}
diff --git a/src/model/chart-model.ts b/src/model/chart-model.ts
index 97b41bf..c2db5e6 100644
--- a/src/model/chart-model.ts
+++ b/src/model/chart-model.ts
@@ -17,10 +17,10 @@ import { GridOptions } from './grid';
 import { InvalidateMask, InvalidationLevel } from './invalidate-mask';
 import { IPriceDataSource } from './iprice-data-source';
 import { ColorType, LayoutOptions, LayoutOptionsInternal } from './layout-options';
-import { LineTool, LineToolPoint } from './line-tool';
+import { LineTool, LineToolExport, LineToolPoint } from './line-tool';
+import { LineToolCreator } from './line-tool-creator';
 import { LineToolOptionsMap, LineToolType } from './line-tool-options';
 import { LineTools } from './line-tools';
-import { LineToolCreator } from './line-tool-creator';
 import { LocalizationOptions } from './localization-options';
 import { Magnet } from './magnet';
 import { DEFAULT_STRETCH_FACTOR, Pane } from './pane';
@@ -346,6 +346,8 @@ export class ChartModel implements IDestroyable {
 	private _hoveredSource: HoveredSource | null = null;
 	private readonly _priceScalesOptionsChanged: Delegate = new Delegate();
 	private _crosshairMoved: Delegate<TimePointIndex | null, Point | null> = new Delegate();
+	private _lineToolsDoubleClick: Delegate<LineToolExport<LineToolType>> = new Delegate();
+	private _lineToolsAfterEdit: Delegate<LineToolExport<LineToolType>, string> = new Delegate();
 
 	private _backgroundTopColor: string;
 	private _backgroundBottomColor: string;
@@ -483,6 +485,10 @@ export class ChartModel implements IDestroyable {
 		return this._timeScale;
 	}
 
+	public getActivePane(): Pane | null {
+		return this._panes.length > 0 ? this._panes[0] : null;
+	}
+
 	public panes(): readonly Pane[] {
 		return this._panes;
 	}
@@ -507,6 +513,14 @@ export class ChartModel implements IDestroyable {
 		return this._crosshairMoved;
 	}
 
+	public lineToolsDoubleClick(): ISubscription<LineToolExport<LineToolType>> {
+		return this._lineToolsDoubleClick;
+	}
+
+	public lineToolsAfterEdit(): ISubscription<LineToolExport<LineToolType>, string> {
+		return this._lineToolsAfterEdit;
+	}
+
 	public setPaneHeight(pane: Pane, height: number): void {
 		pane.setHeight(height);
 		this.recalculateAllPanes();
@@ -699,6 +713,30 @@ export class ChartModel implements IDestroyable {
 		this._crosshair.updateAllViews();
 	}
 
+	public setAndSaveCurrentPositionFire(x: Coordinate, y: Coordinate, fire: boolean, pane: Pane): void {
+		this._crosshair.saveOriginCoord(x, y);
+		let price = NaN;
+		let index = this._timeScale.coordinateToIndex(x);
+
+		const visibleBars = this._timeScale.visibleStrictRange();
+		if (visibleBars !== null) {
+			index = Math.min(Math.max(visibleBars.left(), index), visibleBars.right()) as TimePointIndex;
+		}
+
+		const priceScale = pane.defaultPriceScale();
+		const firstValue = priceScale.firstValue();
+		if (firstValue !== null) {
+			price = priceScale.coordinateToPrice(y, firstValue);
+		}
+		price = this._magnet.align(price, index, pane);
+
+		this._crosshair.setPosition(index, price, pane);
+		this.cursorUpdate();
+		if (fire) {
+			this._crosshairMoved.fire(this._crosshair.appliedIndex(), new Point(x, y));
+		}
+	}
+
 	public updateTimeScale(newBaseIndex: TimePointIndex | null, newPoints?: readonly TimeScalePoint[], firstChangedPointIndex?: number): void {
 		const oldFirstTime = this._timeScale.indexToTime(0 as TimePointIndex);
 
@@ -747,6 +785,14 @@ export class ChartModel implements IDestroyable {
 		this.updateCrosshair();
 	}
 
+	public fireLineToolsDoubleClick(selectedLineTools: LineToolExport<LineToolType>): void {
+		this._lineToolsDoubleClick.fire(selectedLineTools);
+	}
+
+	public fireLineToolsAfterEdit(selectedLineTools: LineToolExport<LineToolType>, stage: string): void {
+		this._lineToolsAfterEdit.fire(selectedLineTools, stage);
+	}
+
 	public destroy(): void {
 		this._panes.forEach((p: Pane) => p.destroy());
 		this._panes.length = 0;
diff --git a/src/model/line-tool-creator.ts b/src/model/line-tool-creator.ts
index 5b63d7e..610517f 100644
--- a/src/model/line-tool-creator.ts
+++ b/src/model/line-tool-creator.ts
@@ -30,6 +30,7 @@ export class LineToolCreator implements IInputEventListener {
 				source.setSelected(false);
 				source.setHovered(false);
 				source.setEditing(false);
+				source.setCreating(false);
 			}
 		});
 		this._model.lightUpdate();
@@ -39,7 +40,7 @@ export class LineToolCreator implements IInputEventListener {
 		return this._activeType !== null;
 	}
 
-	public onInputEvent(paneWidget: PaneWidget, eventType: InputEventType, event: TouchMouseEvent): void {
+	public onInputEvent(paneWidget: PaneWidget, ctx: CanvasRenderingContext2D, eventType: InputEventType, event: TouchMouseEvent): void {
 		if (!this._activeType || !this._activeOptions) { return; }
 		event.consumed = true;
 		if (eventType !== InputEventType.MouseDown) { return; }
diff --git a/src/model/line-tool-highlighter.ts b/src/model/line-tool-highlighter.ts
index b13ca16..02135a8 100644
--- a/src/model/line-tool-highlighter.ts
+++ b/src/model/line-tool-highlighter.ts
@@ -11,6 +11,7 @@ export class LineToolHighlighter extends LineToolBrush {
 		const options = this.options();
 		return {
 			visible: options.visible,
+			editable: options.editable,
 			line: {
 				width: 20 as LineWidth,
 				cap: LineCap.Round,
diff --git a/src/model/line-tool-options.ts b/src/model/line-tool-options.ts
index 8d7bf7c..43b941a 100644
--- a/src/model/line-tool-options.ts
+++ b/src/model/line-tool-options.ts
@@ -354,6 +354,11 @@ export interface FibRetracementLevel {
 	 * Level color.
 	 */
 	color: string;
+
+    /**
+     * Opacity of the background.
+     */
+	opacity: number;
 }
 
 export interface LineToolOptionsCommon {
@@ -364,6 +369,13 @@ export interface LineToolOptionsCommon {
 	 */
 	visible: boolean;
 
+	/**
+	 * Can the line be edited.
+	 *
+	 * @defaultValue `true`
+	 */
+	editable: boolean;
+
 	/**
 	 * The owner source id.
 	 */
diff --git a/src/model/line-tool-path.ts b/src/model/line-tool-path.ts
index d3daac7..e59afc5 100644
--- a/src/model/line-tool-path.ts
+++ b/src/model/line-tool-path.ts
@@ -19,7 +19,7 @@ export class LineToolPath extends LineTool<'Path'> {
 	}
 
 	public override tryFinish(): void {
-		if (this._points.length > 0) {
+		if (this._points.length > 1) {
 			const point0 = this._points[this._points.length - 1];
 			const point1 = this._points[this._points.length - 2];
 			const screenPoint0 = ensureNotNull(this.pointToScreenPoint(point0));
diff --git a/src/model/line-tool.ts b/src/model/line-tool.ts
index dba58db..a418120 100644
--- a/src/model/line-tool.ts
+++ b/src/model/line-tool.ts
@@ -6,25 +6,23 @@ import { DeepPartial, merge } from '../helpers/strict-type-checks';
 
 import { IPaneView } from '../views/pane/ipane-view';
 import { IUpdatablePaneView } from '../views/pane/iupdatable-pane-view';
-import { PriceAxisView } from '../views/price-axis/price-axis-view';
 import { LineToolPriceAxisBackgroundView } from '../views/price-axis/line-tool-price-axis-background-view';
 import { LineToolPriceAxisLabelView } from '../views/price-axis/line-tool-price-axis-label-view';
+import { PriceAxisView } from '../views/price-axis/price-axis-view';
 import { ITimeAxisView } from '../views/time-axis/itime-axis-view';
 import { LineToolTimeAxisBackgroundView } from '../views/time-axis/line-tool-time-axis-background-view';
 import { LineToolTimeAxisLabelView } from '../views/time-axis/line-tool-time-axis-label-view';
 
 import { AutoscaleInfoImpl } from './autoscale-info-impl';
 import { ChartModel } from './chart-model';
-//import { DataSource } from './data-source';
-import { PriceDataSource } from './price-data-source';
 import { FirstValue, IPriceDataSource } from './iprice-data-source';
 import { LineToolOptionsCommon, LineToolOptionsMap, LineToolPartialOptionsMap, LineToolType } from './line-tool-options';
 import { Pane, PaneCursorType } from './pane';
 import { Point } from './point';
+import { PriceDataSource } from './price-data-source';
 import { PriceScale } from './price-scale';
-import { UTCTimestamp } from './time-data';
+import { TimePointIndex, UTCTimestamp } from './time-data';
 import { TimeScale } from './time-scale';
-import { TimePointIndex } from './time-data';
 
 export interface LineToolPoint {
 	price: number;
@@ -42,18 +40,23 @@ export interface LineToolHitTestData {
 	cursorType: PaneCursorType;
 }
 
+export interface LineToolExport<T extends LineToolType> {
+	id: string;
+	toolType: LineToolType;
+	options: LineToolOptionsInternal<T>;
+	points: LineToolPoint[];
+}
+
 export type LineToolOptionsInternal<T extends LineToolType> = LineToolOptionsMap[T];
 export type LineToolPartialOptionsInternal<T extends LineToolType> = LineToolPartialOptionsMap[T];
 
-//export abstract class LineTool<T extends LineToolType = LineToolType> extends DataSource implements IDestroyable {
+// export abstract class LineTool<T extends LineToolType = LineToolType> extends DataSource implements IDestroyable {
 export abstract class LineTool<T extends LineToolType = LineToolType> extends PriceDataSource implements IDestroyable {
 	protected _pointChanged: Delegate = new Delegate();
 	protected _pointAdded: Delegate = new Delegate();
 	protected _priceAxisViews: PriceAxisView[] = [];
 	protected _timeAxisViews: ITimeAxisView[] = [];
 	protected _paneViews: IUpdatablePaneView[] = [];
-	
-	private _formatter!: IPriceFormatter;
 
 	protected readonly _options: LineToolOptionsInternal<T>;
 	protected readonly _toolType!: LineToolType;
@@ -62,15 +65,18 @@ export abstract class LineTool<T extends LineToolType = LineToolType> extends Pr
 	protected _selected: boolean = false;
 	protected _finished: boolean = false;
 	protected _editing: boolean = false;
+	protected _creating: boolean = false;
 
 	protected _ownerSource: IPriceDataSource | null = null;
 	protected _lastPoint: LineToolPoint | null = null;
 	protected _points: LineToolPoint[] = [];
-	//protected _model: ChartModel;
+	// protected _model: ChartModel;
+
+	private _formatter!: IPriceFormatter;
 
 	public constructor(model: ChartModel, options: LineToolOptionsInternal<T>, points: LineToolPoint[] = []) {
 		super(model);
-		//this._model = model;
+		// this._model = model;
 		this._points = points;
 		this._options = options;
 
@@ -88,6 +94,9 @@ export abstract class LineTool<T extends LineToolType = LineToolType> extends Pr
 		// this._ownerSource = model.serieses().find((series: IPriceDataSource) => series.id() === this._options.ownerSourceId) || null;
 		this._ownerSource = model.serieses()[0];
 		this._finished = this._points.length >= (this.pointsCount() === -1 ? 2 : this.pointsCount());
+		// if no point is provided, we consider that linetool is being created and the call to tryFinish will set it to false afterwards.
+		// if points are provided, just get the inverse of _finished value.
+		this._creating = this._points.length === 0 ? true : !this.finished();
 	}
 
 	public abstract pointsCount(): number;
@@ -100,6 +109,7 @@ export abstract class LineTool<T extends LineToolType = LineToolType> extends Pr
 		if (this._points.length >= Math.max(1, this.pointsCount())) {
 			this._finished = true;
 			this._selected = true;
+			this._creating = false;
 			this._lastPoint = null;
 			this.model().updateSource(this);
 		}
@@ -245,6 +255,16 @@ export abstract class LineTool<T extends LineToolType = LineToolType> extends Pr
 		return changed;
 	}
 
+	public creating(): boolean {
+		return this._creating;
+	}
+
+	public setCreating(creating: boolean): boolean {
+		const changed = creating !== this._creating;
+		this._creating = creating;
+		return changed;
+	}
+
 	// public model(): ChartModel {
 		// return this._model;
 	// }
@@ -286,30 +306,33 @@ export abstract class LineTool<T extends LineToolType = LineToolType> extends Pr
 	public hasMagnet(): boolean {
 		return true;
 	}
-	
+
 	// implementation of IPriceDataSource
-	
 	public minMove(): number {
 		return 0;
-		// return this._options.priceFormat.minMove; // Shinobaki : TODO
+		// return this._options.priceFormat.minMove;
 	}
 
 	public autoscaleInfo(startTimePoint: TimePointIndex, endTimePoint: TimePointIndex): AutoscaleInfoImpl | null {
 		return null;
 	}
 
-	public firstValue(): FirstValue | null  {
+	public firstValue(): FirstValue | null {
 		return null;
 	}
-	
+
 	public formatter(): IPriceFormatter {
 		return this._formatter;
 	}
-	
+
 	public priceLineColor(lastBarColor: string): string {
 		return lastBarColor;
 	}
 
+	public exportLineToolToLineToolExport(): LineToolExport<T> {
+		return { id: this.id(), toolType: this._toolType, options: this.options(), points: this.points() };
+	}
+
 	protected _setPaneViews(paneViews: IUpdatablePaneView[]): void {
 		this._paneViews = paneViews;
 	}
diff --git a/src/model/magnet.ts b/src/model/magnet.ts
index 6360df3..9962316 100644
--- a/src/model/magnet.ts
+++ b/src/model/magnet.ts
@@ -9,7 +9,7 @@ import { Series } from './series';
 import { TimePointIndex } from './time-data';
 
 export class Magnet {
-	private _enabled: boolean = false;
+	private _enabled: boolean = true;
 	private readonly _options: CrosshairOptions;
 
 	public constructor(options: CrosshairOptions) {
@@ -78,7 +78,7 @@ export class Magnet {
 		candidates.sort((y1: Coordinate, y2: Coordinate) => Math.abs(y1 - y) - Math.abs(y2 - y));
 
 		const nearest = candidates[0];
-		//res = defaultPriceScale.coordinateToPrice(nearest, firstValue);
+		// res = defaultPriceScale.coordinateToPrice(nearest, firstValue);
 		if (Math.abs(nearest - y) < this._options.magnetThreshold) {
 			res = defaultPriceScale.coordinateToPrice(nearest, firstValue);
 		}
diff --git a/src/model/pane.ts b/src/model/pane.ts
index d221159..37df8e8 100644
--- a/src/model/pane.ts
+++ b/src/model/pane.ts
@@ -8,6 +8,8 @@ import { ChartModel, ChartOptions, OverlayPriceScaleOptions, VisiblePriceScaleOp
 import { DefaultPriceScaleId, isDefaultPriceScale } from './default-price-scale';
 import { Grid } from './grid';
 import { IPriceDataSource } from './iprice-data-source';
+import { LineTool } from './line-tool';
+import { LineToolType } from './line-tool-options';
 import { PriceScale, PriceScaleOptions, PriceScaleState } from './price-scale';
 import { sortSources } from './sort-sources';
 import { TimeScale } from './time-scale';
@@ -33,6 +35,7 @@ export enum PaneCursorType {
 	HorizontalResize = 'e-resize',
 	DiagonalNeSwResize = 'nesw-resize',
 	DiagonalNwSeResize = 'nwse-resize',
+	NotAllowed = 'not-allowed',
 }
 
 export class Pane implements IDestroyable {
@@ -215,6 +218,19 @@ export class Pane implements IDestroyable {
 		this._cachedOrderedSources = null;
 	}
 
+	public getAllLineTools(): LineTool<LineToolType>[] {
+		return this._dataSources.filter((s: IPriceDataSource) => s instanceof LineTool).map((s: IPriceDataSource) => (s as LineTool<LineToolType>));
+	}
+
+	public getLineTool(id: string): LineTool<LineToolType> | null {
+		const lineTools = this._dataSources.filter((s: IPriceDataSource) => s instanceof LineTool && s.id() === id).map((s: IPriceDataSource) => (s as LineTool<LineToolType>));
+		return lineTools.length > 0 ? lineTools[0] : null;
+	}
+
+	public getSelectedLineTools(): LineTool<LineToolType>[] {
+		return this._dataSources.filter((s: IPriceDataSource) => s instanceof LineTool && (s as LineTool).selected()).map((s: IPriceDataSource) => (s as LineTool<LineToolType>));
+	}
+
 	public priceScalePosition(priceScale: PriceScale): PriceScalePosition {
 		if (priceScale === this._leftPriceScale) {
 			return 'left';
diff --git a/src/model/price-line-options.ts b/src/model/price-line-options.ts
index c46e0ea..6b43aa2 100644
--- a/src/model/price-line-options.ts
+++ b/src/model/price-line-options.ts
@@ -46,4 +46,16 @@ export interface PriceLineOptions {
 	 * @defaultValue `''`
 	 */
 	title: string;
+	/**
+	 * Whether the price line is a ray.
+	 *
+	 * @defaultValue `false`
+	 */
+	ray: boolean;
+	/**
+	 * Ray start date as a number.
+	 *
+	 * @defaultValue `0`
+	 */
+	rayStart: number;
 }
diff --git a/src/renderers/composite-renderer.ts b/src/renderers/composite-renderer.ts
index 3bd9341..f747eb4 100644
--- a/src/renderers/composite-renderer.ts
+++ b/src/renderers/composite-renderer.ts
@@ -1,12 +1,12 @@
 import { Coordinate } from '../model/coordinate';
 import { HitTestResult } from '../model/hit-test-result';
+
 import { IPaneRenderer } from './ipane-renderer';
 
 export class CompositeRenderer implements IPaneRenderer {
 	private _renderers: IPaneRenderer[] = [];
 	private _globalAlpha: number = 1;
 
-
 	public setGlobalAlpha(value: number): void {
 		this._globalAlpha = value;
 	}
@@ -26,7 +26,7 @@ export class CompositeRenderer implements IPaneRenderer {
 	public isEmpty(): boolean {
 		return this._renderers.length === 0;
 	}
-	
+
 	public setRenderers(renderers: IPaneRenderer[]): void {
 		this._renderers = renderers;
 	}
@@ -40,12 +40,12 @@ export class CompositeRenderer implements IPaneRenderer {
 		});
 	}
 
-	public hitTest(x: Coordinate, y: Coordinate): HitTestResult<unknown> | null {
+	public hitTest(x: Coordinate, y: Coordinate, ctx: CanvasRenderingContext2D): HitTestResult<unknown> | null {
 		let result = null;
 		for (let i = this._renderers.length - 1; i >= 0; i--) {
 			const renderer = this._renderers[i];
 			if (renderer.hitTest) {
-				result = renderer.hitTest(x, y) || null;
+				result = renderer.hitTest(x, y, ctx) || null;
 			}
 			if (result) { break; }
 		}
diff --git a/src/renderers/draw-line.ts b/src/renderers/draw-line.ts
index f2a068c..6592659 100644
--- a/src/renderers/draw-line.ts
+++ b/src/renderers/draw-line.ts
@@ -85,14 +85,36 @@ export const enum LineStyle {
 
 export function computeDashPattern(ctx: CanvasRenderingContext2D): number[] {
 	return [
-		[ctx.lineWidth, 2 * ctx.lineWidth],
-		[5 * ctx.lineWidth, 6 * ctx.lineWidth],
+		[ctx.lineWidth, ctx.lineWidth],
+		[2 * ctx.lineWidth, 2 * ctx.lineWidth],
 		[6 * ctx.lineWidth, 6 * ctx.lineWidth],
 		[ctx.lineWidth, 4 * ctx.lineWidth],
 		[2 * ctx.lineWidth, ctx.lineWidth],
 	][ctx.lineStyle - 1] || [];
 }
 
+export function computeEndLineSize(lineWidth: number): number {
+	let endLineMultiplier = 1;
+	switch (lineWidth) {
+		case 1:
+			endLineMultiplier = 3.5;
+			break;
+		case 2:
+			endLineMultiplier = 2;
+			break;
+		case 3:
+			endLineMultiplier = 1.5;
+			break;
+		case 4:
+			endLineMultiplier = 1.25;
+			break;
+		case 0:
+		default:
+			break;
+	}
+	return endLineMultiplier;
+}
+
 export function setLineStyle(ctx: CanvasRenderingContext2D, style: LineStyle): void {
 	ctx.lineStyle = style;
 	const dashPattern = computeDashPattern(ctx);
@@ -191,10 +213,11 @@ export function extendAndClipLineSegment(point0: Point, point1: Point, width: nu
 }
 
 export function drawCircleEnd(point: Point, ctx: CanvasRenderingContext2D, width: number, pixelRatio: number): void {
+	const circleEndMultiplier = computeEndLineSize(width);
 	ctx.save();
 	ctx.fillStyle = '#000000';
 	ctx.beginPath();
-	ctx.arc(point.x * pixelRatio, point.y * pixelRatio, width * pixelRatio, 0, 2 * Math.PI, false);
+	ctx.arc(point.x * pixelRatio, point.y * pixelRatio, width * circleEndMultiplier * pixelRatio, 0, 2 * Math.PI, false);
 	ctx.fill();
 	ctx.restore();
 }
@@ -214,7 +237,8 @@ export function getArrowPoints(point0: Point, point1: Point, width: number): [[P
 	const n = Math.sqrt(2);
 	const o = point1.subtract(point0);
 	const a = o.normalized();
-	const l = 5 * width;
+	const arrowheadMultiplier = computeEndLineSize(width);
+	const l = 5 * width * arrowheadMultiplier;
 	const c = 1 * r;
 
 	if (l * n * 0.2 <= c) { return []; }
diff --git a/src/renderers/draw-rect.ts b/src/renderers/draw-rect.ts
index a64fcc6..5a98fa2 100644
--- a/src/renderers/draw-rect.ts
+++ b/src/renderers/draw-rect.ts
@@ -3,7 +3,7 @@ import { Point } from '../model/point';
 import { LineStyle } from '..';
 import { setLineStyle } from './draw-line';
 
-export function drawRoundRect(ctx: CanvasRenderingContext2D, x: number, y: number, width: number, height: number, radius: number | number[]): void {
+export function drawRoundRect(ctx: CanvasRenderingContext2D, x: number, y: number, width: number, height: number, radius: number | number[], borderStyle?: number): void {
 	let a; let b; let c; let d;
 
 	if (Array.isArray(radius)) {
@@ -30,6 +30,9 @@ export function drawRoundRect(ctx: CanvasRenderingContext2D, x: number, y: numbe
 	}
 
 	ctx.beginPath();
+
+	setLineStyle(ctx, borderStyle || LineStyle.Solid);
+
 	ctx.moveTo(x + a, y);
 	ctx.lineTo(x + width - b, y);
 	if (b !== 0) { ctx.arcTo(x + width, y, x + width, y + b, b); }
@@ -39,6 +42,7 @@ export function drawRoundRect(ctx: CanvasRenderingContext2D, x: number, y: numbe
 	if (d !== 0) { ctx.arcTo(x, y + height, x, y + height - d, d); }
 	ctx.lineTo(x, y + a);
 	if (a !== 0) { ctx.arcTo(x, y, x + a, y, a); }
+	ctx.stroke();
 }
 
 // eslint-disable-next-line max-params
diff --git a/src/renderers/horizontal-line-renderer.ts b/src/renderers/horizontal-line-renderer.ts
index 11176f4..2b74bfc 100644
--- a/src/renderers/horizontal-line-renderer.ts
+++ b/src/renderers/horizontal-line-renderer.ts
@@ -12,6 +12,8 @@ export interface HorizontalLineRendererData {
 	y: Coordinate;
 	visible?: boolean;
 	width: number;
+	ray: boolean;
+	rayStart: number;
 }
 
 export class HorizontalLineRenderer implements IPaneRenderer {
@@ -36,11 +38,17 @@ export class HorizontalLineRenderer implements IPaneRenderer {
 			return;
 		}
 
+		let start = 0;
+
+		if (this._data.ray === true) {
+			start = this._data.rayStart;
+		}
+
 		const width = Math.ceil(this._data.width * pixelRatio);
 		ctx.lineCap = 'butt';
 		ctx.strokeStyle = this._data.color;
 		ctx.lineWidth = Math.floor(this._data.lineWidth * pixelRatio);
 		setLineStyle(ctx, this._data.lineStyle);
-		drawHorizontalLine(ctx, y, 0, width);
+		drawHorizontalLine(ctx, y, start, width);
 	}
 }
diff --git a/src/renderers/ipane-renderer.ts b/src/renderers/ipane-renderer.ts
index a28960c..28672ac 100644
--- a/src/renderers/ipane-renderer.ts
+++ b/src/renderers/ipane-renderer.ts
@@ -1,8 +1,8 @@
-import { HitTestResult } from '../model/hit-test-result';
 import { Coordinate } from '../model/coordinate';
+import { HitTestResult } from '../model/hit-test-result';
 
 export interface IPaneRenderer {
 	draw(ctx: CanvasRenderingContext2D, pixelRatio: number, isHovered: boolean, hitTestData?: unknown): void;
 	drawBackground?(ctx: CanvasRenderingContext2D, pixelRatio: number, isHovered: boolean, hitTestData?: unknown): void;
-	hitTest?(x: Coordinate, y: Coordinate): HitTestResult<unknown> | null;
+	hitTest?(x: Coordinate, y: Coordinate, ctx: CanvasRenderingContext2D): HitTestResult<unknown> | null;
 }
diff --git a/src/renderers/polygon-renderer.ts b/src/renderers/polygon-renderer.ts
index e9231d3..78fce42 100644
--- a/src/renderers/polygon-renderer.ts
+++ b/src/renderers/polygon-renderer.ts
@@ -62,7 +62,7 @@ export class PolygonRenderer extends ScaledRenderer {
 
 	// eslint-disable-next-line complexity
 	protected _drawImpl(ctx: CanvasRenderingContext2D, isHovered: boolean, hitTestData?: unknown): void {
-		if (this._data === null || !this._data.points) { return; }
+		if (this._data === null || !this._data.points || !this._data.points.length) { return; }
 
 		const pointsCount = this._data.points.length;
 		const lineStyle = this._data.line.style || LineStyle.Solid;
diff --git a/src/renderers/rectangle-renderer.ts b/src/renderers/rectangle-renderer.ts
index 4bd85fa..518f362 100644
--- a/src/renderers/rectangle-renderer.ts
+++ b/src/renderers/rectangle-renderer.ts
@@ -9,11 +9,12 @@ import { Box, equalPoints, Point, Segment } from '../model/point';
 
 import { LineStyle } from '..';
 import { fillRectWithBorder } from './draw-rect';
+import { IPaneRenderer } from './ipane-renderer';
 import { AnchorPoint } from './line-anchor-renderer';
 
 export type RectangleRendererData = DeepPartial<RectangleOptions> & { points: AnchorPoint[]; hitTestBackground?: boolean };
 
-export class RectangleRenderer {
+export class RectangleRenderer implements IPaneRenderer {
 	protected _backHitTest: HitTestResult<void>;
 	protected _hitTest: HitTestResult<void>;
 	protected _data: RectangleRendererData | null;
@@ -28,18 +29,19 @@ export class RectangleRenderer {
 		this._data = data;
 	}
 
-	public hitTest(x: Coordinate, y: Coordinate): HitTestResult<void> | null {
+	public hitTest(x: Coordinate, y: Coordinate, ctx: CanvasRenderingContext2D): HitTestResult<void> | null {
 		if (null === this._data || this._data.points.length < 2) { return null; }
-		const pixelRatio = 1;
+		const pixelRatio = ctx.canvas.ownerDocument && ctx.canvas.ownerDocument.defaultView && ctx.canvas.ownerDocument.defaultView.devicePixelRatio || 1;
+		const physicalWidth = ctx.canvas.width;
 		const scaledPoint = new Point(x, y);
 		const [topLeft, bottomRight] = this._getPointsInPhysicalSpace(pixelRatio);
 		const topRight = new Point(bottomRight.x, topLeft.y);
 		const bottomLeft = new Point(topLeft.x, bottomRight.y);
 
-		const topLineHitResult = this._extendAndHitTestLineSegment(scaledPoint, topLeft, topRight, pixelRatio);
+		const topLineHitResult = this._extendAndHitTestLineSegment(scaledPoint, topLeft, topRight, physicalWidth);
 		if (topLineHitResult !== null) { return topLineHitResult; }
 
-		const bottomLineHitResult = this._extendAndHitTestLineSegment(scaledPoint, bottomLeft, bottomRight, pixelRatio);
+		const bottomLineHitResult = this._extendAndHitTestLineSegment(scaledPoint, bottomLeft, bottomRight, physicalWidth);
 		if (bottomLineHitResult !== null) { return bottomLineHitResult; }
 
 		const rightSegmentDistance = distanceToSegment(topRight, bottomRight, scaledPoint);
@@ -48,7 +50,7 @@ export class RectangleRenderer {
 		const leftSegmentDistance = distanceToSegment(topLeft, bottomLeft, scaledPoint);
 		if (leftSegmentDistance.distance <= 3) { return this._hitTest; }
 
-		const backgroundHitResult = this._hitTestBackground(scaledPoint, topLeft, bottomRight, pixelRatio);
+		const backgroundHitResult = this._hitTestBackground(scaledPoint, topLeft, bottomRight, physicalWidth);
 		if (this._data.hitTestBackground && backgroundHitResult !== null) { return backgroundHitResult; }
 
 		return null;
@@ -67,7 +69,7 @@ export class RectangleRenderer {
 		const [point0, point1] = this._getPointsInPhysicalSpace(pixelRatio);
 		const { left, right } = this._data.extend || {};
 
-		const physicalWidth = 1;
+		const physicalWidth = ctx.canvas.width;
 		fillRectWithBorder(ctx, point0, point1, background, borderColor, scaledBorderWidth, borderStyle, 'center', !!left, !!right, physicalWidth);
 		ctx.restore();
 	}
@@ -86,11 +88,10 @@ export class RectangleRenderer {
 		return [new Point(scaledMinX, scaledMinY), new Point(scaledMax, scaledMaxY)];
 	}
 
-	protected _extendAndClipLineSegment(end0: Point, end1: Point, pixelRatio: number): Segment | null {
+	protected _extendAndClipLineSegment(end0: Point, end1: Point, physicalWidth: number): Segment | null {
 		const data = ensureNotNull(this._data);
 		if (equalPoints(end0, end1)) { return null; }
 
-		const physicalWidth = 1;
 		const minX = Math.min(end0.x, end1.x);
 		const maxX = Math.max(end0.x, end1.x);
 		const x1 = data.extend?.left ? 0 : Math.max(minX, 0);
@@ -98,14 +99,14 @@ export class RectangleRenderer {
 		return x1 > x2 || x2 <= 0 || x1 >= physicalWidth ? null : [new Point(x1, end0.y), new Point(x2, end1.y)];
 	}
 
-	protected _extendAndHitTestLineSegment(point: Point, end0: Point, end1: Point, pixelRatio: number): HitTestResult<void> | null {
-		const line = this._extendAndClipLineSegment(end0, end1, pixelRatio);
+	protected _extendAndHitTestLineSegment(point: Point, end0: Point, end1: Point, physicalWidth: number): HitTestResult<void> | null {
+		const line = this._extendAndClipLineSegment(end0, end1, physicalWidth);
 		if (line !== null && distanceToSegment(line[0], line[1], point).distance <= 3) { return this._hitTest; }
 		return null;
 	}
 
-	protected _hitTestBackground(point: Point, end0: Point, end1: Point, pixelRatio: number): HitTestResult<void> | null {
-		const line = this._extendAndClipLineSegment(end0, end1, pixelRatio);
+	protected _hitTestBackground(point: Point, end0: Point, end1: Point, physicalWidth: number): HitTestResult<void> | null {
+		const line = this._extendAndClipLineSegment(end0, end1, physicalWidth);
 		return line !== null && pointInBox(point, new Box(line[0], line[1])) ? this._backHitTest : null;
 	}
 }
diff --git a/src/renderers/text-renderer.ts b/src/renderers/text-renderer.ts
index 69b08e0..18c575e 100644
--- a/src/renderers/text-renderer.ts
+++ b/src/renderers/text-renderer.ts
@@ -8,7 +8,6 @@ import { pointInBox, pointInPolygon } from '../model/interesection';
 import { BoxHorizontalAlignment, BoxVerticalAlignment, TextAlignment, TextOptions } from '../model/line-tool-options';
 import { Box, Point, Rect } from '../model/point';
 
-import { LineStyle, setLineStyle } from './draw-line';
 import { drawRoundRect } from './draw-rect';
 import { IPaneRenderer } from './ipane-renderer';
 
@@ -175,10 +174,12 @@ export class TextRenderer implements IPaneRenderer {
 		const textData = this._data.text;
 		const internalData = this._getInternalData();
 		const pivot = this._getRotationPoint().scaled(pixelRatio);
+		const angleDegrees = textData.box?.angle || 0;
+		const angle = -angleDegrees * Math.PI / 180;
 
 		ctx.save();
 		ctx.translate(pivot.x, pivot.y);
-		ctx.rotate(textData.box?.angle || 0);
+		ctx.rotate(angle);
 		ctx.translate(-pivot.x, -pivot.y);
 
 		const fontSize = this._getFontInfo().fontSize;
@@ -206,48 +207,28 @@ export class TextRenderer implements IPaneRenderer {
 				ctxUpdated = true;
 			}
 
-			if (textData.box.border?.radius) {
-				if (textData.box.background?.color) {
-					const radius = textData.box?.border?.radius * pixelRatio;
-					drawRoundRect(ctx, scaledLeft, scaledTop, scaledRight - scaledLeft, scaledBottom - scaledTop, radius);
-					ctx.fillStyle = textData.box?.background?.color;
-					ctx.fill();
-					if (ctxUpdated) { ctx.restore(); ctxUpdated = false; }
-				}
-
+			if (textData.box.border?.width) {
 				if (textData.box.border?.color) {
-					const radius = textData.box?.border?.radius * pixelRatio + borderWidth;
-					drawRoundRect(ctx, scaledLeft - halfBorderWidth, scaledTop - halfBorderWidth, scaledRight - scaledLeft + borderWidth, scaledBottom - scaledTop + borderWidth, radius);
 					ctx.strokeStyle = textData.box.border.color;
-					ctx.lineWidth = borderWidth;
-					if (ctxUpdated) { ctx.restore(); ctxUpdated = false; }
-				}
-			} else if (textData.box.background?.color) {
-				ctx.fillStyle = textData.box.background.color;
-				ctx.fillRect(scaledLeft, scaledTop, scaledRight - scaledLeft, scaledBottom - scaledTop);
-				if (ctxUpdated) { ctx.restore(); ctxUpdated = false; }
-			} else if (textData.box?.border?.color || textData.box?.border?.highlight) {
-				let usedBorderWidth;
-				if (textData.box?.border?.color) {
-					ctx.strokeStyle = textData.box?.border?.color;
-					usedBorderWidth = borderWidth;
-				} else {
-					ctx.strokeStyle = textData.font?.color as string;
-					setLineStyle(ctx, LineStyle.Dashed);
-					usedBorderWidth = Math.max(1, Math.floor(pixelRatio));
 				}
+				ctx.lineWidth = borderWidth;
 
-				ctx.lineWidth = usedBorderWidth;
+				const radius = textData.box?.border?.radius ?? 0 * pixelRatio + borderWidth;
+				const textBoxBorderStyle = textData.box?.border?.style;
+				drawRoundRect(ctx, scaledLeft - halfBorderWidth, scaledTop - halfBorderWidth, scaledRight - scaledLeft + borderWidth, scaledBottom - scaledTop + borderWidth, radius, textBoxBorderStyle);
 
-				ctx.beginPath();
-				ctx.moveTo(scaledLeft - usedBorderWidth / 2, scaledTop - usedBorderWidth / 2);
-				ctx.lineTo(scaledLeft - usedBorderWidth / 2, scaledBottom + usedBorderWidth / 2);
-				ctx.lineTo(scaledRight + usedBorderWidth / 2, scaledBottom + usedBorderWidth / 2);
-				ctx.lineTo(scaledRight + usedBorderWidth / 2, scaledTop - usedBorderWidth / 2);
-				ctx.lineTo(scaledLeft - usedBorderWidth / 2, scaledTop - usedBorderWidth / 2);
-				ctx.stroke();
+				if (textData.box.background?.color) {
+					ctx.fillStyle = textData.box.background.color;
+					ctx.fill();
+				}
 
-				if (ctxUpdated) { ctx.restore(); }
+				if (ctxUpdated) { ctx.restore(); ctxUpdated = false; }
+			} else {
+				if (textData.box.background?.color) {
+					ctx.fillStyle = textData.box.background.color;
+					ctx.fillRect(scaledLeft, scaledTop, scaledRight - scaledLeft, scaledBottom - scaledTop);
+				}
+				if (ctxUpdated) { ctx.restore(); ctxUpdated = false; }
 			}
 		}
 
@@ -284,13 +265,13 @@ export class TextRenderer implements IPaneRenderer {
 		let anchorX = anchor.x as number;
 
 		switch (data.text?.box?.alignment?.vertical) {
-			case BoxVerticalAlignment.Bottom:
+			case BoxVerticalAlignment.Top:
 				anchorY -= boxHeight + (data.text?.box?.offset?.y || 0);
 				break;
 			case BoxVerticalAlignment.Middle:
 				anchorY -= boxHeight / 2;
 				break;
-			case BoxVerticalAlignment.Top:
+			case BoxVerticalAlignment.Bottom:
 				anchorY += (data.text?.box?.offset?.y || 0);
 		}
 
@@ -309,6 +290,7 @@ export class TextRenderer implements IPaneRenderer {
 				anchorX -= boxWidth + (data.text?.box?.offset?.x || 0);
 		}
 		switch (ensureDefined(data.text?.alignment)) {
+			case TextAlignment.Start:
 			case TextAlignment.Left: {
 				textAlign = TextAlignment.Start;
 				textX = anchorX + inflationPaddingX;
@@ -328,6 +310,7 @@ export class TextRenderer implements IPaneRenderer {
 				textX = anchorX + boxWidth / 2;
 				break;
 			case TextAlignment.Right:
+			case TextAlignment.End:
 				textAlign = TextAlignment.End;
 				textX = anchorX + boxWidth - inflationPaddingX;
 				if (isRtl() && data.text?.forceTextAlign) {
@@ -411,7 +394,8 @@ export class TextRenderer implements IPaneRenderer {
 
 		const { boxLeft, boxTop, boxWidth, boxHeight } = this._getInternalData();
 		const pivot = this._getRotationPoint();
-		const angle = this._data.text?.box?.angle || 0;
+		const angleDegrees = this._data.text?.box?.angle || 0;
+		const angle = -angleDegrees * Math.PI / 180;
 		this._polygonPoints = [
 			rotatePoint(new Point(boxLeft, boxTop), pivot, angle),
 			rotatePoint(new Point(boxLeft + boxWidth, boxTop), pivot, angle),
@@ -442,10 +426,10 @@ export class TextRenderer implements IPaneRenderer {
 			case BoxVerticalAlignment.Middle:
 				y = boxTop + boxHeight / 2;
 				break;
-			case BoxVerticalAlignment.Top:
+			case BoxVerticalAlignment.Bottom:
 				y = boxTop;
 				break;
-			case BoxVerticalAlignment.Bottom:
+			case BoxVerticalAlignment.Top:
 				y = boxTop + boxHeight;
 		}
 		return new Point(x, y);
diff --git a/src/views/pane/custom-price-line-pane-view.ts b/src/views/pane/custom-price-line-pane-view.ts
index ba1ccc0..63fd771 100644
--- a/src/views/pane/custom-price-line-pane-view.ts
+++ b/src/views/pane/custom-price-line-pane-view.ts
@@ -1,5 +1,7 @@
+import { Coordinate } from '../../model/coordinate';
 import { CustomPriceLine } from '../../model/custom-price-line';
 import { Series } from '../../model/series';
+import { UTCTimestamp } from '../../model/time-data';
 
 import { SeriesHorizontalLinePaneView } from './series-horizontal-line-pane-view';
 
@@ -11,6 +13,11 @@ export class CustomPriceLinePaneView extends SeriesHorizontalLinePaneView {
 		this._priceLine = priceLine;
 	}
 
+	public xCoord(): Coordinate | null {
+		const lineOptions = this._priceLine.options();
+		return this._xCoord(lineOptions.rayStart as UTCTimestamp);
+	}
+
 	protected _updateImpl(height: number, width: number): void {
 		const data = this._lineRendererData;
 		data.visible = false;
@@ -26,6 +33,11 @@ export class CustomPriceLinePaneView extends SeriesHorizontalLinePaneView {
 			return;
 		}
 
+		const rayStartCord = this.xCoord();
+		if (rayStartCord === null) {
+			return;
+		}
+
 		data.visible = true;
 		data.y = y;
 		data.color = lineOptions.color;
@@ -33,5 +45,19 @@ export class CustomPriceLinePaneView extends SeriesHorizontalLinePaneView {
 		data.height = height;
 		data.lineWidth = lineOptions.lineWidth;
 		data.lineStyle = lineOptions.lineStyle;
+		data.ray = lineOptions.ray;
+		data.rayStart = rayStartCord;
+	}
+
+	private _xCoord(time: UTCTimestamp): Coordinate | null {
+		const series = this._series;
+		const timeScale = series.model().timeScale();
+		const timeIndex = timeScale.timeToIndex({ timestamp: time }, true);
+
+		if (timeScale.isEmpty() || timeIndex === null) {
+			return null;
+		}
+
+		return timeScale.indexToCoordinate(timeIndex);
 	}
 }
diff --git a/src/views/pane/fib-retracement-pane-view.ts b/src/views/pane/fib-retracement-pane-view.ts
index b990e1f..1d7fbcc 100644
--- a/src/views/pane/fib-retracement-pane-view.ts
+++ b/src/views/pane/fib-retracement-pane-view.ts
@@ -82,7 +82,7 @@ export class FibRetracementPaneView extends LineToolPaneView {
 				this._rectangleRenderers[j].setData({
 					...options.line,
 					extend: options.extend,
-					background: { color: applyAlpha(options.levels[i].color, 0.2) },
+					background: { color: applyAlpha(options.levels[i].color, options.levels[i].opacity) },
 					points: [new AnchorPoint(minX, levelCoordinates[i - 1].coordinate, 0), new AnchorPoint(maxX, levelCoordinates[i].coordinate, 0)],
 				});
 				compositeRenderer.append(this._rectangleRenderers[j]);
diff --git a/src/views/pane/horizontal-line-pane-view.ts b/src/views/pane/horizontal-line-pane-view.ts
index 8b30ed3..037000b 100644
--- a/src/views/pane/horizontal-line-pane-view.ts
+++ b/src/views/pane/horizontal-line-pane-view.ts
@@ -63,7 +63,7 @@ export class HorizontalLinePaneView extends LineToolPaneView {
 
 			compositeRenderer.append(this._lineRenderer);
 			if (options.text.value) {
-				const angle = Math.atan((end.y - start.y) / (end.x - start.x));
+				const angle = Math.atan((end.y - start.y) / (end.x - start.x)) / Math.PI * -180;
 				const align = options.text.box.alignment.horizontal;
 				const pivot = align === BoxHorizontalAlignment.Left
 					? start.clone() : align === BoxHorizontalAlignment.Right
diff --git a/src/views/pane/line-tool-pane-view.ts b/src/views/pane/line-tool-pane-view.ts
index c7cee1b..e25257f 100644
--- a/src/views/pane/line-tool-pane-view.ts
+++ b/src/views/pane/line-tool-pane-view.ts
@@ -2,6 +2,7 @@ import { IInputEventListener, InputEventType, TouchMouseEvent } from '../../gui/
 import { PaneWidget } from '../../gui/pane-widget';
 
 import { ensureNotNull } from '../../helpers/assertions';
+import { clone } from '../../helpers/strict-type-checks';
 
 import { BarPrice } from '../../model/bar';
 import { ChartModel } from '../../model/chart-model';
@@ -9,20 +10,20 @@ import { Coordinate } from '../../model/coordinate';
 import { HitTestResult, HitTestType } from '../../model/hit-test-result';
 import { LineTool, LineToolHitTestData, LineToolPoint } from '../../model/line-tool';
 import { LineToolType } from '../../model/line-tool-options';
-import { /*Pane,*/ PaneCursorType } from '../../model/pane';
+import { PaneCursorType } from '../../model/pane';
 import { Point } from '../../model/point';
 import { CompositeRenderer } from '../../renderers/composite-renderer';
 import { IPaneRenderer } from '../../renderers/ipane-renderer';
 import { AnchorPoint, LineAnchorRenderer } from '../../renderers/line-anchor-renderer';
 
-import { IPaneView } from './ipane-view';
+import { IUpdatablePaneView } from './iupdatable-pane-view';
 
 export interface CreateAnchorData {
 	points: AnchorPoint[];
 	pointsCursorType?: PaneCursorType[];
 }
 
-export abstract class LineToolPaneView implements IPaneView, IInputEventListener {
+export abstract class LineToolPaneView implements IUpdatablePaneView, IInputEventListener {
 	protected readonly _source: LineTool<LineToolType>;
 	protected readonly _model: ChartModel;
 	protected _points: AnchorPoint[] = [];
@@ -39,7 +40,7 @@ export abstract class LineToolPaneView implements IPaneView, IInputEventListener
 	}
 
 	// eslint-disable-next-line complexity
-	public onInputEvent(paneWidget: PaneWidget, eventType: InputEventType, event?: TouchMouseEvent): void {
+	public onInputEvent(paneWidget: PaneWidget, ctx: CanvasRenderingContext2D, eventType: InputEventType, event?: TouchMouseEvent): void {
 		if (!event || (!this._renderer || !this._renderer.hitTest) && this._source.finished()) { return; }
 
 		const crossHair = this._model.crosshairSource();
@@ -47,13 +48,13 @@ export abstract class LineToolPaneView implements IPaneView, IInputEventListener
 		const originPoint = new Point(crossHair.originCoordX(), crossHair.originCoordY());
 
 		const changed = eventType === InputEventType.PressedMouseMove && !event.consumed
-			? this._onPressedMouseMove(paneWidget, originPoint, appliedPoint)
+			? this._onPressedMouseMove(paneWidget, ctx, originPoint, appliedPoint, event)
 			: eventType === InputEventType.MouseMove
-			? this._onMouseMove(paneWidget, originPoint, appliedPoint, event)
+			? this._onMouseMove(paneWidget, ctx, originPoint, appliedPoint, event)
 			: eventType === InputEventType.MouseDown
-			? this._onMouseDown(paneWidget, originPoint, appliedPoint, event)
+			? this._onMouseDown(paneWidget, ctx, originPoint, appliedPoint, event)
 			: eventType === InputEventType.MouseUp
-			? this._onMouseUp()
+			? this._onMouseUp(paneWidget)
 			: false;
 
 		event.consumed ||= this._source.editing() || !this._source.finished();
@@ -62,7 +63,7 @@ export abstract class LineToolPaneView implements IPaneView, IInputEventListener
 		}
 	}
 
-	public renderer(height: number, width: number, addAnchors?: boolean | undefined/*, pane: Pane*/): IPaneRenderer | null {
+	public renderer(height: number, width: number, addAnchors?: boolean | undefined): IPaneRenderer | null {
 		if (this._invalidated) { this._updateImpl(height, width); }
 		return this._source.visible() ? this._renderer : null;
 	}
@@ -131,9 +132,32 @@ export abstract class LineToolPaneView implements IPaneView, IInputEventListener
 		return renderer;
 	}
 
-	protected _onMouseUp(): boolean {
+	public getSelectedAndFireAfterEdit(paneWidget: PaneWidget, stage: string, orderID: string): void {
+		// finised editing or creating a line tool, execute AfterEdit event
+		// get the specific lineTool that was pathFinished, lineToolFinished, lineToolEdited and pass it on to the front end
+		const modifiedLineTool = paneWidget.state().getLineTool(orderID);
+		// if not null, the id exists, so pass it to frontend
+		if (modifiedLineTool !== null) {
+			// create a new lineToolExport to make sure that any change in the lineTool exported in not immediately applied.
+			const selectedLineTool = clone(modifiedLineTool.exportLineToolToLineToolExport());
+			this._model.fireLineToolsAfterEdit(selectedLineTool, stage);
+		}
+	}
+
+	protected _onMouseUp(paneWidget: PaneWidget): boolean {
 		if (!this._source.finished()) {
 			this._source.tryFinish();
+
+			const orderID = this._source.id();
+
+			// did a line tool just finish being created, if so fire AfterEdit
+			if (!this._source.editing() && !this._source.creating()) {
+				// finished creating a line tool, fire after edit event
+				this.getSelectedAndFireAfterEdit(paneWidget, 'lineToolFinished', orderID);
+			} else if (this._source.finished()) {
+				// this will detect if a path is finished being created
+				this.getSelectedAndFireAfterEdit(paneWidget, 'pathFinished', orderID);
+			}
 		} else if (this._source.editing()) {
 			this._model.magnet().disable();
 			this._updateSourcePoints();
@@ -141,12 +165,21 @@ export abstract class LineToolPaneView implements IPaneView, IInputEventListener
 			this._lastMovePoint = null;
 			this._editedPointIndex = null;
 			this._source.setEditing(false);
+			this._source.setCreating(false);
+
+			// pass along the id of the lineTool
+			const orderID = this._source.id();
+
+			// finished editing an existing line tool, fire after edit event
+			this.getSelectedAndFireAfterEdit(paneWidget, 'lineToolEdited', orderID);
+
 			return true;
 		}
+
 		return false;
 	}
 
-	protected _onPressedMouseMove(paneWidget: PaneWidget, originPoint: Point, appliedPoint: Point): boolean {
+	protected _onPressedMouseMove(paneWidget: PaneWidget, ctx: CanvasRenderingContext2D, originPoint: Point, appliedPoint: Point, event: TouchMouseEvent): boolean {
 		if (!this._source.finished()) {
 			if (this._source.lineDrawnWithPressedButton()) {
 				this._source.addPoint(this._source.screenPointToPoint(appliedPoint) as LineToolPoint);
@@ -157,7 +190,7 @@ export abstract class LineToolPaneView implements IPaneView, IInputEventListener
 		if (!this._source.selected()) { return false; }
 
 		if (!this._source.editing()) {
-			const hitResult = this._hitTest(paneWidget, originPoint);
+			const hitResult = this._hitTest(paneWidget, ctx, originPoint);
 			const hitData = hitResult?.data();
 			this._source.setEditing(this._source.hovered() || !!hitResult);
 
@@ -168,6 +201,8 @@ export abstract class LineToolPaneView implements IPaneView, IInputEventListener
 			paneWidget.setCursor(this._editedPointIndex !== null ? PaneCursorType.Default : PaneCursorType.Grabbing);
 
 			if (this._editedPointIndex !== null) {
+				this._tryApplyLineToolShift(appliedPoint, event, true);
+
 				this._source.setPoint(this._editedPointIndex, this._source.screenPointToPoint(appliedPoint) as LineToolPoint);
 			} else if (this._lastMovePoint) {
 				const diff = appliedPoint.subtract(this._lastMovePoint);
@@ -183,17 +218,24 @@ export abstract class LineToolPaneView implements IPaneView, IInputEventListener
 		return false;
 	}
 
-	protected _onMouseMove(paneWidget: PaneWidget, originPoint: Point, appliedPoint: Point, event: TouchMouseEvent): boolean {
+	protected _onMouseMove(paneWidget: PaneWidget, ctx: CanvasRenderingContext2D, originPoint: Point, appliedPoint: Point, event: TouchMouseEvent): boolean {
 		if (!this._source.finished()) {
 			if (this._source.hasMagnet()) { this._model.magnet().enable(); }
+
+			this._tryApplyLineToolShift(appliedPoint, event, false);
+
 			this._source.setLastPoint(this._source.screenPointToPoint(appliedPoint) as LineToolPoint);
 		} else {
-			const hitResult = this._hitTest(paneWidget, originPoint);
+			const hitResult = this._hitTest(paneWidget, ctx, originPoint);
 			const changed = this._source.setHovered(hitResult !== null && !event.consumed);
 
 			if (this._source.hovered() && !event.consumed) {
-				paneWidget.setCursor(hitResult?.data()?.cursorType || PaneCursorType.Pointer);
-				this._editedPointIndex = hitResult?.data()?.pointIndex ?? null;
+				if (this._source.options().editable === true) {
+					paneWidget.setCursor(hitResult?.data()?.cursorType || PaneCursorType.Pointer);
+					this._editedPointIndex = hitResult?.data()?.pointIndex ?? null;
+				} else {
+					paneWidget.setCursor(hitResult?.data()?.cursorType || PaneCursorType.NotAllowed);
+				}
 			}
 
 			return changed;
@@ -202,13 +244,19 @@ export abstract class LineToolPaneView implements IPaneView, IInputEventListener
 		return false;
 	}
 
-	protected _onMouseDown(paneWidget: PaneWidget, originPoint: Point, appliedPoint: Point, event: TouchMouseEvent): boolean {
+	protected _onMouseDown(paneWidget: PaneWidget, ctx: CanvasRenderingContext2D, originPoint: Point, appliedPoint: Point, event: TouchMouseEvent): boolean {
 		if (!this._source.finished()) {
+			this._tryApplyLineToolShift(appliedPoint, event, false);
+
 			this._source.addPoint(this._source.screenPointToPoint(appliedPoint) as LineToolPoint);
 			return false;
 		} else {
-			const hitResult = this._hitTest(paneWidget, originPoint);
-			return this._source.setSelected(hitResult !== null && !event.consumed);
+			if (this._source.options().editable === true) {
+				const hitResult = this._hitTest(paneWidget, ctx, originPoint);
+				return this._source.setSelected(hitResult !== null && !event.consumed);
+			} else {
+				return false;
+			}
 		}
 	}
 
@@ -216,9 +264,9 @@ export abstract class LineToolPaneView implements IPaneView, IInputEventListener
 		this._source.setPoints(this._points.map((point: Point) => this._source.screenPointToPoint(point) as LineToolPoint));
 	}
 
-	protected _hitTest(paneWidget: PaneWidget, point: Point): HitTestResult<LineToolHitTestData> | null {
+	protected _hitTest(paneWidget: PaneWidget, ctx: CanvasRenderingContext2D, point: Point): HitTestResult<LineToolHitTestData> | null {
 		if (!this._renderer?.hitTest) { return null; }
-		return this._renderer.hitTest(point.x, point.y) as HitTestResult<LineToolHitTestData> | null;
+		return this._renderer.hitTest(point.x, point.y, ctx) as HitTestResult<LineToolHitTestData> | null;
 	}
 
 	protected _lineAnchorColors(points: AnchorPoint[]): string[] {
@@ -251,4 +299,43 @@ export abstract class LineToolPaneView implements IPaneView, IInputEventListener
 		for (; this._lineAnchorRenderers.length <= index;) {this._lineAnchorRenderers.push(new LineAnchorRenderer());}
 		return this._lineAnchorRenderers[index];
 	}
+
+	protected _tryApplyLineToolShift(appliedPoint: Point, event: TouchMouseEvent, useEditedPointIndex: boolean): void {
+		const isTrendLine = this._isTrendLine();
+
+		// if shift, isTrendLine = true and at least 1 point exists already
+		if (event.shiftKey === true && isTrendLine === true && this._points.length > 0) {
+			// override point
+			if (useEditedPointIndex) {
+				if (this._editedPointIndex === 1) {
+					appliedPoint.y = this._points[0].y;
+				} else if (this._editedPointIndex === 0) {
+					appliedPoint.y = this._points[1].y;
+				} else if (this._editedPointIndex === 2) {
+					// parallelChannel is the only tool supporting holding shift that has 3-4 points
+					// points does not track point 3, so i have to use the diference from 0 and 1 and offset 2 so it now match what point 3 is without knowing anything about 3
+					const dif = this._points[0].y - this._points[1].y;
+					appliedPoint.y = (this._points[2].y - dif) as Coordinate;
+				} else if (this._editedPointIndex === 3) {
+					// parallelChannel is the only tool supporting holding shift that has 3-4 points
+					appliedPoint.y = this._points[2].y;
+				}
+			} else {
+				// if shift, isTrendLine = true and at least 1 point exists already
+				if (event.shiftKey === true && isTrendLine === true && this._points.length > 0) {
+					// override point 2's y with point 1's y
+					appliedPoint.y = this._points[0].y;
+				}
+			}
+		}
+	}
+
+	protected _isTrendLine(): boolean {
+		let isTrendLine = false;
+		const toolTypeStr = String(this._source.toolType());
+		if (toolTypeStr === 'TrendLine' || toolTypeStr === 'Ray' || toolTypeStr === 'Arrow' || toolTypeStr === 'ExtendedLine' || toolTypeStr === 'ParallelChannel') {
+			isTrendLine = true;
+		}
+		return isTrendLine;
+	}
 }
diff --git a/src/views/pane/rectangle-pane-view.ts b/src/views/pane/rectangle-pane-view.ts
index a2e83b1..ce22963 100644
--- a/src/views/pane/rectangle-pane-view.ts
+++ b/src/views/pane/rectangle-pane-view.ts
@@ -64,10 +64,10 @@ export class RectanglePaneView extends LineToolPaneView {
 						hoirzontalPadding = textHalfSize;
 						break;
 					case BoxVerticalAlignment.Top:
-						pivot.y = maxY as Coordinate;
+						pivot.y = minY as Coordinate;
 						break;
 					case BoxVerticalAlignment.Bottom:
-						pivot.y = minY as Coordinate;
+						pivot.y = maxY as Coordinate;
 				}
 
 				switch (options.text.box.alignment.horizontal) {
@@ -85,7 +85,9 @@ export class RectanglePaneView extends LineToolPaneView {
 				labelOptions.box = { ...labelOptions.box, padding: { y: textHalfSize, x: hoirzontalPadding } };
 
 				if (options.text.box.alignment.vertical === BoxVerticalAlignment.Middle) {
-					labelOptions.wordWrapWidth = maxX - minX - 2 * hoirzontalPadding;
+					// if (options.text.forceCalculateMaxLineWidth) {
+					//	labelOptions.wordWrapWidth = maxX - minX - 2 * hoirzontalPadding;
+					// }
 					labelOptions.box.maxHeight = maxY - minY;
 				}
 
diff --git a/src/views/pane/series-horizontal-line-pane-view.ts b/src/views/pane/series-horizontal-line-pane-view.ts
index 602994a..82edd50 100644
--- a/src/views/pane/series-horizontal-line-pane-view.ts
+++ b/src/views/pane/series-horizontal-line-pane-view.ts
@@ -16,6 +16,8 @@ export abstract class SeriesHorizontalLinePaneView implements IPaneView {
 		lineWidth: 1,
 		lineStyle: LineStyle.Solid,
 		visible: false,
+		ray: false,
+		rayStart: 0 as Coordinate,
 	};
 
 	protected readonly _series: Series;
diff --git a/src/views/pane/text-pane-view.ts b/src/views/pane/text-pane-view.ts
index 880dc81..9c14e8d 100644
--- a/src/views/pane/text-pane-view.ts
+++ b/src/views/pane/text-pane-view.ts
@@ -28,7 +28,7 @@ export class TextPaneView extends LineToolPaneView {
 
 		const options = this._source.options() as LineToolOptionsInternal<'Text'>;
 		const data = deepCopy(options.text) as TextOptions;
-		data.box.alignment = { vertical: BoxVerticalAlignment.Bottom, horizontal: BoxHorizontalAlignment.Center };
+		data.box.alignment = { vertical: BoxVerticalAlignment.Top, horizontal: BoxHorizontalAlignment.Center };
 		data.alignment = TextAlignment.Center;
 		const point = this._points[0].clone();
 
diff --git a/src/views/pane/trend-line-pane-view.ts b/src/views/pane/trend-line-pane-view.ts
index 1e46842..96111d5 100644
--- a/src/views/pane/trend-line-pane-view.ts
+++ b/src/views/pane/trend-line-pane-view.ts
@@ -50,7 +50,7 @@ export class TrendLinePaneView extends LineToolPaneView {
 				const start = point0.x < point1.x ? point0 : point1;
 				const end = start === point0 ? point1 : point0;
 
-				const angle = Math.atan((end.y - start.y) / (end.x - start.x));
+				const angle = Math.atan((end.y - start.y) / (end.x - start.x)) / Math.PI * -180;
 				const align = options.text.box.alignment.horizontal;
 				const pivot = align === BoxHorizontalAlignment.Left
 					? start.clone() : align === BoxHorizontalAlignment.Right
diff --git a/src/views/pane/vertical-line-pane-view.ts b/src/views/pane/vertical-line-pane-view.ts
index 1cc8b3a..b7632f0 100644
--- a/src/views/pane/vertical-line-pane-view.ts
+++ b/src/views/pane/vertical-line-pane-view.ts
@@ -59,7 +59,7 @@ export class VerticalLinePaneView extends LineToolPaneView {
 
 			compositeRenderer.append(this._lineRenderer);
 			if (options.text.value) {
-				const angle = Math.atan((end.y - start.y) / (end.x - start.x));
+				const angle = Math.atan((end.y - start.y) / (end.x - start.x)) / Math.PI * -180;
 				const align = options.text.box.alignment.horizontal;
 				const pivot = align === BoxHorizontalAlignment.Left
 					? start.clone() : align === BoxHorizontalAlignment.Right
diff --git a/src/views/time-axis/crosshair-time-axis-view.ts b/src/views/time-axis/crosshair-time-axis-view.ts
index fad104d..74c72ac 100644
--- a/src/views/time-axis/crosshair-time-axis-view.ts
+++ b/src/views/time-axis/crosshair-time-axis-view.ts
@@ -61,7 +61,7 @@ export class CrosshairTimeAxisView implements ITimeAxisView {
 		const currentTime = timeScale.floatIndexToTime(this._crosshair.appliedIndex());
 		data.width = timeScale.width();
 
-// Shinobaki - Useless. Not removed just to keep constructor arguments untouched.
+		// Useless. Not removed just to keep constructor arguments untouched.
 		const value = this._valueProvider();
 		data.coordinate = value.coordinate;
 		/*if (!value.time) {
