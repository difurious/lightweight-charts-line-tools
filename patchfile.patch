diff --git a/src/api/chart-api.ts b/src/api/chart-api.ts
index 12e3172..93972bb 100644
--- a/src/api/chart-api.ts
+++ b/src/api/chart-api.ts
@@ -1,4 +1,4 @@
-import { ChartWidget, MouseEventParamsImpl, MouseEventParamsImplSupplier } from '../gui/chart-widget';
+import { ChartWidget, LineToolsAfterEditEventParamsImpl, LineToolsAfterEditEventParamsImplSupplier, LineToolsDoubleClickEventParamsImpl, LineToolsDoubleClickEventParamsImplSupplier, MouseEventParamsImpl, MouseEventParamsImplSupplier } from '../gui/chart-widget';
 
 import { ensureDefined } from '../helpers/assertions';
 import { Delegate } from '../helpers/delegate';
@@ -8,6 +8,9 @@ import { clone, DeepPartial, isBoolean, merge } from '../helpers/strict-type-che
 import { BarPrice, BarPrices } from '../model/bar';
 import { ChartOptions, ChartOptionsInternal } from '../model/chart-model';
 import { ColorType } from '../model/layout-options';
+import { LineTool, LineToolExport, LineToolPoint } from '../model/line-tool';
+import { LineToolOptionsMap, LineToolPartialOptionsMap, LineToolType } from '../model/line-tool-options';
+import { Pane } from '../model/pane';
 import { Series } from '../model/series';
 import {
 	AreaSeriesOptions,
@@ -32,11 +35,13 @@ import {
 import { CandlestickSeriesApi } from './candlestick-series-api';
 import { DataUpdatesConsumer, SeriesDataItemTypeMap } from './data-consumer';
 import { DataLayer, DataUpdateResponse, SeriesChanges } from './data-layer';
-import { IChartApi, MouseEventHandler, MouseEventParams } from './ichart-api';
+import { IChartApi, LineToolsAfterEditEventHandler, LineToolsAfterEditEventParams, LineToolsDoubleClickEventHandler, LineToolsDoubleClickEventParams, MouseEventHandler, MouseEventParams } from './ichart-api';
 import { IPriceScaleApi } from './iprice-scale-api';
 import { ISeriesApi } from './iseries-api';
 import { ITimeScaleApi } from './itime-scale-api';
+import { LineToolApi } from './line-tool-api';
 import { chartOptionsDefaults } from './options/chart-options-defaults';
+import { LineToolsOptionDefaults } from './options/line-tools-options-defaults';
 import {
 	areaStyleDefaults,
 	barStyleDefaults,
@@ -159,6 +164,8 @@ export class ChartApi implements IChartApi, DataUpdatesConsumer<SeriesType> {
 
 	private readonly _clickedDelegate: Delegate<MouseEventParams> = new Delegate();
 	private readonly _crosshairMovedDelegate: Delegate<MouseEventParams> = new Delegate();
+	private readonly _lineToolsDoubleClickDelegate: Delegate<LineToolsDoubleClickEventParams> = new Delegate();
+	private readonly _lineToolsAfterEditDelegate: Delegate<LineToolsAfterEditEventParams> = new Delegate();
 
 	private readonly _timeScaleApi: TimeScaleApi;
 
@@ -186,13 +193,41 @@ export class ChartApi implements IChartApi, DataUpdatesConsumer<SeriesType> {
 			this
 		);
 
+		this._chartWidget.lineToolsDoubleClick().subscribe(
+			(paramSupplier: LineToolsDoubleClickEventParamsImplSupplier) => {
+				if (this._lineToolsDoubleClickDelegate.hasListeners()) {
+					this._lineToolsDoubleClickDelegate.fire(this._convertLineToolsDoubleClickParams(paramSupplier()));
+				}
+			},
+			this
+		);
+
+		this._chartWidget.lineToolsAfterEdit().subscribe(
+			(paramSupplier: LineToolsAfterEditEventParamsImplSupplier) => {
+				if (this._lineToolsAfterEditDelegate.hasListeners()) {
+					this._lineToolsAfterEditDelegate.fire(this._convertLineToolsAfterEditParams(paramSupplier()));
+				}
+			},
+			this
+		);
+
 		const model = this._chartWidget.model();
 		this._timeScaleApi = new TimeScaleApi(model, this._chartWidget.timeAxisWidget());
 	}
 
+	public setCrossHairXY(x: number, y: number, visible: boolean): void {
+		this._chartWidget.paneWidgets()[0].setCrossHair(x, y, visible);
+	}
+
+	public clearCrossHair(): void {
+		this._chartWidget.paneWidgets()[0].clearCrossHair();
+	}
+
 	public remove(): void {
 		this._chartWidget.clicked().unsubscribeAll(this);
 		this._chartWidget.crosshairMoved().unsubscribeAll(this);
+		this._chartWidget.lineToolsDoubleClick().unsubscribeAll(this);
+		this._chartWidget.lineToolsAfterEdit().unsubscribeAll(this);
 
 		this._timeScaleApi.destroy();
 		this._chartWidget.destroy();
@@ -202,6 +237,8 @@ export class ChartApi implements IChartApi, DataUpdatesConsumer<SeriesType> {
 
 		this._clickedDelegate.destroy();
 		this._crosshairMovedDelegate.destroy();
+		this._lineToolsDoubleClickDelegate.destroy();
+		this._lineToolsAfterEditDelegate.destroy();
 		this._dataLayer.destroy();
 	}
 
@@ -308,6 +345,112 @@ export class ChartApi implements IChartApi, DataUpdatesConsumer<SeriesType> {
 		this._seriesMapReversed.delete(series);
 	}
 
+	public addLineTool<T extends LineToolType>(name: T, points: LineToolPoint[], options?: LineToolPartialOptionsMap[T]): LineToolApi<T> {
+		const strictOptions = merge(clone(LineToolsOptionDefaults[name]), options || {}) as LineToolOptionsMap[T];
+		const tool = this._chartWidget.model().createLineTool(name, strictOptions, points);
+		return new LineToolApi<T>(tool);
+	}
+
+	public setActiveLineTool<T extends LineToolType>(name: T, options?: LineToolPartialOptionsMap[T]): void {
+		this._chartWidget.model().lineToolCreator().setActiveLineTool(name, options);
+	}
+
+	public removeLineToolsById(ids: string[]): void {
+		if (Array.isArray(ids)) {
+			const pane = this._getPane();
+			if (pane === null) { return; }
+			ids.forEach((id: string) => {
+				const lineToolToRemove = pane.getLineTool(id);
+				if (lineToolToRemove === null) {
+					return;
+				}
+				pane.removeDataSource(lineToolToRemove);
+			});
+			pane.recalculate();
+		}
+		return;
+	}
+
+	public getSelectedLineTools(): string {
+		let lineToolsOptions: LineToolExport<LineToolType>[] = [];
+		const pane = this._getPane();
+		if (pane === null) { return JSON.stringify(lineToolsOptions); }
+		const selectedLineTools = pane.getSelectedLineTools();
+		if (selectedLineTools.length > 0) {
+			lineToolsOptions = selectedLineTools.map((l: LineTool<LineToolType>) => l.exportLineToolToLineToolExport());
+		}
+		return JSON.stringify(lineToolsOptions);
+	}
+
+	public removeSelectedLineTools(): void {
+		const pane = this._getPane();
+		if (pane === null) { return; }
+		const selectedLineTools = pane.getSelectedLineTools();
+		if (selectedLineTools.length > 0) {
+			selectedLineTools.forEach((line: LineTool<LineToolType>) => { pane.removeDataSource(line); });
+			pane.recalculate();
+		}
+	}
+
+	public removeAllLineTools(): void {
+		const pane = this._getPane();
+		if (pane === null) { return; }
+		const selectedLineTools = pane.getAllLineTools();
+		if (selectedLineTools.length > 0) {
+			selectedLineTools.forEach((line: LineTool<LineToolType>) => { pane.removeDataSource(line); });
+			pane.recalculate();
+		}
+	}
+
+	public exportLineTools(): string {
+		let lineToolsOptions: LineToolExport<LineToolType>[] = [];
+		const pane = this._getPane();
+		if (pane === null) {
+			return JSON.stringify(lineToolsOptions);
+		}
+		const lineTools = pane.getAllLineTools();
+		if (lineTools.length > 0) {
+			lineToolsOptions = lineTools.map((l: LineTool<LineToolType>) => l.exportLineToolToLineToolExport());
+		}
+		return JSON.stringify(lineToolsOptions);
+	}
+
+	public importLineTools(json: string): boolean {
+		if (json === 'undefined' || !json) {
+			return false;
+		}
+		const lineTools = JSON.parse(json) as LineToolExport<LineToolType>[];
+
+		lineTools.forEach((line: LineToolExport<LineToolType>) => {
+			const lineToolApi = this.addLineTool<LineToolType>(line.toolType, line.points, line.options);
+			lineToolApi.lineTool.setId(line.id);
+		});
+
+		const pane = this._getPane();
+		if (pane !== null) {
+			pane.recalculate();
+		}
+		return true;
+	}
+
+	public applyLineToolOptions(newLineTool: LineToolExport<LineToolType>): boolean {
+		const pane = this._getPane();
+		if (pane === null) {
+			return false;
+		}
+
+		const lineTool = pane.getLineTool(newLineTool.id);
+		if (lineTool === null) {
+			return false;
+		}
+
+		lineTool.setPoints(newLineTool.points);
+		const lineToolApi = new LineToolApi(lineTool);
+		lineToolApi.applyOptions(newLineTool.options);
+
+		return true;
+	}
+
 	public applyNewData<TSeriesType extends SeriesType>(series: Series<TSeriesType>, data: SeriesDataItemTypeMap[TSeriesType][]): void {
 		this._sendUpdateToChart(this._dataLayer.setSeriesData(series, data));
 	}
@@ -332,6 +475,22 @@ export class ChartApi implements IChartApi, DataUpdatesConsumer<SeriesType> {
 		this._crosshairMovedDelegate.unsubscribe(handler);
 	}
 
+	public subscribeLineToolsDoubleClick(handler: LineToolsDoubleClickEventHandler): void {
+		this._lineToolsDoubleClickDelegate.subscribe(handler);
+	}
+
+	public unsubscribeLineToolsDoubleClick(handler: LineToolsDoubleClickEventHandler): void {
+		this._lineToolsDoubleClickDelegate.unsubscribe(handler);
+	}
+
+	public subscribeLineToolsAfterEdit(handler: LineToolsAfterEditEventHandler): void {
+		this._lineToolsAfterEditDelegate.subscribe(handler);
+	}
+
+	public unsubscribeLineToolsAfterEdit(handler: LineToolsAfterEditEventHandler): void {
+		this._lineToolsAfterEditDelegate.unsubscribe(handler);
+	}
+
 	public priceScale(priceScaleId?: string): IPriceScaleApi {
 		if (priceScaleId === undefined) {
 			warn('Using ChartApi.priceScale() method without arguments has been deprecated, pass valid price scale id instead');
@@ -370,6 +529,10 @@ export class ChartApi implements IChartApi, DataUpdatesConsumer<SeriesType> {
 		return ensureDefined(this._seriesMapReversed.get(series));
 	}
 
+	private _getPane(): Pane | null {
+		return this._chartWidget.model().getActivePane();
+	}
+
 	private _convertMouseParams(param: MouseEventParamsImpl): MouseEventParams {
 		const seriesPrices = new Map<ISeriesApi<SeriesType>, BarPrice | BarPrices>();
 		param.seriesPrices.forEach((price: BarPrice | BarPrices, series: Series) => {
@@ -386,4 +549,17 @@ export class ChartApi implements IChartApi, DataUpdatesConsumer<SeriesType> {
 			seriesPrices,
 		};
 	}
+
+	private _convertLineToolsDoubleClickParams(param: LineToolsDoubleClickEventParamsImpl): LineToolsDoubleClickEventParams {
+		return {
+			selectedLineTool: param.selectedLineTool,
+		};
+	}
+
+	private _convertLineToolsAfterEditParams(param: LineToolsAfterEditEventParamsImpl): LineToolsAfterEditEventParams {
+		return {
+			selectedLineTool: param.selectedLineTool,
+			stage: param.stage,
+		};
+	}
 }
diff --git a/src/api/ichart-api.ts b/src/api/ichart-api.ts
index 1a62561..9138e99 100644
--- a/src/api/ichart-api.ts
+++ b/src/api/ichart-api.ts
@@ -2,6 +2,8 @@ import { DeepPartial } from '../helpers/strict-type-checks';
 
 import { BarPrice, BarPrices } from '../model/bar';
 import { ChartOptions } from '../model/chart-model';
+import { LineToolExport, LineToolPoint } from '../model/line-tool';
+import { LineToolPartialOptionsMap, LineToolType } from '../model/line-tool-options';
 import { Point } from '../model/point';
 import { SeriesMarker } from '../model/series-markers';
 import {
@@ -16,6 +18,7 @@ import {
 import { BusinessDay, UTCTimestamp } from '../model/time-data';
 
 import { Time } from './data-consumer';
+import { ILineToolApi } from './iline-tool-api';
 import { IPriceScaleApi } from './iprice-scale-api';
 import { ISeriesApi } from './iseries-api';
 import { ITimeScaleApi } from './itime-scale-api';
@@ -58,6 +61,19 @@ export interface MouseEventParams {
  */
 export type MouseEventHandler = (param: MouseEventParams) => void;
 
+export interface LineToolsDoubleClickEventParams {
+	selectedLineTool: LineToolExport<LineToolType>;
+}
+
+export interface LineToolsAfterEditEventParams {
+	selectedLineTool: LineToolExport<LineToolType>;
+	stage: string;
+}
+
+export type LineToolsDoubleClickEventHandler = (param: LineToolsDoubleClickEventParams) => void;
+
+export type LineToolsAfterEditEventHandler = (param: LineToolsAfterEditEventParams) => void;
+
 /**
  * The main interface of a single chart.
  */
@@ -148,6 +164,51 @@ export interface IChartApi {
 	 */
 	addLineSeries(lineOptions?: LineSeriesPartialOptions): ISeriesApi<'Line'>;
 
+	/**
+	 * Creates a line tool with specified parameters.
+	 */
+	addLineTool<T extends LineToolType>(name: T, points: LineToolPoint[], options: LineToolPartialOptionsMap[T]): ILineToolApi<T>;
+
+	/**
+	 * Sets the active line tool with specified parameters.
+	 */
+	setActiveLineTool<T extends LineToolType>(name: T, options: LineToolPartialOptionsMap[T]): void;
+
+	/**
+     * Remove a LineTool by its ID.
+     */
+	removeLineToolsById(ids: string[]): void;
+
+	/**
+     * Get the currently selected LineTool(s), return JSON string of them.
+     */
+	getSelectedLineTools(): void;
+
+	/**
+     * Remove the currently selected LineTool only.
+     */
+	removeSelectedLineTools(): void;
+
+    /**
+     * Remove All LineTools that have been drawn.
+     */
+	removeAllLineTools(): void;
+
+    /**
+     * Export all LineTools that have been drawn to a JSON string.  This export can be used with importLineTools(JSONstring) if you want to import them in the future
+     */
+	exportLineTools(): void;
+
+    /**
+     * Import a JSON string to recreate all LineTools that have previously been exported using exportLineTools().
+     */
+	importLineTools(json: string): boolean;
+
+    /**
+     * Apply new provided options to lineTool specified in the id field.
+     */
+	applyLineToolOptions(newLineTool: LineToolExport<LineToolType>): boolean;
+
 	/**
 	 * Removes a series of any type. This is an irreversible operation, you cannot do anything with the series after removing it.
 	 *
@@ -207,6 +268,10 @@ export interface IChartApi {
 	 */
 	subscribeCrosshairMove(handler: MouseEventHandler): void;
 
+	setCrossHairXY(x: number, y: number, visible: boolean): void;
+
+	clearCrossHair(): void;
+
 	/**
 	 * Unsubscribe a handler that was previously subscribed using {@link subscribeCrosshairMove}.
 	 *
@@ -218,6 +283,34 @@ export interface IChartApi {
 	 */
 	unsubscribeCrosshairMove(handler: MouseEventHandler): void;
 
+	/**
+	 * Adds a subscription to receive notifications on linetools being double clicked
+	 *
+	 * @param handler - handler (function) to be called on double click
+	 */
+	subscribeLineToolsDoubleClick(handler: LineToolsDoubleClickEventHandler): void;
+
+	/**
+	 * Removes linetools being double clicked subscription
+	 *
+	 * @param handler - previously subscribed handler
+	 */
+	unsubscribeLineToolsDoubleClick(handler: LineToolsDoubleClickEventHandler): void;
+
+	/**
+	 * Adds a subscription to receive notifications on linetools after finishing editing a line tool
+	 *
+	 * @param handler - handler (function) to be called after line tool was finished editing
+	 */
+	subscribeLineToolsAfterEdit(handler: LineToolsAfterEditEventHandler): void;
+
+	/**
+	 * Removes linetools notifications on linetools after finishing editing a line tool
+	 *
+	 * @param handler - previously subscribed handler
+	 */
+	unsubscribeLineToolsAfterEdit(handler: LineToolsAfterEditEventHandler): void;
+
 	/**
 	 * Returns API to manipulate a price scale.
 	 *
diff --git a/src/api/iline-tool-api.ts b/src/api/iline-tool-api.ts
new file mode 100644
index 0000000..77d234a
--- /dev/null
+++ b/src/api/iline-tool-api.ts
@@ -0,0 +1,35 @@
+import { LineToolPoint as LineToolPoint } from '../model/line-tool';
+import { LineToolPartialOptionsMap, LineToolType } from '../model/line-tool-options';
+/**
+ * Represents the interface for interacting with line tools.
+ */
+export interface ILineToolApi<TLineToolType extends LineToolType> {
+	/**
+	 * Applies new options to the existing line tool
+	 * Note that you can only pass options you want to change.
+	 *
+	 * @param options - Any subset of options.
+	 */
+	applyOptions(options: LineToolPartialOptionsMap[TLineToolType]): void;
+
+	/**
+	 * Returns currently applied options
+	 *
+	 * @returns Full set of currently applied options, including defaults
+	 */
+	options(): Readonly<LineToolPartialOptionsMap[TLineToolType]>;
+
+	/**
+	 * Sets or replaces series data.
+	 *
+	 * @param points - Points of the line tool. Old points get replaced by new ones
+	 */
+	setPoints(points: LineToolPoint[]): void;
+
+	/**
+	 * Return current series type.
+	 *
+	 * @returns Type of the lineTool.
+	 */
+	toolType(): LineToolType;
+}
diff --git a/src/api/line-tool-api.ts b/src/api/line-tool-api.ts
new file mode 100644
index 0000000..2c255bd
--- /dev/null
+++ b/src/api/line-tool-api.ts
@@ -0,0 +1,30 @@
+import { clone } from '../helpers/strict-type-checks';
+
+import { LineTool, LineToolPoint } from '../model/line-tool';
+import { LineToolOptionsMap, LineToolPartialOptionsMap, LineToolType } from '../model/line-tool-options';
+
+import { ILineToolApi } from './iline-tool-api';
+
+export class LineToolApi<TLineToolType extends LineToolType> implements ILineToolApi<TLineToolType> {
+	public lineTool: LineTool<TLineToolType>;
+
+	public constructor(lineTool: LineTool<TLineToolType>) {
+		this.lineTool = lineTool;
+	}
+
+	public setPoints(points: LineToolPoint[]): void {
+		throw new Error('Method not implemented.');
+	}
+
+	public applyOptions(options: LineToolPartialOptionsMap[TLineToolType]): void {
+		this.lineTool.applyOptions(options);
+	}
+
+	public options(): Readonly<LineToolOptionsMap[TLineToolType]> {
+		return clone(this.lineTool.options());
+	}
+
+	public toolType(): LineToolType {
+		return this.lineTool.toolType();
+	}
+}
diff --git a/src/api/options/crosshair-options-defaults.ts b/src/api/options/crosshair-options-defaults.ts
index 7d04145..1829b81 100644
--- a/src/api/options/crosshair-options-defaults.ts
+++ b/src/api/options/crosshair-options-defaults.ts
@@ -19,4 +19,7 @@ export const crosshairOptionsDefaults: CrosshairOptions = {
 		labelBackgroundColor: '#4c525e',
 	},
 	mode: CrosshairMode.Magnet,
+	// testing to try and get graphics tests to pass, the crosshair magnet is messing them up
+	magnetThreshold: 14,
+	// magnetThreshold: 1000000,
 };
diff --git a/src/api/options/line-tools-options-defaults.ts b/src/api/options/line-tools-options-defaults.ts
new file mode 100644
index 0000000..4c11033
--- /dev/null
+++ b/src/api/options/line-tools-options-defaults.ts
@@ -0,0 +1,164 @@
+/* eslint-disable @typescript-eslint/naming-convention */
+import { applyAlpha } from '../../helpers/color';
+import { defaultFontFamily } from '../../helpers/make-font';
+import { clone, merge } from '../../helpers/strict-type-checks';
+
+import { BoxHorizontalAlignment, BoxVerticalAlignment, BrushToolOptions, CrossLineToolOptions, FibRetracementToolOptions, HighlighterToolOptions, HorizontalLineToolOptions, LineJoin, ParallelChannelToolOptions, PathToolOptions, RectangleToolOptions, TextAlignment, TextOptions, TextToolOptions, TrendLineToolOptions, TriangleToolOptions, VerticalLineToolOptions } from '../../model/line-tool-options';
+
+import { LineEnd, LineStyle } from '../..';
+
+export const TextDefaults: TextOptions = {
+	value: '',
+	padding: 0,
+	wordWrapWidth: 0,
+	forceTextAlign: false,
+	forceCalculateMaxLineWidth: false,
+	alignment: TextAlignment.Left,
+	font: { family: defaultFontFamily, color: '#2962ff', size: 12, bold: false, italic: false },
+	box: { scale: 1, angle: 0, alignment: { vertical: BoxVerticalAlignment.Top, horizontal: BoxHorizontalAlignment.Left } },
+};
+
+export const TrendLineOptionDefaults: TrendLineToolOptions = {
+	visible: true,
+	editable: true,
+	line: {
+		width: 1,
+		color: '#2962ff',
+		style: LineStyle.Solid,
+		extend: { left: false, right: false },
+		end: { left: LineEnd.Normal, right: LineEnd.Normal },
+	},
+	text: TextDefaults,
+};
+
+export const HorizontalLineOptionDefaults: HorizontalLineToolOptions = {
+	visible: true,
+	editable: true,
+	line: {
+		width: 1,
+		color: '#2962ff',
+		style: LineStyle.Solid,
+		extend: { left: true, right: true },
+		end: { left: LineEnd.Normal, right: LineEnd.Normal },
+	},
+	text: TextDefaults,
+};
+
+export const ParallelChannelOptionDefaults: ParallelChannelToolOptions = {
+	visible: true,
+	editable: true,
+	showMiddleLine: true,
+	extend: { left: false, right: false },
+	background: { color: applyAlpha('#2962ff', 0.2) },
+	middleLine: { width: 1, color: '#2962ff', style: LineStyle.Dashed },
+	channelLine: { width: 1, color: '#2962ff', style: LineStyle.Solid },
+};
+
+export const FibRetracementOptionDefaults: FibRetracementToolOptions = {
+	visible: true,
+	editable: true,
+	extend: { left: false, right: false },
+	line: { width: 1, style: LineStyle.Solid },
+	levels: [
+        { color: '#787b86', coeff: 0, opacity: 0 },
+        { color: '#f23645', coeff: 0.236, opacity: 0 },
+        { color: '#81c784', coeff: 0.382, opacity: 0 },
+        { color: '#4caf50', coeff: 0.5, opacity: 0 },
+        { color: '#089981', coeff: 0.618, opacity: 0 },
+        { color: '#64b5f6', coeff: 0.786, opacity: 0 },
+        { color: '#787b86', coeff: 1, opacity: 0 },
+        { color: '#2962ff', coeff: 1.618, opacity: 0 },
+        { color: '#f23645', coeff: 2.618, opacity: 0 },
+        { color: '#9c27b0', coeff: 3.618, opacity: 0 },
+        { color: '#e91e63', coeff: 4.236, opacity: 0 },
+	],
+};
+
+export const BrushOptionDefaults: BrushToolOptions = {
+	visible: true,
+	editable: true,
+	line: {
+		width: 1,
+		color: '#00bcd4',
+		join: LineJoin.Round,
+		style: LineStyle.Solid,
+		end: { left: LineEnd.Normal, right: LineEnd.Normal },
+	},
+};
+
+export const RectangleOptionDefaults: RectangleToolOptions = {
+	visible: true,
+	editable: true,
+	rectangle: {
+		extend: { left: false, right: false },
+		background: { color: applyAlpha('#9c27b0', 0.2) },
+		border: { width: 1, style: LineStyle.Solid, color: '#9c27b0' },
+	},
+	text: TextDefaults,
+};
+
+export const TriangleOptionDefaults: TriangleToolOptions = {
+	visible: true,
+	editable: true,
+	triangle: {
+		background: { color: applyAlpha('#f57c00', 0.2) },
+		border: { width: 1, style: LineStyle.Solid, color: '#f57c00' },
+	},
+};
+
+export const VerticalLineOptionDefaults: VerticalLineToolOptions = {
+	visible: true,
+	editable: true,
+	text: TextDefaults,
+	line: { width: 1, color: '#2962ff', style: LineStyle.Solid },
+};
+
+export const PathOptionDefaults: PathToolOptions = {
+	visible: true,
+	editable: true,
+	line: {
+		width: 1,
+		color: '#2962ff',
+		style: LineStyle.Solid,
+		end: { left: LineEnd.Normal, right: LineEnd.Arrow },
+	},
+};
+
+export const CrossLineOptionDefaults: CrossLineToolOptions = {
+	visible: true,
+	editable: true,
+	line: { width: 1, color: '#2962ff', style: LineStyle.Solid },
+};
+
+export const HighlighterOptionDefaults: HighlighterToolOptions = {
+	visible: true,
+	editable: true,
+	line: { color: applyAlpha('#f23645', 0.15) },
+};
+
+export const TextOptionDefaults: TextToolOptions = {
+	visible: true,
+	editable: true,
+	text: merge(clone(TextDefaults), { value: 'Text' }) as TextOptions,
+};
+
+/** @public */
+export const LineToolsOptionDefaults = {
+	Ray: merge(clone(TrendLineOptionDefaults), { line: { extend: { right: true } } }),
+	Arrow: merge(clone(TrendLineOptionDefaults), { line: { end: { right: LineEnd.Arrow } } }),
+	ExtendedLine: merge(clone(TrendLineOptionDefaults), { line: { extend: { right: true, left: true } } }),
+	HorizontalRay: merge(clone(HorizontalLineOptionDefaults), { line: { extend: { left: false } } }),
+
+	FibRetracement: FibRetracementOptionDefaults,
+	ParallelChannel: ParallelChannelOptionDefaults,
+	HorizontalLine: HorizontalLineOptionDefaults,
+	VerticalLine: VerticalLineOptionDefaults,
+	Highlighter: HighlighterOptionDefaults,
+	CrossLine: CrossLineOptionDefaults,
+	TrendLine: TrendLineOptionDefaults,
+	Rectangle: RectangleOptionDefaults,
+	Triangle: TriangleOptionDefaults,
+	Brush: BrushOptionDefaults,
+	Path: PathOptionDefaults,
+	Text: TextOptionDefaults,
+};
diff --git a/src/api/options/price-line-options-defaults.ts b/src/api/options/price-line-options-defaults.ts
index ebe6533..dcb1b3d 100644
--- a/src/api/options/price-line-options-defaults.ts
+++ b/src/api/options/price-line-options-defaults.ts
@@ -9,4 +9,6 @@ export const priceLineOptionsDefaults: PriceLineOptions = {
 	lineVisible: true,
 	axisLabelVisible: true,
 	title: '',
+	ray: false,
+	rayStart: 0,
 };
diff --git a/src/gui/chart-widget.ts b/src/gui/chart-widget.ts
index d6a85d3..79f2a8e 100644
--- a/src/gui/chart-widget.ts
+++ b/src/gui/chart-widget.ts
@@ -14,6 +14,8 @@ import {
 	TimeScaleInvalidation,
 	TimeScaleInvalidationType,
 } from '../model/invalidate-mask';
+import { LineToolExport } from '../model/line-tool';
+import { LineToolType } from '../model/line-tool-options';
 import { Point } from '../model/point';
 import { PriceAxisPosition } from '../model/price-scale';
 import { Series } from '../model/series';
@@ -34,6 +36,19 @@ export interface MouseEventParamsImpl {
 
 export type MouseEventParamsImplSupplier = () => MouseEventParamsImpl;
 
+export interface LineToolsDoubleClickEventParamsImpl {
+	selectedLineTool: LineToolExport<LineToolType>;
+}
+
+export interface LineToolsAfterEditEventParamsImpl {
+	selectedLineTool: LineToolExport<LineToolType>;
+	stage: string;
+}
+
+export type LineToolsDoubleClickEventParamsImplSupplier = () => LineToolsDoubleClickEventParamsImpl;
+
+export type LineToolsAfterEditEventParamsImplSupplier = () => LineToolsAfterEditEventParamsImpl;
+
 export class ChartWidget implements IDestroyable {
 	private readonly _options: ChartOptionsInternal;
 	private _paneWidgets: PaneWidget[] = [];
@@ -51,6 +66,8 @@ export class ChartWidget implements IDestroyable {
 	private _drawPlanned: boolean = false;
 	private _clicked: Delegate<MouseEventParamsImplSupplier> = new Delegate();
 	private _crosshairMoved: Delegate<MouseEventParamsImplSupplier> = new Delegate();
+	private _lineToolsDoubleClick: Delegate<LineToolsDoubleClickEventParamsImplSupplier> = new Delegate();
+	private _lineToolsAfterEdit: Delegate<LineToolsAfterEditEventParamsImplSupplier> = new Delegate();
 	private _onWheelBound: (event: WheelEvent) => void;
 
 	public constructor(container: HTMLElement, options: ChartOptionsInternal) {
@@ -75,6 +92,8 @@ export class ChartWidget implements IDestroyable {
 			this._options
 		);
 		this.model().crosshairMoved().subscribe(this._onPaneWidgetCrosshairMoved.bind(this), this);
+		this.model().lineToolsDoubleClick().subscribe(this._onLineToolsDoubleClick.bind(this), this);
+		this.model().lineToolsAfterEdit().subscribe(this._onLineToolsAfterEdit.bind(this), this);
 
 		this._timeAxisWidget = new TimeAxisWidget(this);
 		this._tableElement.appendChild(this._timeAxisWidget.getElement());
@@ -134,6 +153,7 @@ export class ChartWidget implements IDestroyable {
 		}
 
 		this._model.crosshairMoved().unsubscribeAll(this);
+		this._model.lineToolsDoubleClick().unsubscribeAll(this);
 		this._model.timeScale().optionsApplied().unsubscribeAll(this);
 		this._model.priceScalesOptionsChanged().unsubscribeAll(this);
 		this._model.destroy();
@@ -219,6 +239,14 @@ export class ChartWidget implements IDestroyable {
 		return this._crosshairMoved;
 	}
 
+	public lineToolsDoubleClick(): ISubscription<LineToolsDoubleClickEventParamsImplSupplier> {
+		return this._lineToolsDoubleClick;
+	}
+
+	public lineToolsAfterEdit(): ISubscription<LineToolsAfterEditEventParamsImplSupplier> {
+		return this._lineToolsAfterEdit;
+	}
+
 	public takeScreenshot(): HTMLCanvasElement {
 		if (this._invalidateMask !== null) {
 			this._drawImpl(this._invalidateMask);
@@ -645,6 +673,19 @@ export class ChartWidget implements IDestroyable {
 		};
 	}
 
+	private _getLineToolsDoubleClickEventParamsImpl(selectedLineTool: LineToolExport<LineToolType>): LineToolsDoubleClickEventParamsImpl {
+		return {
+			selectedLineTool: selectedLineTool,
+		};
+	}
+
+	private _getLineToolsAfterEditEventParamsImpl(selectedLineTool: LineToolExport<LineToolType>, stage: string): LineToolsAfterEditEventParamsImpl {
+		return {
+			selectedLineTool: selectedLineTool,
+			stage: stage,
+		};
+	}
+
 	private _onPaneWidgetClicked(time: TimePointIndex | null, point: Point): void {
 		this._clicked.fire(() => this._getMouseEventParamsImpl(time, point));
 	}
@@ -653,6 +694,14 @@ export class ChartWidget implements IDestroyable {
 		this._crosshairMoved.fire(() => this._getMouseEventParamsImpl(time, point));
 	}
 
+	private _onLineToolsDoubleClick(selectedLineTool: LineToolExport<LineToolType>): void {
+		this._lineToolsDoubleClick.fire(() => this._getLineToolsDoubleClickEventParamsImpl(selectedLineTool));
+	}
+
+	private _onLineToolsAfterEdit(selectedLineTool: LineToolExport<LineToolType>, stage: string): void {
+		this._lineToolsAfterEdit.fire(() => this._getLineToolsAfterEditEventParamsImpl(selectedLineTool, stage));
+	}
+
 	private _updateTimeAxisVisibility(): void {
 		const display = this._options.timeScale.visible ? '' : 'none';
 		this._timeAxisWidget.getElement().style.display = display;
diff --git a/src/gui/mouse-event-handler.ts b/src/gui/mouse-event-handler.ts
index 94b3858..b47c231 100644
--- a/src/gui/mouse-event-handler.ts
+++ b/src/gui/mouse-event-handler.ts
@@ -5,11 +5,39 @@ import { IDestroyable } from '../helpers/idestroyable';
 
 import { Coordinate } from '../model/coordinate';
 
+import { PaneWidget } from './pane-widget';
+
 export type HandlerMouseEventCallback = (event: MouseEventHandlerMouseEvent) => void;
 export type HandlerTouchEventCallback = (event: MouseEventHandlerTouchEvent) => void;
 export type EmptyCallback = () => void;
 export type PinchEventCallback = (middlePoint: Position, scale: number) => void;
 
+export interface IInputEventListener {
+	onInputEvent(paneWidget: PaneWidget, ctx: CanvasRenderingContext2D, eventType: InputEventType, event?: TouchMouseEvent): void;
+}
+
+// eslint-disable-next-line @typescript-eslint/no-explicit-any
+export function isInputEventListener(object: any): object is IInputEventListener {
+	// eslint-disable-next-line @typescript-eslint/tslint/config
+	return (object as IInputEventListener).onInputEvent !== undefined;
+}
+
+export const enum InputEventType {
+	Pinch,
+	PinchEnd,
+	PinchStart,
+	MouseClick,
+	MouseDoubleClick,
+	MouseDownOutside,
+	MouseDown,
+	MouseEnter,
+	MouseLeave,
+	MouseMove,
+	MouseUp,
+	PressedMouseMove,
+	LongTap,
+}
+
 export interface MouseEventHandlers {
 	pinchStartEvent?: EmptyCallback;
 	pinchEvent?: PinchEventCallback;
@@ -56,6 +84,8 @@ export interface MouseEventHandlerEventBase {
 	readonly metaKey: boolean;
 	readonly srcType: string;
 
+	consumed?: boolean;
+
 	target: MouseEvent['target'];
 	view: MouseEvent['view'];
 
diff --git a/src/gui/pane-widget.ts b/src/gui/pane-widget.ts
index 5e61661..b6d552e 100644
--- a/src/gui/pane-widget.ts
+++ b/src/gui/pane-widget.ts
@@ -5,13 +5,14 @@ import { clearRect, clearRectWithGradient, drawScaled } from '../helpers/canvas-
 import { Delegate } from '../helpers/delegate';
 import { IDestroyable } from '../helpers/idestroyable';
 import { ISubscription } from '../helpers/isubscription';
+import { clone } from '../helpers/strict-type-checks';
 
 import { ChartModel, HoveredObject, TrackingModeExitMode } from '../model/chart-model';
 import { Coordinate } from '../model/coordinate';
 import { IDataSource } from '../model/idata-source';
 import { InvalidationLevel } from '../model/invalidate-mask';
 import { IPriceDataSource } from '../model/iprice-data-source';
-import { Pane } from '../model/pane';
+import { Pane, PaneCursorType } from '../model/pane';
 import { Point } from '../model/point';
 import { TimePointIndex } from '../model/time-data';
 import { IPaneRenderer } from '../renderers/ipane-renderer';
@@ -20,7 +21,7 @@ import { IPaneView } from '../views/pane/ipane-view';
 import { createBoundCanvas, getContext2D, Size } from './canvas-utils';
 import { ChartWidget } from './chart-widget';
 import { KineticAnimation } from './kinetic-animation';
-import { MouseEventHandler, MouseEventHandlerMouseEvent, MouseEventHandlers, MouseEventHandlerTouchEvent, Position, TouchMouseEvent } from './mouse-event-handler';
+import { InputEventType, isInputEventListener as isInputEventListener, MouseEventHandler, MouseEventHandlerMouseEvent, MouseEventHandlers, MouseEventHandlerTouchEvent, Position, TouchMouseEvent } from './mouse-event-handler';
 import { PriceAxisWidget, PriceAxisWidgetSide } from './price-axis-widget';
 
 const enum Constants {
@@ -58,10 +59,10 @@ export interface HitTestResult {
 	view: IPaneView;
 }
 
-interface HitTestPaneViewResult {
-	view: IPaneView;
-	object?: HoveredObject;
-}
+// interface HitTestPaneViewResult {
+	// view: IPaneView;
+	// object?: HitTestResult;
+// }
 
 interface StartScrollPosition extends Point {
 	timestamp: number;
@@ -188,6 +189,13 @@ export class PaneWidget implements IDestroyable, MouseEventHandlers {
 		this.updatePriceAxisWidgetsStates();
 	}
 
+	public setCursor(type: PaneCursorType): void {
+		const cursor = type.toString();
+		if (this._paneCell.style.cursor !== cursor) {
+			this._paneCell.style.cursor = cursor;
+		}
+	}
+
 	public chart(): ChartWidget {
 		return this._chart;
 	}
@@ -251,20 +259,26 @@ export class PaneWidget implements IDestroyable, MouseEventHandlers {
 		this._onMouseEvent();
 		this._mouseTouchDownEvent();
 		this._setCrosshairPosition(event.localX, event.localY);
+		this._propagateEvent(InputEventType.MouseDown, event);
 	}
 
 	public mouseMoveEvent(event: MouseEventHandlerMouseEvent): void {
 		if (!this._state) {
 			return;
 		}
-		this._onMouseEvent();
+		// this._onMouseEvent();
 
 		const x = event.localX;
 		const y = event.localY;
 
+		if (this._preventCrosshairMove()) {
+			this._clearCrosshairPosition();
+		}
+
 		this._setCrosshairPosition(x, y);
-		const hitTest = this.hitTest(x, y);
-		this._model().setHoveredSource(hitTest && { source: hitTest.source, object: hitTest.object });
+		this._propagateEvent(InputEventType.MouseMove, event);
+		// const hitTest = this.hitTest(x, y);
+		// this._model().setHoveredSource(hitTest && { source: hitTest.source, object: hitTest.object });
 	}
 
 	public mouseClickEvent(event: MouseEventHandlerMouseEvent): void {
@@ -272,20 +286,45 @@ export class PaneWidget implements IDestroyable, MouseEventHandlers {
 			return;
 		}
 		this._onMouseEvent();
+		this._propagateEvent(InputEventType.MouseClick, event);
 
 		const x = event.localX;
 		const y = event.localY;
 
 		if (this._clicked.hasListeners()) {
 			const currentTime = this._model().crosshairSource().appliedIndex();
-			this._clicked.fire(currentTime, { x, y });
+			this._clicked.fire(currentTime, new Point(x, y));
 		}
+		this._tryExitTrackingMode();
 	}
 
-	public pressedMouseMoveEvent(event: MouseEventHandlerMouseEvent): void {
+	public mouseDoubleClickEvent(event: MouseEventHandlerMouseEvent): void {
+		if (this._state === null) {
+			return;
+		}
 		this._onMouseEvent();
+		this._propagateEvent(InputEventType.MouseDoubleClick, event);
+
+		const selectedLineTools = this.state().getSelectedLineTools();
+		if (selectedLineTools.length > 0) {
+			const lineTool = selectedLineTools[0];
+			// While linetool is being created, we don't necessarely want to fire the event.
+			// for instance when finishing creating the path linetool.
+			if (lineTool.creating()) {
+				lineTool.setCreating(false);
+			} else {
+				// create a new lineToolExport to make sure that any change in the lineTool exported in not immediately applied.
+				const selectedLineTool = clone(selectedLineTools[0].exportLineToolToLineToolExport());
+				this._model().fireLineToolsDoubleClick(selectedLineTool);
+			}
+		}
+	}
+
+	public pressedMouseMoveEvent(event: MouseEventHandlerMouseEvent): void {
+		// this._onMouseEvent();
 		this._pressedMouseTouchMoveEvent(event);
-		this._setCrosshairPosition(event.localX, event.localY);
+		// this._setCrosshairPosition(event.localX, event.localY);
+		// this._propagateEvent(InputEventType.PressedMouseMove, event);
 	}
 
 	public mouseUpEvent(event: MouseEventHandlerMouseEvent): void {
@@ -293,6 +332,7 @@ export class PaneWidget implements IDestroyable, MouseEventHandlers {
 			return;
 		}
 		this._onMouseEvent();
+		this._propagateEvent(InputEventType.MouseUp, event);
 
 		this._longTap = false;
 
@@ -303,7 +343,7 @@ export class PaneWidget implements IDestroyable, MouseEventHandlers {
 		this._longTap = true;
 
 		if (this._startTrackPoint === null) {
-			const point: Point = { x: event.localX, y: event.localY };
+			const point: Point = new Point(event.localX, event.localY);
 			this._startTrackingMode(point, point);
 		}
 	}
@@ -344,10 +384,12 @@ export class PaneWidget implements IDestroyable, MouseEventHandlers {
 
 		this._mouseTouchDownEvent();
 
+		this._propagateEvent(InputEventType.MouseDown, event);
+
 		if (this._startTrackPoint !== null) {
 			const crosshair = this._model().crosshairSource();
-			this._initCrosshairPosition = { x: crosshair.appliedX(), y: crosshair.appliedY() };
-			this._startTrackPoint = { x: event.localX, y: event.localY };
+			this._initCrosshairPosition = new Point(crosshair.appliedX(), crosshair.appliedY());
+			this._startTrackPoint = new Point(event.localX, event.localY);
 		}
 	}
 
@@ -365,7 +407,9 @@ export class PaneWidget implements IDestroyable, MouseEventHandlers {
 			const newX = origPoint.x + (x - this._startTrackPoint.x) as Coordinate;
 			const newY = origPoint.y + (y - this._startTrackPoint.y) as Coordinate;
 			this._setCrosshairPosition(newX, newY);
-			return;
+			// return;
+		} else if (!this._preventCrosshairMove()) {
+			this._setCrosshairPosition(x, y);
 		}
 
 		this._pressedMouseTouchMoveEvent(event);
@@ -375,30 +419,32 @@ export class PaneWidget implements IDestroyable, MouseEventHandlers {
 		if (this.chart().options().trackingMode.exitMode === TrackingModeExitMode.OnTouchEnd) {
 			this._exitTrackingModeOnNextTry = true;
 		}
+		this._propagateEvent(InputEventType.MouseUp, event);
 		this._tryExitTrackingMode();
 		this._endScroll(event);
 	}
 
-	public hitTest(x: Coordinate, y: Coordinate): HitTestResult | null {
-		const state = this._state;
-		if (state === null) {
-			return null;
-		}
-
-		const sources = state.orderedSources();
-		for (const source of sources) {
-			const sourceResult = this._hitTestPaneView(source.paneViews(state), x, y);
-			if (sourceResult !== null) {
-				return {
-					source: source,
-					view: sourceResult.view,
-					object: sourceResult.object,
-				};
-			}
-		}
-
-		return null;
-	}
+	// public hitTest(x: Coordinate, y: Coordinate): HitTestResult | null {
+		// const state = this._state;
+		// if (state === null) {
+			// return null;
+		// }
+
+		// const sources = state.orderedSources();
+		// for (const source of sources) {
+			// const sourceResult = this._hitTestPaneView(source.paneViews(state), x, y);
+			// if (sourceResult !== null) {
+				// return {
+					// source: source,
+					// view: sourceResult.view,
+					// object: sourceResult.object,
+				// };
+				// //return sourceResult.object || null;
+			// }
+		// }
+
+		// return null;
+	// }
 
 	public setPriceAxisSize(width: number, position: PriceAxisWidgetSide): void {
 		const priceAxisWidget = position === 'left' ? this._leftPriceAxisWidget : this._rightPriceAxisWidget;
@@ -496,6 +542,53 @@ export class PaneWidget implements IDestroyable, MouseEventHandlers {
 		return this._rightPriceAxisWidget;
 	}
 
+	public getCrosshairPosition(x: Coordinate, y: Coordinate): void {
+		this._model().setAndSaveCurrentPosition(this._correctXCoord(x), this._correctYCoord(y), ensureNotNull(this._state));
+	}
+
+	public setCrossHair(xx: number, yy: number, visible: boolean): void {
+		if (!this._state) {
+			return;
+		}
+		if (visible) {
+			const x = xx as Coordinate;
+			const y = yy as Coordinate;
+
+			this._setCrosshairPositionNoFire(x, y);
+		} else {
+			this._state.model().setHoveredSource(null);
+			this._clearCrosshairPosition();
+		}
+	}
+
+	public clearCrossHair(): void {
+		this._clearCrosshairPosition();
+	}
+
+	private _propagateEvent(type: InputEventType, event: TouchMouseEvent): void {
+		if (this._state === null) { return; }
+		this.setCursor(PaneCursorType.Crosshair);
+
+		const ctx = getContext2D(this.getImage());
+
+		// if (this._model().lineToolCreator().hasActiveToolLine()) {
+		this._model().lineToolCreator().onInputEvent(this, ctx, type, event);
+		// }
+
+		const sources = this._state.orderedSources();
+		for (let index = sources.length - 1; index >= 0; index--) {
+			const sourcePane = this._model().paneForSource(sources[index]);
+			if (sourcePane !== null) {
+				const paneViews = sources[index].paneViews(sourcePane);
+				paneViews.forEach((pane: IPaneView) => {
+					if (isInputEventListener(pane)) {
+						pane.onInputEvent(this, ctx, type, event);
+					}
+				});
+			}
+		}
+	}
+
 	private _onStateDestroyed(): void {
 		if (this._state !== null) {
 			this._state.onDestroyed().unsubscribeAll(this);
@@ -580,22 +673,22 @@ export class PaneWidget implements IDestroyable, MouseEventHandlers {
 		}
 	}
 
-	private _hitTestPaneView(paneViews: readonly IPaneView[], x: Coordinate, y: Coordinate): HitTestPaneViewResult | null {
-		for (const paneView of paneViews) {
-			const renderer = paneView.renderer(this._size.h, this._size.w);
-			if (renderer !== null && renderer.hitTest) {
-				const result = renderer.hitTest(x, y);
-				if (result !== null) {
-					return {
-						view: paneView,
-						object: result,
-					};
-				}
-			}
-		}
+	// private _hitTestPaneView(paneViews: readonly IPaneView[], x: Coordinate, y: Coordinate): HitTestPaneViewResult | null {
+		// for (const paneView of paneViews) {
+			// const renderer = paneView.renderer(this._size.h, this._size.w);
+			// if (renderer !== null && renderer.hitTest) {
+				// const result = renderer.hitTest(x, y);
+				// if (result !== null) {
+					// return {
+						// view: paneView,
+						// object: result,
+					// };
+				// }
+			// }
+		// }
 
-		return null;
-	}
+		// return null;
+	// }
 
 	private _recreatePriceAxisWidgets(): void {
 		if (this._state === null) {
@@ -625,6 +718,10 @@ export class PaneWidget implements IDestroyable, MouseEventHandlers {
 		}
 	}
 
+	private _preventCrosshairMove(): boolean {
+		return /* trackCrosshairOnlyAfterLongTap && */this._startTrackPoint === null;
+	}
+
 	private _preventScroll(event: TouchMouseEvent): boolean {
 		return event.isTouch && this._longTap || this._startTrackPoint !== null;
 	}
@@ -645,6 +742,10 @@ export class PaneWidget implements IDestroyable, MouseEventHandlers {
 		this._model().clearCurrentPosition();
 	}
 
+	private _setCrosshairPositionNoFire(x: Coordinate, y: Coordinate): void {
+		this._model().setAndSaveCurrentPositionFire(this._correctXCoord(x), this._correctYCoord(y), false, ensureNotNull(this._state));
+	}
+
 	private _tryExitTrackingMode(): void {
 		if (this._exitTrackingModeOnNextTry) {
 			this._startTrackPoint = null;
@@ -657,7 +758,7 @@ export class PaneWidget implements IDestroyable, MouseEventHandlers {
 		this._exitTrackingModeOnNextTry = false;
 		this._setCrosshairPosition(crossHairPosition.x, crossHairPosition.y);
 		const crosshair = this._model().crosshairSource();
-		this._initCrosshairPosition = { x: crosshair.appliedX(), y: crosshair.appliedY() };
+		this._initCrosshairPosition = new Point(crosshair.appliedX(), crosshair.appliedY());
 	}
 
 	private _model(): ChartModel {
@@ -762,8 +863,26 @@ export class PaneWidget implements IDestroyable, MouseEventHandlers {
 		}
 
 		const model = this._model();
+		const x = event.localX;
+		const y = event.localY;
+
+		if (this._startTrackPoint !== null) {
+			// tracking mode: move crosshair
+			this._exitTrackingModeOnNextTry = false;
+			const origPoint = ensureNotNull(this._initCrosshairPosition);
+			const newX = (origPoint.x + (x - this._startTrackPoint.x)) as Coordinate;
+			const newY = (origPoint.y + (y - this._startTrackPoint.y)) as Coordinate;
+			this._setCrosshairPosition(newX, newY);
+		// } else if (!this._preventCrosshairMove()) { // in case of mouse event, always return false in drawings repo
+		} else {
+			this._setCrosshairPosition(x, y);
+		}
+
+		if (this._startScrollingPos === null) {
+			this._propagateEvent(InputEventType.PressedMouseMove, event);
+		}
 
-		if (model.timeScale().isEmpty()) {
+		if (model.timeScale().isEmpty() || event.consumed) {
 			return;
 		}
 
@@ -782,13 +901,10 @@ export class PaneWidget implements IDestroyable, MouseEventHandlers {
 		const now = performance.now();
 
 		if (this._startScrollingPos === null && !this._preventScroll(event)) {
-			this._startScrollingPos = {
-				x: event.clientX,
-				y: event.clientY,
-				timestamp: now,
-				localX: event.localX,
-				localY: event.localY,
-			};
+			this._startScrollingPos = new Point(event.clientX, event.clientY) as StartScrollPosition;
+			this._startScrollingPos.timestamp = now;
+			this._startScrollingPos.localX = event.localX;
+			this._startScrollingPos.localY = event.localY;
 		}
 
 		if (this._scrollXAnimation !== null) {
diff --git a/src/gui/time-axis-widget.ts b/src/gui/time-axis-widget.ts
index abec725..f052a58 100644
--- a/src/gui/time-axis-widget.ts
+++ b/src/gui/time-axis-widget.ts
@@ -277,7 +277,7 @@ export class TimeAxisWidget implements MouseEventHandlers, IDestroyable {
 			this._drawTickMarks(ctx, this._canvasBinding.pixelRatio);
 			// atm we don't have sources to be drawn on time axis except crosshair which is rendered on top level canvas
 			// so let's don't call this code at all for now
-			// this._drawLabels(this._chart.model().dataSources(), ctx, pixelRatio);
+			this._drawLabels(this._chart.model().dataSources(), ctx, this._canvasBinding.pixelRatio);
 
 			if (this._leftStub !== null) {
 				this._leftStub.paint(type);
@@ -400,8 +400,9 @@ export class TimeAxisWidget implements MouseEventHandlers, IDestroyable {
 		const rendererOptions = this._getRendererOptions();
 		for (const source of sources) {
 			for (const view of source.timeAxisViews()) {
+				const renderer = view.renderer();
 				ctx.save();
-				view.renderer().draw(ctx, rendererOptions, pixelRatio);
+				renderer.draw(ctx, rendererOptions, pixelRatio);
 				ctx.restore();
 			}
 		}
diff --git a/src/helpers/deep-copy.ts b/src/helpers/deep-copy.ts
new file mode 100644
index 0000000..2ed56df
--- /dev/null
+++ b/src/helpers/deep-copy.ts
@@ -0,0 +1,31 @@
+export function deepCopy<T>(value: T): T {
+	// eslint-disable-next-line @typescript-eslint/no-explicit-any
+	let copy: any;
+	if (
+		typeof value != 'object' ||
+		value === null ||
+		typeof (value as Record<string, unknown>).nodeType == 'number'
+	) {
+		copy = value;
+	} else if (value instanceof Date) {
+		copy = new Date(value.valueOf());
+	} else if (Array.isArray(value)) {
+		copy = [];
+
+		for (let i = 0; i < value.length; i++) {
+			if (Object.prototype.hasOwnProperty.call(value, i)) {
+				// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
+				copy[i] = deepCopy(value[i]);
+			}
+		}
+	} else {
+		copy = {};
+
+		Object.keys(value).forEach((key: string) => {
+			// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
+			copy[key] = deepCopy((value as Record<string, unknown>)[key]);
+		});
+	}
+
+	return copy as T;
+}
diff --git a/src/helpers/strict-type-checks.ts b/src/helpers/strict-type-checks.ts
index 56ac22d..3ea8400 100644
--- a/src/helpers/strict-type-checks.ts
+++ b/src/helpers/strict-type-checks.ts
@@ -1,3 +1,13 @@
+/* eslint-disable @typescript-eslint/no-explicit-any */
+/* eslint-disable @typescript-eslint/ban-types */
+
+type OmitDistributive<T, K extends PropertyKey> = T extends any ? (T extends object ? Id<OmitRecursively<T, K>> : T) : never;
+type Id<T> = {} & { [P in keyof T]: T[P] };
+export type OmitRecursively<T extends any, K extends PropertyKey> = Omit<
+    { [P in keyof T]: OmitDistributive<T[P], K> },
+    K
+>;
+
 /**
  * Represents a type `T` where every property is optional.
  */
diff --git a/src/helpers/uid.ts b/src/helpers/uid.ts
new file mode 100644
index 0000000..70f97cc
--- /dev/null
+++ b/src/helpers/uid.ts
@@ -0,0 +1,21 @@
+const source = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
+
+export function guid(): string {
+	return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (e: string) => {
+		const t = 16 * Math.random() | 0;
+		return ('x' === e ? t : 3 & t | 8).toString(16);
+	});
+}
+
+export function randomHash(): string {
+	return randomHashN(12);
+}
+
+export function randomHashN(count: number): string {
+	let hash = '';
+	for (let i = 0; i < count; ++i) {
+		const index = Math.floor(Math.random() * source.length);
+		hash += source[index];
+	}
+	return hash;
+}
diff --git a/src/index.ts b/src/index.ts
index 9f5b3d0..cddf80c 100644
--- a/src/index.ts
+++ b/src/index.ts
@@ -6,8 +6,11 @@ export { TrackingModeExitMode } from './model/chart-model';
 export { CrosshairMode } from './model/crosshair';
 export { PriceScaleMode } from './model/price-scale';
 export { PriceLineSource, LastPriceAnimationMode, LasPriceAnimationMode } from './model/series-options';
+export { BoxHorizontalAlignment, BoxVerticalAlignment } from './model/line-tool-options';
 export { TickMarkType } from './model/time-scale';
 export { ColorType } from './model/layout-options';
+export { LineEnd } from './renderers/draw-line';
+export { TextAlignment } from './model/line-tool-options';
 
 export {
 	isBusinessDay,
diff --git a/src/model/canvas-render-params.ts b/src/model/canvas-render-params.ts
new file mode 100644
index 0000000..9d87e00
--- /dev/null
+++ b/src/model/canvas-render-params.ts
@@ -0,0 +1,7 @@
+export interface CanvasRenderParams {
+	pixelRatio: number;
+	physicalWidth: number;
+	physicalHeight: number;
+	cssWidth: number;
+	cssHeight: number;
+}
diff --git a/src/model/chart-model.ts b/src/model/chart-model.ts
index 9eaa559..c2db5e6 100644
--- a/src/model/chart-model.ts
+++ b/src/model/chart-model.ts
@@ -17,6 +17,10 @@ import { GridOptions } from './grid';
 import { InvalidateMask, InvalidationLevel } from './invalidate-mask';
 import { IPriceDataSource } from './iprice-data-source';
 import { ColorType, LayoutOptions, LayoutOptionsInternal } from './layout-options';
+import { LineTool, LineToolExport, LineToolPoint } from './line-tool';
+import { LineToolCreator } from './line-tool-creator';
+import { LineToolOptionsMap, LineToolType } from './line-tool-options';
+import { LineTools } from './line-tools';
 import { LocalizationOptions } from './localization-options';
 import { Magnet } from './magnet';
 import { DEFAULT_STRETCH_FACTOR, Pane } from './pane';
@@ -330,6 +334,7 @@ export class ChartModel implements IDestroyable {
 
 	private readonly _timeScale: TimeScale;
 	private readonly _panes: Pane[] = [];
+	private readonly _lineToolCreator: LineToolCreator;
 	private readonly _crosshair: Crosshair;
 	private readonly _magnet: Magnet;
 	private readonly _watermark: Watermark;
@@ -341,6 +346,8 @@ export class ChartModel implements IDestroyable {
 	private _hoveredSource: HoveredSource | null = null;
 	private readonly _priceScalesOptionsChanged: Delegate = new Delegate();
 	private _crosshairMoved: Delegate<TimePointIndex | null, Point | null> = new Delegate();
+	private _lineToolsDoubleClick: Delegate<LineToolExport<LineToolType>> = new Delegate();
+	private _lineToolsAfterEdit: Delegate<LineToolExport<LineToolType>, string> = new Delegate();
 
 	private _backgroundTopColor: string;
 	private _backgroundBottomColor: string;
@@ -356,6 +363,7 @@ export class ChartModel implements IDestroyable {
 		this._crosshair = new Crosshair(this, options.crosshair);
 		this._magnet = new Magnet(options.crosshair);
 		this._watermark = new Watermark(this, options.watermark);
+		this._lineToolCreator = new LineToolCreator(this);
 
 		this.createPane();
 		this._panes[0].setStretchFactor(DEFAULT_STRETCH_FACTOR * 2);
@@ -385,6 +393,16 @@ export class ChartModel implements IDestroyable {
 		return this._hoveredSource;
 	}
 
+	public dataSources(): IPriceDataSource[] {
+		const sources: IPriceDataSource[] = [];
+		for (const pane of this._panes) {
+			for (const paneSource of pane.dataSources()) {
+				sources.push(paneSource);
+			}
+		}
+		return sources;
+	}
+
 	public setHoveredSource(source: HoveredSource | null): void {
 		const prevSource = this._hoveredSource;
 		this._hoveredSource = source;
@@ -467,6 +485,10 @@ export class ChartModel implements IDestroyable {
 		return this._timeScale;
 	}
 
+	public getActivePane(): Pane | null {
+		return this._panes.length > 0 ? this._panes[0] : null;
+	}
+
 	public panes(): readonly Pane[] {
 		return this._panes;
 	}
@@ -475,14 +497,30 @@ export class ChartModel implements IDestroyable {
 		return this._watermark;
 	}
 
+	public lineToolCreator(): LineToolCreator {
+		return this._lineToolCreator;
+	}
+
 	public crosshairSource(): Crosshair {
 		return this._crosshair;
 	}
 
+	public magnet(): Magnet {
+		return this._magnet;
+	}
+
 	public crosshairMoved(): ISubscription<TimePointIndex | null, Point | null> {
 		return this._crosshairMoved;
 	}
 
+	public lineToolsDoubleClick(): ISubscription<LineToolExport<LineToolType>> {
+		return this._lineToolsDoubleClick;
+	}
+
+	public lineToolsAfterEdit(): ISubscription<LineToolExport<LineToolType>, string> {
+		return this._lineToolsAfterEdit;
+	}
+
 	public setPaneHeight(pane: Pane, height: number): void {
 		pane.setHeight(height);
 		this.recalculateAllPanes();
@@ -653,7 +691,7 @@ export class ChartModel implements IDestroyable {
 		this._crosshair.setPosition(index, price, pane);
 
 		this.cursorUpdate();
-		this._crosshairMoved.fire(this._crosshair.appliedIndex(), { x, y });
+		this._crosshairMoved.fire(this._crosshair.appliedIndex(), new Point(x, y));
 	}
 
 	public clearCurrentPosition(): void {
@@ -675,6 +713,30 @@ export class ChartModel implements IDestroyable {
 		this._crosshair.updateAllViews();
 	}
 
+	public setAndSaveCurrentPositionFire(x: Coordinate, y: Coordinate, fire: boolean, pane: Pane): void {
+		this._crosshair.saveOriginCoord(x, y);
+		let price = NaN;
+		let index = this._timeScale.coordinateToIndex(x);
+
+		const visibleBars = this._timeScale.visibleStrictRange();
+		if (visibleBars !== null) {
+			index = Math.min(Math.max(visibleBars.left(), index), visibleBars.right()) as TimePointIndex;
+		}
+
+		const priceScale = pane.defaultPriceScale();
+		const firstValue = priceScale.firstValue();
+		if (firstValue !== null) {
+			price = priceScale.coordinateToPrice(y, firstValue);
+		}
+		price = this._magnet.align(price, index, pane);
+
+		this._crosshair.setPosition(index, price, pane);
+		this.cursorUpdate();
+		if (fire) {
+			this._crosshairMoved.fire(this._crosshair.appliedIndex(), new Point(x, y));
+		}
+	}
+
 	public updateTimeScale(newBaseIndex: TimePointIndex | null, newPoints?: readonly TimeScalePoint[], firstChangedPointIndex?: number): void {
 		const oldFirstTime = this._timeScale.indexToTime(0 as TimePointIndex);
 
@@ -723,6 +785,14 @@ export class ChartModel implements IDestroyable {
 		this.updateCrosshair();
 	}
 
+	public fireLineToolsDoubleClick(selectedLineTools: LineToolExport<LineToolType>): void {
+		this._lineToolsDoubleClick.fire(selectedLineTools);
+	}
+
+	public fireLineToolsAfterEdit(selectedLineTools: LineToolExport<LineToolType>, stage: string): void {
+		this._lineToolsAfterEdit.fire(selectedLineTools, stage);
+	}
+
 	public destroy(): void {
 		this._panes.forEach((p: Pane) => p.destroy());
 		this._panes.length = 0;
@@ -772,6 +842,13 @@ export class ChartModel implements IDestroyable {
 		}
 	}
 
+	public createLineTool<T extends LineToolType>(lineToolType: T, options: LineToolOptionsMap[T], points: LineToolPoint[]): LineTool<T> {
+		const lineTool = new LineTools[lineToolType](this, options, points) as LineTool<T>;
+		// TODO: iosif add to ownerSourceId pane
+		this._panes[0].addDataSource(lineTool as unknown as IPriceDataSource, this.defaultVisiblePriceScaleId());
+		return lineTool;
+	}
+
 	public moveSeriesToScale(series: Series, targetScaleId: string): void {
 		const pane = ensureNotNull(this.paneForSource(series));
 		pane.removeDataSource(series);
diff --git a/src/model/crosshair.ts b/src/model/crosshair.ts
index db36c67..58dfde2 100644
--- a/src/model/crosshair.ts
+++ b/src/model/crosshair.ts
@@ -106,6 +106,10 @@ export interface CrosshairOptions {
 	 * @defaultValue {@link CrosshairMode.Magnet}
 	 */
 	mode: CrosshairMode;
+	/**
+	 * The threashold of the magnet
+	 */
+	magnetThreshold: number;
 
 	/**
 	 * Vertical line options.
diff --git a/src/model/data-source.ts b/src/model/data-source.ts
index de3d52f..b09acf4 100644
--- a/src/model/data-source.ts
+++ b/src/model/data-source.ts
@@ -1,3 +1,5 @@
+import { randomHashN } from '../helpers/uid';
+
 import { IPaneView } from '../views/pane/ipane-view';
 import { IPriceAxisView } from '../views/price-axis/iprice-axis-view';
 import { ITimeAxisView } from '../views/time-axis/itime-axis-view';
@@ -8,9 +10,18 @@ import { PriceScale } from './price-scale';
 
 export abstract class DataSource implements IDataSource {
 	protected _priceScale: PriceScale | null = null;
+	private _id: string = randomHashN(6);
 
 	private _zorder: number = 0;
 
+	public id(): string {
+		return this._id;
+	}
+
+	public setId(id: string): void {
+		this._id = id;
+	}
+	
 	public zorder(): number {
 		return this._zorder;
 	}
diff --git a/src/model/hit-test-result.ts b/src/model/hit-test-result.ts
new file mode 100644
index 0000000..b912d97
--- /dev/null
+++ b/src/model/hit-test-result.ts
@@ -0,0 +1,25 @@
+export class HitTestResult<T> {
+	private _data: T | null;
+	private _type: HitTestType;
+
+	public constructor(type: HitTestType, data?: T) {
+		this._type = type;
+		this._data = data || null;
+	}
+
+	public type(): HitTestType {
+		return this._type;
+	}
+
+	public data(): T | null {
+		return this._data;
+	}
+}
+
+export enum HitTestType {
+    Regular = 1,
+    MovePoint = 2,
+	MovePointBackground = 3,
+    ChangePoint = 4,
+    Custom = 5
+}
diff --git a/src/model/interesection.ts b/src/model/interesection.ts
new file mode 100644
index 0000000..524c97b
--- /dev/null
+++ b/src/model/interesection.ts
@@ -0,0 +1,238 @@
+import { Coordinate } from './coordinate';
+import { Box, equalPoints, HalfPlane, Line, lineSegment, lineThroughPoints, Point, pointInHalfPlane, Segment } from './point';
+
+function addPoint(array: Point[], point: Point): boolean {
+	for (let i = 0; i < array.length; i++) {
+		if (equalPoints(array[i], point)) {
+			return false;
+		}
+	}
+
+	array.push(point);
+	return true;
+}
+
+export function intersectLineAndBox(line: Line, box: Box): Segment | Point | null {
+	if (line.a === 0) {
+		const l = -line.c / line.b;
+		return box.min.y <= l && l <= box.max.y ? lineSegment(new Point(box.min.x, l), new Point(box.max.x, l)) : null;
+	}
+	if (line.b === 0) {
+		const h = -line.c / line.a;
+		return box.min.x <= h && h <= box.max.x ? lineSegment(new Point(h, box.min.y), new Point(h, box.max.y)) : null;
+	}
+
+	const points: Point[] = [];
+	const u = function(value: number): void {
+		const i = -(line.c + line.a * value) / line.b;
+		if (box.min.y <= i && i <= box.max.y) { addPoint(points, new Point(value, i)); }
+	};
+	const p = function(value: number): void {
+		const s = -(line.c + line.b * value) / line.a;
+		if (box.min.x <= s && s <= box.max.x) { addPoint(points, new Point(s, value)); }
+	};
+
+	u(box.min.x);
+	p(box.min.y);
+	u(box.max.x);
+	p(box.max.y);
+
+	switch (points.length) {
+		case 0:
+			return null;
+		case 1:
+			return points[0];
+		case 2:
+			return equalPoints(points[0], points[1]) ? points[0] : lineSegment(points[0], points[1]);
+	}
+
+	throw new Error('We should have at most two intersection points');
+	return null;
+}
+
+export function intersectRayAndBox(point0: Point, point1: Point, box: Box): Point | null {
+	const s = intersectLineSegments(point0, point1, box.min, new Point(box.max.x, box.min.y));
+	const n = intersectLineSegments(point0, point1, new Point(box.max.x, box.min.y), box.max);
+	const a = intersectLineSegments(point0, point1, box.max, new Point(box.min.x, box.max.y));
+	const c = intersectLineSegments(point0, point1, new Point(box.min.x, box.max.y), box.min);
+
+	const h = [];
+	if (null !== s && s >= 0) { h.push(s); }
+	if (null !== n && n >= 0) { h.push(n); }
+	if (null !== a && a >= 0) { h.push(a); }
+	if (null !== c && c >= 0) { h.push(c); }
+
+	if (0 === h.length) { return null; }
+	h.sort((e: number, t: number) => e - t);
+
+	const d = pointInBox(point0, box) ? h[0] : h[h.length - 1];
+	return point0.addScaled(point1.subtract(point0), d);
+}
+
+export function intersectLineSegments(point0: Point, point1: Point, point2: Point, point3: Point): number | null {
+	const z = (function(e: Point, t: Point, i: Point, s: Point): number | null {
+		const r = t.subtract(e);
+		const n = s.subtract(i);
+		const o = r.x * n.y - r.y * n.x;
+		if (Math.abs(o) < 1e-6) {return null;}
+		const a = e.subtract(i);
+		return (a.y * n.x - a.x * n.y) / o;
+	})(point0, point1, point2, point3);
+
+	if (null === z) {return null;}
+	const o = point1.subtract(point0).scaled(z).add(point0);
+	const a = distanceToSegment(point2, point3, o);
+	return Math.abs(a.distance) < 1e-6 ? z : null;
+}
+
+export function intersectLineSegmentAndBox(segment: Segment, box: Box): Point | Segment | null {
+	let i = segment[0].x;
+	let s = segment[0].y;
+	let n = segment[1].x;
+	let o = segment[1].y;
+	const a = box.min.x;
+	const l = box.min.y;
+	const c = box.max.x;
+	const h = box.max.y;
+
+	function d(n1: number, n2: number, n3: number, n4: number, n5: number, n6: number): number {
+		let z = 0;
+		if (n1 < n3) { z |= 1; } else if (n1 > n5) { z |= 2; }
+		if (n2 < n4) { z |= 4; } else if (n2 > n6) { z |= 8; }
+		return z;
+	}
+
+	let check = false;
+
+	for (let u = d(i, s, a, l, c, h), p = d(n, o, a, l, c, h), m = 0; ;) {
+		if (m > 1e3) {throw new Error('Cohen - Sutherland algorithm: infinity loop');}
+		m++;
+
+		if (!(u | p)) {
+			check = true;
+			break;
+		}
+
+		if (u & p) {break;}
+
+		const g = u || p;
+		let f: number | undefined = void 0;
+		let v: number | undefined = void 0;
+
+		if (8 & g) {
+			f = i + (n - i) * (h - s) / (o - s);
+			v = h;
+		} else if (4 & g) {
+			f = i + (n - i) * (l - s) / (o - s);
+			v = l;
+		} else if (2 & g) {
+			v = s + (o - s) * (c - i) / (n - i);
+			f = c;
+		} else {
+			v = s + (o - s) * (a - i) / (n - i);
+			f = a;
+		}
+
+		if (g === u) {
+			i = f as Coordinate;
+			s = v as Coordinate;
+			u = d(i, s, a, l, c, h);
+		} else {
+			n = f as Coordinate;
+			o = v as Coordinate;
+			p = d(n, o, a, l, c, h);
+		}
+	}
+
+	return check ? equalPoints(new Point(i, s), new Point(n, o)) ? new Point(i, s) : lineSegment(new Point(i, s), new Point(n, o)) : null;
+}
+
+export function distanceToLine(point0: Point, point1: Point, point2: Point): { distance: number; coeff: number } {
+	const s = point1.subtract(point0);
+	const r = point2.subtract(point0).dotProduct(s) / s.dotProduct(s);
+	return { coeff: r, distance: point0.addScaled(s, r).subtract(point2).length() };
+}
+
+export function distanceToSegment(point0: Point, point1: Point, point2: Point): { distance: number; coeff: number } {
+	const lineDist = distanceToLine(point0, point1, point2);
+	if (0 <= lineDist.coeff && lineDist.coeff <= 1) { return lineDist; }
+
+	const n = point0.subtract(point2).length();
+	const o = point1.subtract(point2).length();
+
+	return n < o ? { coeff: 0, distance: n } : { coeff: 1, distance: o };
+}
+
+export function pointInBox(point: Point, box: Box): boolean {
+	return point.x >= box.min.x && point.x <= box.max.x && point.y >= box.min.y && point.y <= box.max.y;
+}
+
+export function pointInPolygon(point: Point, polygon: Point[]): boolean {
+	const x = point.x;
+	const y = point.y;
+	let isInside = false;
+
+	for (let j = polygon.length - 1, i = 0; i < polygon.length; i++) {
+		const curr = polygon[i];
+		const prev = polygon[j];
+		j = i;
+
+		if ((curr.y < y && prev.y >= y || prev.y < y && curr.y >= y) && curr.x + (y - curr.y) / (prev.y - curr.y) * (prev.x - curr.x) < x) {
+			isInside = !isInside;
+		}
+	}
+	return isInside;
+}
+
+export function pointInTriangle(point: Point, end0: Point, end1: Point, end2: Point): boolean {
+	const middle = end0.add(end1).scaled(0.5).add(end2).scaled(0.5);
+	return intersectLineSegments(end0, end1, middle, point) === null
+		&& intersectLineSegments(end1, end2, middle, point) === null
+		&& intersectLineSegments(end2, end0, middle, point) === null;
+}
+
+export function intersectLines(line0: Line, line1: Line): Point | null {
+	const c = line0.a * line1.b - line1.a * line0.b;
+	if (Math.abs(c) < 1e-6) { return null; }
+
+	const x = (line0.b * line1.c - line1.b * line0.c) / c;
+	const y = (line1.a * line0.c - line0.a * line1.c) / c;
+	return new Point(x, y);
+}
+
+export function intersectPolygonAndHalfPlane(points: Point[], halfPlane: HalfPlane): Point[] | null {
+	const intersectionPoints: Point[] = [];
+	for (let i = 0; i < points.length; ++i) {
+		const current = points[i];
+		const next = points[(i + 1) % points.length];
+		const line = lineThroughPoints(current, next);
+
+		if (pointInHalfPlane(current, halfPlane)) {
+			addPointToPointsSet(intersectionPoints, current);
+			if (!pointInHalfPlane(next, halfPlane)) {
+				const lineIntersection = intersectLines(line, halfPlane.edge);
+				if (lineIntersection !== null) {
+					addPointToPointsSet(intersectionPoints, lineIntersection);
+				}
+			}
+		} else if (pointInHalfPlane(next, halfPlane)) {
+			const lineIntersection = intersectLines(line, halfPlane.edge);
+			if (lineIntersection !== null) {
+				addPointToPointsSet(intersectionPoints, lineIntersection);
+			}
+		}
+	}
+	return intersectionPoints.length >= 3 ? intersectionPoints : null;
+}
+
+function addPointToPointsSet(points: Point[], point: Point): boolean {
+	if (points.length <= 0 || !(equalPoints(points[points.length - 1], point) && equalPoints(points[0], point))) {
+		points.push(point);
+		return false;
+	}
+	return true;
+}
+
+export function pointInCircle(point: Point, edge0: Point, distance: number): boolean {
+	return (point.x - edge0.x) * (point.x - edge0.x) + (point.y - edge0.y) * (point.y - edge0.y) <= distance * distance;
+}
diff --git a/src/model/line-tool-arrow.ts b/src/model/line-tool-arrow.ts
new file mode 100644
index 0000000..51ac040
--- /dev/null
+++ b/src/model/line-tool-arrow.ts
@@ -0,0 +1,6 @@
+import { LineToolType } from './line-tool-options';
+import { LineToolTrendLine } from './line-tool-trend-line';
+
+export class LineToolArrow extends LineToolTrendLine {
+	protected override readonly _toolType: LineToolType = 'Arrow';
+}
diff --git a/src/model/line-tool-brush.ts b/src/model/line-tool-brush.ts
new file mode 100644
index 0000000..106b97c
--- /dev/null
+++ b/src/model/line-tool-brush.ts
@@ -0,0 +1,47 @@
+import { ensureNotNull } from '../helpers/assertions';
+
+import { BrushPaneView } from '../views/pane/brush-pane-view';
+
+import { ChartModel } from './chart-model';
+import { LineTool, LineToolPoint } from './line-tool';
+import { BrushToolOptions, LineToolType } from './line-tool-options';
+
+export class LineToolBrush extends LineTool<'Brush'> {
+	protected override readonly _toolType: LineToolType = 'Brush';
+
+	public constructor(model: ChartModel, options: BrushToolOptions, points: LineToolPoint[] = []) {
+		super(model, options, points);
+		this._setPaneViews([new BrushPaneView(this, model)]);
+	}
+
+	public pointsCount(): number {
+		return -1;
+	}
+
+	public smooth(): number {
+		return 5;
+	}
+
+	public getBrushOptions(): BrushToolOptions {
+		return this.options();
+	}
+
+	public override addPoint(point: LineToolPoint): void {
+		if (this._finished) { return; }
+		this._lastPoint = null;
+		if (this._points.length > 0) {
+			const endPoint = this._points[this._points.length - 1];
+			const endScreenPoint = ensureNotNull(this.pointToScreenPoint(endPoint));
+			if (ensureNotNull(this.pointToScreenPoint(point)).subtract(endScreenPoint).length() < 2) { return; }
+		}
+		return super.addPoint(point);
+	}
+
+	public override hasMagnet(): boolean {
+		return false;
+	}
+
+	public override lineDrawnWithPressedButton(): boolean {
+		return true;
+	}
+}
diff --git a/src/model/line-tool-creator.ts b/src/model/line-tool-creator.ts
new file mode 100644
index 0000000..610517f
--- /dev/null
+++ b/src/model/line-tool-creator.ts
@@ -0,0 +1,57 @@
+import { LineToolsOptionDefaults } from '../api/options/line-tools-options-defaults';
+
+import { IInputEventListener, InputEventType, TouchMouseEvent } from '../gui/mouse-event-handler';
+import { PaneWidget } from '../gui/pane-widget';
+
+import { clone, merge } from '../helpers/strict-type-checks';
+
+import { ChartModel } from './chart-model';
+import { IDataSource } from './idata-source';
+import { LineTool } from './line-tool';
+import { LineToolOptions, LineToolPartialOptions, LineToolPartialOptionsMap, LineToolType } from './line-tool-options';
+import { LineTools } from './line-tools';
+
+export class LineToolCreator implements IInputEventListener {
+	protected _lastLineTool: LineTool<LineToolType> | null = null;
+	protected _activeOptions: LineToolPartialOptions<unknown> | null = null;
+	protected _activeType: LineToolType | null = null;
+	protected _model: ChartModel;
+
+	public constructor(model: ChartModel) {
+		this._model = model;
+	}
+
+	public setActiveLineTool<T extends LineToolType>(lineToolType: T, options?: LineToolPartialOptionsMap[T]): void {
+		this._activeOptions = options || {};
+		this._activeType = lineToolType;
+
+		this._model.dataSources().forEach((source: IDataSource) => {
+			if (source instanceof LineTool) {
+				source.setSelected(false);
+				source.setHovered(false);
+				source.setEditing(false);
+				source.setCreating(false);
+			}
+		});
+		this._model.lightUpdate();
+	}
+
+	public hasActiveToolLine(): boolean {
+		return this._activeType !== null;
+	}
+
+	public onInputEvent(paneWidget: PaneWidget, ctx: CanvasRenderingContext2D, eventType: InputEventType, event: TouchMouseEvent): void {
+		if (!this._activeType || !this._activeOptions) { return; }
+		event.consumed = true;
+		if (eventType !== InputEventType.MouseDown) { return; }
+
+		const priceScaleId = paneWidget.state().dataSources()[0].priceScale()?.id() || paneWidget.state().model().defaultVisiblePriceScaleId();
+		const strictOptions = merge(clone(LineToolsOptionDefaults[this._activeType]), this._activeOptions || {}) as LineToolOptions<unknown>;
+
+		this._lastLineTool = new LineTools[this._activeType](this._model, strictOptions, []);
+		paneWidget.state().addDataSource(this._lastLineTool, priceScaleId);
+
+		this._activeType = null;
+		this._activeOptions = null;
+	}
+}
diff --git a/src/model/line-tool-cross-line.ts b/src/model/line-tool-cross-line.ts
new file mode 100644
index 0000000..c5f2882
--- /dev/null
+++ b/src/model/line-tool-cross-line.ts
@@ -0,0 +1,26 @@
+import { CrossLinePaneView } from '../views/pane/cross-line-pane-view';
+
+import { ChartModel } from './chart-model';
+import { LineTool, LineToolPoint } from './line-tool';
+import { CrossLineToolOptions, LineToolType } from './line-tool-options';
+
+export class LineToolCrossLine extends LineTool<'CrossLine'> {
+	protected override readonly _toolType: LineToolType = 'CrossLine';
+
+	public constructor(model: ChartModel, options: CrossLineToolOptions, points: LineToolPoint[] = []) {
+		super(model, options, points);
+		this._setPaneViews([new CrossLinePaneView(this, model)]);
+	}
+
+	public pointsCount(): number {
+		return 1;
+	}
+
+	public override timeAxisLabelColor(): string | null {
+		return this.options().line.color;
+	}
+
+	public override priceAxisLabelColor(): string | null {
+		return this.options().line.color;
+	}
+}
diff --git a/src/model/line-tool-extended-line.ts b/src/model/line-tool-extended-line.ts
new file mode 100644
index 0000000..4801474
--- /dev/null
+++ b/src/model/line-tool-extended-line.ts
@@ -0,0 +1,6 @@
+import { LineToolType } from './line-tool-options';
+import { LineToolTrendLine } from './line-tool-trend-line';
+
+export class LineToolExtendedLine extends LineToolTrendLine {
+	protected override readonly _toolType: LineToolType = 'ExtendedLine';
+}
diff --git a/src/model/line-tool-fib-retracement.ts b/src/model/line-tool-fib-retracement.ts
new file mode 100644
index 0000000..47f544d
--- /dev/null
+++ b/src/model/line-tool-fib-retracement.ts
@@ -0,0 +1,18 @@
+import { FibRetracementPaneView } from '../views/pane/fib-retracement-pane-view';
+
+import { ChartModel } from './chart-model';
+import { LineTool, LineToolPoint } from './line-tool';
+import { FibRetracementToolOptions, LineToolType } from './line-tool-options';
+
+export class LineToolFibRetracement extends LineTool<'FibRetracement'> {
+	protected override readonly _toolType: LineToolType = 'FibRetracement';
+
+	public constructor(model: ChartModel, options: FibRetracementToolOptions, points: LineToolPoint[] = []) {
+		super(model, options, points);
+		this._setPaneViews([new FibRetracementPaneView(this, model)]);
+	}
+
+	public pointsCount(): number {
+		return 2;
+	}
+}
diff --git a/src/model/line-tool-highlighter.ts b/src/model/line-tool-highlighter.ts
new file mode 100644
index 0000000..02135a8
--- /dev/null
+++ b/src/model/line-tool-highlighter.ts
@@ -0,0 +1,25 @@
+import { LineWidth } from '../renderers/draw-line';
+
+import { LineEnd, LineStyle } from '..';
+import { LineToolBrush } from './line-tool-brush';
+import { BrushToolOptions, LineCap, LineJoin, LineToolType } from './line-tool-options';
+
+export class LineToolHighlighter extends LineToolBrush {
+	protected override readonly _toolType: LineToolType = 'Highlighter';
+
+	public override getBrushOptions(): BrushToolOptions & { line: { cap: LineCap } } {
+		const options = this.options();
+		return {
+			visible: options.visible,
+			editable: options.editable,
+			line: {
+				width: 20 as LineWidth,
+				cap: LineCap.Round,
+				join: LineJoin.Round,
+				style: LineStyle.Solid,
+				color: options.line.color,
+				end: { left: LineEnd.Normal, right: LineEnd.Normal },
+			},
+		};
+	}
+}
diff --git a/src/model/line-tool-horizontal-line.ts b/src/model/line-tool-horizontal-line.ts
new file mode 100644
index 0000000..1b3df58
--- /dev/null
+++ b/src/model/line-tool-horizontal-line.ts
@@ -0,0 +1,31 @@
+import { HorizontalLinePaneView } from '../views/pane/horizontal-line-pane-view';
+import { ITimeAxisView } from '../views/time-axis/itime-axis-view';
+
+import { ChartModel } from './chart-model';
+import { LineTool, LineToolPoint } from './line-tool';
+import { HorizontalLineToolOptions, LineToolType } from './line-tool-options';
+
+export class LineToolHorizontalLine extends LineTool<'HorizontalLine'> {
+	protected override readonly _toolType: LineToolType = 'HorizontalLine';
+
+	public constructor(model: ChartModel, options: HorizontalLineToolOptions, points: LineToolPoint[] = []) {
+		super(model, options, points);
+		this._setPaneViews([new HorizontalLinePaneView(this, model)]);
+	}
+
+	public pointsCount(): number {
+		return 1;
+	}
+
+	public override timeAxisViews(): ITimeAxisView[] {
+		return [];
+	}
+
+	public override timeAxisPoints(): LineToolPoint[] {
+		return [];
+	}
+
+	public override priceAxisLabelColor(): string | null {
+		return this.options().line.color;
+	}
+}
diff --git a/src/model/line-tool-horizontal-ray.ts b/src/model/line-tool-horizontal-ray.ts
new file mode 100644
index 0000000..b774607
--- /dev/null
+++ b/src/model/line-tool-horizontal-ray.ts
@@ -0,0 +1,6 @@
+import { LineToolHorizontalLine } from './line-tool-horizontal-line';
+import { LineToolType } from './line-tool-options';
+
+export class LineToolHorizontalRay extends LineToolHorizontalLine {
+	protected override readonly _toolType: LineToolType = 'HorizontalRay';
+}
diff --git a/src/model/line-tool-options.ts b/src/model/line-tool-options.ts
new file mode 100644
index 0000000..43b941a
--- /dev/null
+++ b/src/model/line-tool-options.ts
@@ -0,0 +1,654 @@
+/* eslint-disable @typescript-eslint/naming-convention */
+import { DeepPartial, OmitRecursively } from '../helpers/strict-type-checks';
+
+import { LineEnd as LineEnd, LineStyle, LineWidth } from '../renderers/draw-line';
+
+export interface IPoint {
+	x: number;
+	y: number;
+}
+
+export const enum BoxVerticalAlignment {
+	Top = 'top',
+	Middle = 'middle',
+	Bottom = 'bottom',
+}
+
+export const enum BoxHorizontalAlignment {
+	Left = 'left',
+	Center = 'center',
+	Right = 'right',
+}
+
+export const enum TextAlignment {
+	Start = 'start',
+	Center = 'center',
+	End = 'end',
+	Left = 'left',
+	Right = 'right',
+}
+
+export const enum LineJoin {
+	Bevel = 'bevel',
+	Round = 'round',
+	Miter = 'miter',
+}
+
+export const enum LineCap {
+	Butt = 'butt',
+	Round = 'round',
+	Square = 'square',
+}
+
+export interface ExtendOptions {
+	/**
+	 * Extend line right.
+	 *
+	 * @defaultValue `false`
+	 */
+	right: boolean;
+
+	/**
+	 * Extend line left.
+	 *
+	 * @defaultValue `false`
+	 */
+	left: boolean;
+}
+
+export interface EndOptions {
+	/**
+	 * Line cap right.
+	 *
+	 * @defaultValue {@link LineEnd.Normal}
+	 */
+	left: LineEnd;
+
+	/**
+	 * Line cap left.
+	 *
+	 * @defaultValue {@link LineEnd.Normal}
+	 */
+	right: LineEnd;
+}
+
+export interface BoxAlignmentOptions {
+	/**
+	 * Text vertical alignment.
+	 *
+	 * @defaultValue {@link BoxVerticalAlignment.Top}
+	 */
+	vertical: BoxVerticalAlignment;
+
+	/**
+	 * Text horizontal alignment.
+	 *
+	 * @defaultValue {@link BoxHorizontalAlignment.Left}
+	 */
+	horizontal: BoxHorizontalAlignment;
+}
+
+export interface ShadowOptions {
+	blur: number;
+	color: string;
+	offset: IPoint;
+}
+
+export interface TextBoxOptions {
+	/**
+	 * Box alignment.
+	 */
+	alignment: BoxAlignmentOptions;
+
+	/**
+	 * Box angle.
+	*/
+	angle: number;
+
+	/**
+	 * Box scale.
+	 */
+	scale: number;
+
+	/**
+	 * Box offset.
+	 */
+	offset?: IPoint;
+
+	/**
+	 * Box padding.
+	 */
+	padding?: IPoint;
+
+	/**
+	 * Box max height.
+	 */
+	maxHeight?: number;
+
+	/**
+	 * Box shadow.
+	 */
+	shadow?: ShadowOptions;
+
+	/**
+	 * Box border.
+	 */
+	border?: BorderOptions;
+
+	/**
+	 * Box background.
+	 */
+	background?: BackroundOptions;
+}
+
+export interface TextFontOptions {
+	/**
+	 * Font color.
+	 *
+	 * @defaultValue `'#B2B5BE'`
+	 */
+	color: string;
+
+	/**
+	 * Font size.
+	 *
+	 * @defaultValue `12`
+	 */
+	size: number;
+
+	/**
+	 * If font should be bold.
+	 *
+	 * @defaultValue `false`
+	 */
+	bold: boolean;
+
+	/**
+	 * If font should be italic.
+	 *
+	 * @defaultValue `false`
+	 */
+	italic: boolean;
+
+	/**
+	 * Font family.
+	 *
+	 * @defaultValue `-apple-system, BlinkMacSystemFont, 'Trebuchet MS', Roboto, SegoeUI, Ubuntu, sans-serif`
+	 */
+	family: string;
+}
+
+export interface BackroundOptions {
+	/**
+	 * Background color.
+	 */
+	color: string;
+
+	/**
+	 * Background inflate.
+	 */
+	inflation: IPoint;
+}
+
+export interface BorderOptions {
+	/**
+	 * Border color.
+	 */
+	color: string;
+
+	/**
+	 * Border width.
+	 */
+	width: number;
+
+	/**
+	 * Border radius.
+	 */
+	radius: number;
+
+	/**
+	 * If border should be highlighted.
+	 */
+	highlight: boolean;
+
+	/**
+	 * Border style.
+	 *
+	 * @defaultValue {@link LineStyle.Solid}
+	 */
+	style: LineStyle;
+}
+
+export interface TextOptions {
+	/**
+	 * Text value.
+	 *
+	 * @defaultValue `""`
+	 */
+	value: string;
+
+	/**
+	 * Text alignment.
+	 *
+	 * @defaultValue {@link BoxHorizontalAlignment.Left}
+	 */
+	alignment: TextAlignment;
+
+	/**
+	 * Text font.
+	 */
+	font: TextFontOptions;
+
+	/**
+	 * Text box.
+	 */
+	box: TextBoxOptions;
+
+	/**
+	 * Text padding.
+	 */
+	padding: number;
+
+	/**
+	 * Text word wrap width.
+	 */
+	wordWrapWidth: number;
+
+	/**
+	 * Should force text align.
+	 */
+	forceTextAlign: boolean;
+
+	/**
+	 * Should force calcualte max line width.
+	 */
+	forceCalculateMaxLineWidth: boolean;
+}
+
+export interface RectangleOptions {
+	/**
+	 * Rectangle background.
+	 */
+	background: Omit<BackroundOptions, 'inflation'>;
+
+	/**
+	 * Rectangle border.
+	*/
+	border: Omit<BorderOptions, 'radius' | 'highlight'>;
+
+	/**
+	 * Rectangle extend sides.
+	 */
+	extend: ExtendOptions;
+}
+
+export interface TriangleOptions {
+	/**
+	 * Triangle background.
+	 */
+	background: Omit<BackroundOptions, 'inflation'>;
+
+	/**
+	 * Triangle border.
+	*/
+	border: Omit<BorderOptions, 'radius' | 'highlight'>;
+}
+
+export interface LineOptions {
+	/**
+	 * Line color.
+	 *
+	 * @defaultValue `'#B2B5BE'`
+	 */
+	color: string;
+
+	/**
+	 * Line width.
+	 *
+	 * @defaultValue `1`
+	 */
+	width: LineWidth;
+
+	/**
+	 * Line style.
+	 *
+	 * @defaultValue {@link LineStyle.Solid}
+	 */
+	style: LineStyle;
+
+	/**
+	 * Line join.
+	 *
+	 * @defaultValue {@link LineJoin.Miter}
+	 */
+	join: LineJoin;
+
+	/**
+	 * Line join.
+	 *
+	 * @defaultValue {@link LineCap.Round}
+	 */
+	cap: LineCap;
+
+	/**
+	 * Line ends.
+	 */
+	end: EndOptions;
+
+	/**
+	 * Line extend.
+	 */
+	extend: ExtendOptions;
+}
+
+/**
+ * Represents fib retracement level.
+ */
+export interface FibRetracementLevel {
+	/**
+	 * Level coefficient.
+	 */
+	coeff: number;
+
+	/**
+	 * Level color.
+	 */
+	color: string;
+
+    /**
+     * Opacity of the background.
+     */
+	opacity: number;
+}
+
+export interface LineToolOptionsCommon {
+	/**
+	 * Visibility of the line.
+	 *
+	 * @defaultValue `true`
+	 */
+	visible: boolean;
+
+	/**
+	 * Can the line be edited.
+	 *
+	 * @defaultValue `true`
+	 */
+	editable: boolean;
+
+	/**
+	 * The owner source id.
+	 */
+	ownerSourceId?: string;
+}
+
+/**
+ * Represents style options for a trend line.
+ */
+export interface LineToolTrendLineOptions {
+	/**
+	 * Text config.
+	 */
+	text: TextOptions;
+	/**
+	 * Line config.
+	 */
+	line: Omit<LineOptions, 'join' | 'cap'>;
+}
+
+/**
+ * Represents style options for a horizotnal line.
+ */
+export interface LineToolHorizontalLineOptions {
+	/**
+	 * Text config.
+	 */
+	text: TextOptions;
+	/**
+	 * Line config.
+	 */
+	line: Omit<LineOptions, 'cap' | 'join'>;
+}
+
+/**
+ * Represents style options for a vertical line.
+ */
+export interface LineToolVerticalLineOptions {
+	/**
+	 * Text config.
+	 */
+	text: TextOptions;
+	/**
+	 * Line config.
+	 */
+	line: Omit<LineOptions, 'cap' | 'extend' | 'join' | 'end'>;
+}
+
+/**
+ * Represents style options for a cross line.
+ */
+export interface LineToolCrossLineOptions {
+	/**
+	 * Line config.
+	 */
+	line: Omit<LineOptions, 'cap' | 'extend' | 'join' | 'end'>;
+}
+
+/**
+ * Represents style options for a parallel channel.
+ */
+export interface LineToolParallelChannelOptions {
+	/**
+	 * Channel line config.
+	 */
+	channelLine: Omit<LineOptions, 'cap' | 'extend' | 'join' | 'end'>;
+
+	/**
+	 * Middle line config.
+	 */
+	middleLine: Omit<LineOptions, 'cap' | 'extend' | 'join' | 'end'>;
+
+	/**
+	 * If the middle line should be visible.
+	 */
+	showMiddleLine: boolean;
+
+	/**
+	 * Channel extension
+	 */
+	extend: ExtendOptions;
+
+	/**
+	 * Channel background
+	 */
+	background?: Omit<BackroundOptions, 'inflation'>;
+}
+
+/**
+ * Represents style options for a rectangle.
+ */
+export interface LineToolRectangleOptions {
+	/**
+	 * Text config.
+	 */
+	text: TextOptions;
+	/**
+	 * Rectangle config.
+	 */
+	rectangle: RectangleOptions;
+}
+
+/**
+ * Represents style options for a triangle.
+ */
+export interface LineToolTriangleOptions {
+	/**
+	 * Triangle config.
+	 */
+	triangle: TriangleOptions;
+}
+
+/**
+ * Represents style options for a text.
+ */
+export interface LineToolTextOptions {
+	/**
+	 * Text config.
+	 */
+	text: OmitRecursively<TextOptions, 'alignment'>;
+}
+
+/**
+ * Represents style options for a brush.
+ */
+export interface LineToolBrushOptions {
+	/**
+	 * Line config.
+	 */
+	line: Omit<LineOptions, 'cap' | 'extend'>;
+
+	/**
+	 * Brush background.
+	 */
+	background?: Omit<BackroundOptions, 'inflation'>;
+}
+
+/**
+ * Represents style options for a highlighter.
+ */
+export interface LineToolHighlighterOptions {
+	/**
+	 * Line config.
+	 */
+	line: Pick<LineOptions, 'color'>;
+}
+
+/**
+ * Represents style options for a path.
+ */
+export interface LineToolPathOptions {
+	/**
+	 * Line config.
+	 */
+	line: Omit<LineOptions, 'cap' | 'extend' | 'join'>;
+}
+
+/**
+ * Represents style options for a fib retracement.
+ */
+export interface LineToolFibRetracementOptions {
+	/**
+	 * Line config.
+	 */
+	line: Omit<LineOptions, 'extend' | 'join' | 'color' | 'cap' | 'end'>;
+
+	/**
+	 * Lines extend.
+	 */
+	extend: ExtendOptions;
+
+	/**
+	 * Fib Levels.
+	 */
+	levels: FibRetracementLevel[];
+}
+
+/**
+ * Represents the intersection of a series type `T`'s options and common line tool options.
+ *
+ * @see {@link LineToolOptionsCommon} for common options.
+ */
+export type LineToolOptions<T> = T & LineToolOptionsCommon;
+/**
+ * Represents a {@link LineToolOptions} where every property is optional.
+ */
+export type LineToolPartialOptions<T> = DeepPartial<T & LineToolOptionsCommon>;
+
+export type PathToolOptions = LineToolOptions<LineToolPathOptions>;
+export type PathToolPartialOptions = LineToolPartialOptions<LineToolPathOptions>;
+
+export type BrushToolOptions = LineToolOptions<LineToolBrushOptions>;
+export type BrushToolPartialOptions = LineToolPartialOptions<LineToolBrushOptions>;
+
+export type HighlighterToolOptions = LineToolOptions<LineToolHighlighterOptions>;
+export type HighlighterToolPartialOptions = LineToolPartialOptions<LineToolHighlighterOptions>;
+
+export type TextToolOptions = LineToolOptions<LineToolTextOptions>;
+export type TextToolPartialOptions = LineToolPartialOptions<LineToolTextOptions>;
+
+export type TrendLineToolOptions = LineToolOptions<LineToolTrendLineOptions>;
+export type TrendLineToolPartialOptions = LineToolPartialOptions<LineToolTrendLineOptions>;
+
+export type CrossLineToolOptions = LineToolOptions<LineToolCrossLineOptions>;
+export type CrossLineToolPartialOptions = LineToolPartialOptions<LineToolCrossLineOptions>;
+
+export type VerticalLineToolOptions = LineToolOptions<LineToolVerticalLineOptions>;
+export type VerticalLineToolPartialOptions = LineToolPartialOptions<LineToolVerticalLineOptions>;
+
+export type HorizontalLineToolOptions = LineToolOptions<LineToolHorizontalLineOptions>;
+export type HorizontalLineToolPartialOptions = LineToolPartialOptions<LineToolHorizontalLineOptions>;
+
+export type RectangleToolOptions = LineToolOptions<LineToolRectangleOptions>;
+export type RectangleToolPartialOptions = LineToolPartialOptions<LineToolRectangleOptions>;
+
+export type TriangleToolOptions = LineToolOptions<LineToolTriangleOptions>;
+export type TriangleToolPartialOptions = LineToolPartialOptions<LineToolTriangleOptions>;
+
+export type ParallelChannelToolOptions = LineToolOptions<LineToolParallelChannelOptions>;
+export type ParallelChannelToolPartialOptions = LineToolPartialOptions<LineToolParallelChannelOptions>;
+
+export type FibRetracementToolOptions = LineToolOptions<LineToolFibRetracementOptions>;
+export type FibRetracementToolPartialOptions = LineToolPartialOptions<LineToolFibRetracementOptions>;
+
+/**
+ * Represents the type of options for each line tool type.
+ */
+export interface LineToolOptionsMap {
+	FibRetracement: FibRetracementToolOptions;
+	ParallelChannel: ParallelChannelToolOptions;
+	HorizontalLine: HorizontalLineToolOptions;
+	VerticalLine: VerticalLineToolOptions;
+	Highlighter: HighlighterToolOptions;
+	CrossLine: CrossLineToolOptions;
+	TrendLine: TrendLineToolOptions;
+	Rectangle: RectangleToolOptions;
+	Triangle: TriangleToolOptions;
+	Brush: BrushToolOptions;
+	Path: PathToolOptions;
+	Text: TextToolOptions;
+
+	Ray: TrendLineToolOptions;
+	Arrow: TrendLineToolOptions;
+	ExtendedLine: TrendLineToolOptions;
+	HorizontalRay: HorizontalLineToolOptions;
+}
+
+/**
+ * Represents the type of partial options for each line tool type.
+ */
+export interface LineToolPartialOptionsMap {
+	FibRetracement: FibRetracementToolPartialOptions;
+	ParallelChannel: ParallelChannelToolPartialOptions;
+	HorizontalLine: HorizontalLineToolPartialOptions;
+	VerticalLine: VerticalLineToolPartialOptions;
+	Highlighter: HighlighterToolPartialOptions;
+	CrossLine: CrossLineToolPartialOptions;
+	TrendLine: TrendLineToolPartialOptions;
+	Rectangle: RectangleToolPartialOptions;
+	Triangle: TriangleToolPartialOptions;
+	Brush: BrushToolPartialOptions;
+	Path: PathToolPartialOptions;
+	Text: TextToolPartialOptions;
+
+	Ray: TrendLineToolPartialOptions;
+	Arrow: TrendLineToolPartialOptions;
+	ExtendedLine: TrendLineToolPartialOptions;
+	HorizontalRay: HorizontalLineToolPartialOptions;
+}
+
+/**
+ * Represents a type of line tool.
+ *
+ * @see {@link LineToolOptionsMap}
+ */
+export type LineToolType = keyof LineToolOptionsMap;
diff --git a/src/model/line-tool-parallel-channel.ts b/src/model/line-tool-parallel-channel.ts
new file mode 100644
index 0000000..607972e
--- /dev/null
+++ b/src/model/line-tool-parallel-channel.ts
@@ -0,0 +1,147 @@
+import { ensure, ensureNotNull } from '../helpers/assertions';
+
+import { ParallelChannelPaneView } from '../views/pane/parallel-channel-pane-view';
+import { LineToolPriceAxisLabelView } from '../views/price-axis/line-tool-price-axis-label-view';
+
+import { ChartModel } from './chart-model';
+import { Coordinate } from './coordinate';
+import { LineTool, LineToolPoint } from './line-tool';
+import { LineToolType, ParallelChannelToolOptions } from './line-tool-options';
+import { Point } from './point';
+
+export class LineToolParallelChannel extends LineTool<'ParallelChannel'> {
+	protected override readonly _toolType: LineToolType = 'ParallelChannel';
+
+	public constructor(model: ChartModel, options: ParallelChannelToolOptions, points: LineToolPoint[] = []) {
+		super(model, options, points);
+		this._priceAxisViews.push(new LineToolPriceAxisLabelView(this, 3));
+		this._setPaneViews([new ParallelChannelPaneView(this, model)]);
+	}
+
+	public pointsCount(): number {
+		return 3;
+	}
+
+	public override addPoint(point: LineToolPoint): void {
+		if (this._points.length === 2) {
+			super.addPoint(this._correctLastPoint(point));
+		} else {
+			super.addPoint(point);
+		}
+	}
+
+	public override points(): LineToolPoint[] {
+		const points = super.points();
+		if (points.length === 3 && !this.finished()) {
+			return [points[0], points[1], this._correctLastPoint(points[2])];
+		} else {
+			return points;
+		}
+	}
+
+	public override setPoint(index: number, point: LineToolPoint): void {
+		if (this._points[0].timestamp === this._points[1].timestamp && index >= 4) { return; }
+		const screenPoint0 = ensureNotNull(this.pointToScreenPoint(this._points[0]));
+		const screenPoint1 = ensureNotNull(this.pointToScreenPoint(this._points[1]));
+		const screenPoint = ensureNotNull(this.pointToScreenPoint(point));
+		const movingCoordOffset = this._findPixelsHeight() || 0;
+		const priceScale = ensureNotNull(this.priceScale());
+		const ownerSource = this.ownerSource();
+
+		const firstValue = ensure(ownerSource === null ? undefined : ownerSource.firstValue());
+		if (index === 0) {
+			super.setPoint(index, point);
+			this._points[2].price = priceScale.coordinateToPrice(screenPoint.y + movingCoordOffset as Coordinate, firstValue.value);
+		} else if (index === 1) {
+			super.setPoint(index, point);
+		} else if (index === 2) {
+			super.setPoint(index, point);
+			this._points[0].timestamp = point.timestamp;
+			this._points[0].price = priceScale.coordinateToPrice(screenPoint.y - movingCoordOffset as Coordinate, firstValue.value);
+		} else if (index === 3) {
+			this._points[1].timestamp = point.timestamp;
+			this._points[1].price = priceScale.coordinateToPrice(screenPoint.y - movingCoordOffset as Coordinate, firstValue.value);
+		} else if (index === 4) {
+			const heading = screenPoint1.subtract(screenPoint0);
+			const scale = (screenPoint.x - screenPoint0.x) / heading.x;
+			const displace = screenPoint.y - screenPoint0.addScaled(heading, scale).y;
+			this._points[2].price = priceScale.coordinateToPrice(screenPoint0.y + displace as Coordinate, firstValue.value);
+		} else if (index === 5) {
+			const heading = screenPoint1.subtract(screenPoint0);
+			const scale = (screenPoint.x - screenPoint0.x) / heading.x;
+			const displace = screenPoint.y - screenPoint0.addScaled(heading, scale).y;
+			this._points[0].price = priceScale.coordinateToPrice(screenPoint0.y + displace as Coordinate, firstValue.value);
+			this._points[1].price = priceScale.coordinateToPrice(screenPoint1.y + displace as Coordinate, firstValue.value);
+		}
+	}
+
+	public override getPoint(index: number): LineToolPoint | null {
+		if (index < 3) { return super.getPoint(index); }
+
+		const end0 = this.pointToScreenPoint(this._points[0]);
+		const end1 = this.pointToScreenPoint(this._points[1]);
+		const end2 = this.pointToScreenPoint(this._points[2]);
+		if (!end0 || !end1 || !end2) { return null; }
+
+		switch (index) {
+			case 3: {
+				const height = end2.y - end0.y;
+				const end3 = end1.add(new Point(0, height));
+				return this.screenPointToPoint(end3);
+			}
+			case 4: {
+				const height = end2.y - end0.y;
+				const end3 = end1.add(new Point(0, height));
+				const middle0 = end2.add(end3).scaled(0.5);
+				return this.screenPointToPoint(middle0);
+			}
+			case 5: {
+				const middle1 = end0.add(end1).scaled(0.5);
+				return this.screenPointToPoint(middle1);
+			}
+		}
+		return null;
+	}
+
+	public override priceAxisPoints(): LineToolPoint[] {
+		return this._axisPoints();
+	}
+
+	public override timeAxisPoints(): LineToolPoint[] {
+		return this._axisPoints().slice(0, 2);
+	}
+
+	protected _findPixelsHeight(): number | null {
+		const end2 = this.pointToScreenPoint(this._points[2]);
+		const end0 = this.pointToScreenPoint(this._points[0]);
+		return end2 && end0 ? end2.y - end0.y : null;
+	}
+
+	protected _axisPoints(): LineToolPoint[] {
+		const points = this.points();
+		const screenPoint0 = this._points[0] ? this.pointToScreenPoint(this._points[0]) : null;
+		const screenPoint1 = this._points[1] ? this.pointToScreenPoint(this._points[1]) : null;
+		const screenPoint2 = this._points[2] ? this.pointToScreenPoint(this._points[2]) : null;
+
+		if (screenPoint0 && screenPoint1 && screenPoint2) {
+			const height = screenPoint1.y - screenPoint0.y;
+			const screenPoint3 = screenPoint2.add(new Point(0, height));
+			points.push(ensureNotNull(this.screenPointToPoint(screenPoint3)));
+		}
+
+		return points;
+	}
+
+	protected _correctLastPoint(point2: LineToolPoint): LineToolPoint {
+		if (this._points.length < 2 || this._points[1].timestamp === this._points[0].timestamp) { return point2; }
+		const screenPoint2 = ensureNotNull(this.pointToScreenPoint(point2));
+		const screenPoint1 = ensureNotNull(this.pointToScreenPoint(this._points[1]));
+		const screenPoint0 = ensureNotNull(this.pointToScreenPoint(this._points[0]));
+		const heading = screenPoint1.subtract(screenPoint0);
+		const scale = (screenPoint2.x - screenPoint0.x) / heading.x;
+		const height = screenPoint0.addScaled(heading, scale);
+		const displaceY = screenPoint2.y - height.y;
+		const correctedPoint = screenPoint0.add(new Point(0, displaceY));
+		return ensureNotNull(this.screenPointToPoint(correctedPoint));
+	}
+}
diff --git a/src/model/line-tool-path.ts b/src/model/line-tool-path.ts
new file mode 100644
index 0000000..e59afc5
--- /dev/null
+++ b/src/model/line-tool-path.ts
@@ -0,0 +1,35 @@
+import { ensureNotNull } from '../helpers/assertions';
+
+import { PathPaneView } from '../views/pane/path-pane-view';
+
+import { ChartModel } from './chart-model';
+import { LineTool, LineToolPoint } from './line-tool';
+import { BrushToolOptions, LineToolType } from './line-tool-options';
+
+export class LineToolPath extends LineTool<'Path'> {
+	protected override readonly _toolType: LineToolType = 'Path';
+
+	public constructor(model: ChartModel, options: BrushToolOptions, points: LineToolPoint[] = []) {
+		super(model, options, points);
+		this._setPaneViews([new PathPaneView(this, model)]);
+	}
+
+	public pointsCount(): number {
+		return -1;
+	}
+
+	public override tryFinish(): void {
+		if (this._points.length > 1) {
+			const point0 = this._points[this._points.length - 1];
+			const point1 = this._points[this._points.length - 2];
+			const screenPoint0 = ensureNotNull(this.pointToScreenPoint(point0));
+			const screenPoint1 = ensureNotNull(this.pointToScreenPoint(point1));
+			if (screenPoint0.subtract(screenPoint1).length() < 10) {
+				this._points.pop();
+				this._finished = true;
+				this._selected = true;
+				this._lastPoint = null;
+			}
+		}
+	}
+}
diff --git a/src/model/line-tool-ray.ts b/src/model/line-tool-ray.ts
new file mode 100644
index 0000000..d0b57f1
--- /dev/null
+++ b/src/model/line-tool-ray.ts
@@ -0,0 +1,6 @@
+import { LineToolType } from './line-tool-options';
+import { LineToolTrendLine } from './line-tool-trend-line';
+
+export class LineToolRay extends LineToolTrendLine {
+	protected override readonly _toolType: LineToolType = 'Ray';
+}
diff --git a/src/model/line-tool-rectangle.ts b/src/model/line-tool-rectangle.ts
new file mode 100644
index 0000000..0085587
--- /dev/null
+++ b/src/model/line-tool-rectangle.ts
@@ -0,0 +1,65 @@
+import { RectanglePaneView } from '../views/pane/rectangle-pane-view';
+
+import { ChartModel } from './chart-model';
+import { LineTool, LineToolPoint } from './line-tool';
+import { LineToolType, RectangleToolOptions } from './line-tool-options';
+import { UTCTimestamp } from './time-data';
+
+export class LineToolRectangle extends LineTool<'Rectangle'> {
+	protected override readonly _toolType: LineToolType = 'Rectangle';
+
+	public constructor(model: ChartModel, options: RectangleToolOptions, points: LineToolPoint[] = []) {
+		super(model, options, points);
+		this._setPaneViews([new RectanglePaneView(this, model)]);
+	}
+
+	public pointsCount(): number {
+		return 2;
+	}
+
+	public override setPoint(index: number, point: LineToolPoint): void {
+		if (index < 2) { super.setPoint(index, point); }
+
+		switch (index) {
+			case 2:
+				this._points[1].price = point.price;
+				this._points[0].timestamp = point.timestamp;
+				break;
+			case 3:
+				this._points[0].price = point.price;
+				this._points[1].timestamp = point.timestamp;
+				break;
+			case 4:
+				this._points[0].timestamp = point.timestamp;
+				break;
+			case 5:
+				this._points[1].timestamp = point.timestamp;
+				break;
+			case 6:
+				this._points[0].price = point.price;
+				break;
+			case 7:
+				this._points[1].price = point.price;
+		}
+	}
+
+	public override getPoint(index: number): LineToolPoint | null {
+		return index < 2 ? super.getPoint(index) : this._getAnchorPointForIndex(index);
+	}
+
+	protected _getAnchorPointForIndex(index: number): LineToolPoint {
+		const start = this.points()[0];
+		const end = this.points()[1];
+
+		return [
+			{ price: start.price, timestamp: start.timestamp },
+			{ price: end.price, timestamp: end.timestamp },
+			{ price: end.price, timestamp: start.timestamp },
+			{ price: start.price, timestamp: end.timestamp },
+			{ price: (end.price + start.price) / 2, timestamp: start.timestamp },
+			{ price: (end.price + start.price) / 2, timestamp: end.timestamp },
+			{ price: start.price, timestamp: (end.timestamp + start.timestamp) / 2 as UTCTimestamp },
+			{ price: end.price, timestamp: (end.timestamp + start.timestamp) / 2 as UTCTimestamp },
+		][index];
+	}
+}
diff --git a/src/model/line-tool-text.ts b/src/model/line-tool-text.ts
new file mode 100644
index 0000000..ceb0cb8
--- /dev/null
+++ b/src/model/line-tool-text.ts
@@ -0,0 +1,18 @@
+import { TextPaneView } from '../views/pane/text-pane-view';
+
+import { ChartModel } from './chart-model';
+import { LineTool, LineToolPoint } from './line-tool';
+import { LineToolType, TextToolOptions } from './line-tool-options';
+
+export class LineToolText extends LineTool<'Text'> {
+	protected override readonly _toolType: LineToolType = 'Text';
+
+	public constructor(model: ChartModel, options: TextToolOptions, points: LineToolPoint[] = []) {
+		super(model, options, points);
+		this._setPaneViews([new TextPaneView(this, model)]);
+	}
+
+	public pointsCount(): number {
+		return 1;
+	}
+}
diff --git a/src/model/line-tool-trend-line.ts b/src/model/line-tool-trend-line.ts
new file mode 100644
index 0000000..4663961
--- /dev/null
+++ b/src/model/line-tool-trend-line.ts
@@ -0,0 +1,18 @@
+import { TrendLinePaneView } from '../views/pane/trend-line-pane-view';
+
+import { ChartModel } from './chart-model';
+import { LineTool, LineToolPoint } from './line-tool';
+import { LineToolType, TrendLineToolOptions } from './line-tool-options';
+
+export class LineToolTrendLine extends LineTool<'TrendLine'> {
+	protected override readonly _toolType: LineToolType = 'TrendLine';
+
+	public constructor(model: ChartModel, options: TrendLineToolOptions, points: LineToolPoint[] = []) {
+		super(model, options, points);
+		this._setPaneViews([new TrendLinePaneView(this, model)]);
+	}
+
+	public pointsCount(): number {
+		return 2;
+	}
+}
diff --git a/src/model/line-tool-triangle.ts b/src/model/line-tool-triangle.ts
new file mode 100644
index 0000000..f63cbb8
--- /dev/null
+++ b/src/model/line-tool-triangle.ts
@@ -0,0 +1,18 @@
+import { TrianglePaneView } from '../views/pane/triangle-pane-view';
+
+import { ChartModel } from './chart-model';
+import { LineTool, LineToolPoint } from './line-tool';
+import { LineToolType, TriangleToolOptions } from './line-tool-options';
+
+export class LineToolTriangle extends LineTool<'Triangle'> {
+	protected override readonly _toolType: LineToolType = 'Triangle';
+
+	public constructor(model: ChartModel, options: TriangleToolOptions, points: LineToolPoint[] = []) {
+		super(model, options, points);
+		this._setPaneViews([new TrianglePaneView(this, model)]);
+	}
+
+	public pointsCount(): number {
+		return 3;
+	}
+}
diff --git a/src/model/line-tool-vertical-line.ts b/src/model/line-tool-vertical-line.ts
new file mode 100644
index 0000000..5a8c646
--- /dev/null
+++ b/src/model/line-tool-vertical-line.ts
@@ -0,0 +1,31 @@
+import { VerticalLinePaneView } from '../views/pane/vertical-line-pane-view';
+import { PriceAxisView } from '../views/price-axis/price-axis-view';
+
+import { ChartModel } from './chart-model';
+import { LineTool, LineToolPoint } from './line-tool';
+import { LineToolType, VerticalLineToolOptions } from './line-tool-options';
+
+export class LineToolVerticalLine extends LineTool<'VerticalLine'> {
+	protected override readonly _toolType: LineToolType = 'VerticalLine';
+
+	public constructor(model: ChartModel, options: VerticalLineToolOptions, points: LineToolPoint[] = []) {
+		super(model, options, points);
+		this._setPaneViews([new VerticalLinePaneView(this, model)]);
+	}
+
+	public pointsCount(): number {
+		return 1;
+	}
+
+	public override priceAxisViews(): PriceAxisView[] {
+		return [];
+	}
+
+	public override priceAxisPoints(): LineToolPoint[] {
+		return [];
+	}
+
+	public override timeAxisLabelColor(): string | null {
+		return this.options().line.color;
+	}
+}
diff --git a/src/model/line-tool.ts b/src/model/line-tool.ts
new file mode 100644
index 0000000..a418120
--- /dev/null
+++ b/src/model/line-tool.ts
@@ -0,0 +1,343 @@
+import { IPriceFormatter } from '../formatters/iprice-formatter';
+
+import { Delegate } from '../helpers/delegate';
+import { IDestroyable } from '../helpers/idestroyable';
+import { DeepPartial, merge } from '../helpers/strict-type-checks';
+
+import { IPaneView } from '../views/pane/ipane-view';
+import { IUpdatablePaneView } from '../views/pane/iupdatable-pane-view';
+import { LineToolPriceAxisBackgroundView } from '../views/price-axis/line-tool-price-axis-background-view';
+import { LineToolPriceAxisLabelView } from '../views/price-axis/line-tool-price-axis-label-view';
+import { PriceAxisView } from '../views/price-axis/price-axis-view';
+import { ITimeAxisView } from '../views/time-axis/itime-axis-view';
+import { LineToolTimeAxisBackgroundView } from '../views/time-axis/line-tool-time-axis-background-view';
+import { LineToolTimeAxisLabelView } from '../views/time-axis/line-tool-time-axis-label-view';
+
+import { AutoscaleInfoImpl } from './autoscale-info-impl';
+import { ChartModel } from './chart-model';
+import { FirstValue, IPriceDataSource } from './iprice-data-source';
+import { LineToolOptionsCommon, LineToolOptionsMap, LineToolPartialOptionsMap, LineToolType } from './line-tool-options';
+import { Pane, PaneCursorType } from './pane';
+import { Point } from './point';
+import { PriceDataSource } from './price-data-source';
+import { PriceScale } from './price-scale';
+import { TimePointIndex, UTCTimestamp } from './time-data';
+import { TimeScale } from './time-scale';
+
+export interface LineToolPoint {
+	price: number;
+	timestamp: number;
+}
+
+export interface State<T extends LineToolType = LineToolType> {
+	id: string;
+	type: LineToolType;
+	options: LineToolOptionsInternal<T>;
+}
+
+export interface LineToolHitTestData {
+	pointIndex: number;
+	cursorType: PaneCursorType;
+}
+
+export interface LineToolExport<T extends LineToolType> {
+	id: string;
+	toolType: LineToolType;
+	options: LineToolOptionsInternal<T>;
+	points: LineToolPoint[];
+}
+
+export type LineToolOptionsInternal<T extends LineToolType> = LineToolOptionsMap[T];
+export type LineToolPartialOptionsInternal<T extends LineToolType> = LineToolPartialOptionsMap[T];
+
+// export abstract class LineTool<T extends LineToolType = LineToolType> extends DataSource implements IDestroyable {
+export abstract class LineTool<T extends LineToolType = LineToolType> extends PriceDataSource implements IDestroyable {
+	protected _pointChanged: Delegate = new Delegate();
+	protected _pointAdded: Delegate = new Delegate();
+	protected _priceAxisViews: PriceAxisView[] = [];
+	protected _timeAxisViews: ITimeAxisView[] = [];
+	protected _paneViews: IUpdatablePaneView[] = [];
+
+	protected readonly _options: LineToolOptionsInternal<T>;
+	protected readonly _toolType!: LineToolType;
+
+	protected _hovered: boolean = false;
+	protected _selected: boolean = false;
+	protected _finished: boolean = false;
+	protected _editing: boolean = false;
+	protected _creating: boolean = false;
+
+	protected _ownerSource: IPriceDataSource | null = null;
+	protected _lastPoint: LineToolPoint | null = null;
+	protected _points: LineToolPoint[] = [];
+	// protected _model: ChartModel;
+
+	private _formatter!: IPriceFormatter;
+
+	public constructor(model: ChartModel, options: LineToolOptionsInternal<T>, points: LineToolPoint[] = []) {
+		super(model);
+		// this._model = model;
+		this._points = points;
+		this._options = options;
+
+		for (let i = 0; i < this.pointsCount(); i++) {
+			this._priceAxisViews.push(new LineToolPriceAxisLabelView(this, i));
+			this._timeAxisViews.push(new LineToolTimeAxisLabelView(model, this, i));
+		}
+
+		if (this.pointsCount() > 1) {
+			this._priceAxisViews.push(new LineToolPriceAxisBackgroundView(this));
+			this._timeAxisViews.push(new LineToolTimeAxisBackgroundView(this));
+		}
+
+		// TODO: iosif change to use the ownerSourceId
+		// this._ownerSource = model.serieses().find((series: IPriceDataSource) => series.id() === this._options.ownerSourceId) || null;
+		this._ownerSource = model.serieses()[0];
+		this._finished = this._points.length >= (this.pointsCount() === -1 ? 2 : this.pointsCount());
+		// if no point is provided, we consider that linetool is being created and the call to tryFinish will set it to false afterwards.
+		// if points are provided, just get the inverse of _finished value.
+		this._creating = this._points.length === 0 ? true : !this.finished();
+	}
+
+	public abstract pointsCount(): number;
+
+	public finished(): boolean {
+		return this._finished;
+	}
+
+	public tryFinish(): void {
+		if (this._points.length >= Math.max(1, this.pointsCount())) {
+			this._finished = true;
+			this._selected = true;
+			this._creating = false;
+			this._lastPoint = null;
+			this.model().updateSource(this);
+		}
+	}
+
+	public points(): LineToolPoint[] {
+		const points = [...this._points, ...(this._lastPoint ? [this._lastPoint] : [])];
+		return this.pointsCount() === -1 ? points : points.slice(0, this.pointsCount());
+	}
+
+	public addPoint(point: LineToolPoint): void {
+		this._points.push(point);
+	}
+
+	public getPoint(index: number): LineToolPoint | null {
+		return this.points()[index] || null;
+	}
+
+	public setPoint(index: number, point: LineToolPoint): void {
+		this._points[index].price = point.price;
+		this._points[index].timestamp = point.timestamp;
+	}
+
+	public setPoints(points: LineToolPoint[]): void {
+		this._points = points;
+	}
+
+	public setLastPoint(point: LineToolPoint | null): void {
+		this._lastPoint = point;
+	}
+
+	public pointToScreenPoint(linePoint: LineToolPoint): Point | null {
+		const baseValue = this.ownerSource()?.firstValue()?.value || 0;
+		const priceScale = this.priceScale();
+		const timeScale = this.timeScale();
+
+		if (!priceScale || priceScale.isEmpty() || timeScale.isEmpty()) {
+			return null;
+		}
+
+		const x = timeScale.timeToCoordinate({ timestamp: linePoint.timestamp as UTCTimestamp });
+		const y = priceScale.priceToCoordinate(linePoint.price, baseValue);
+
+		return new Point(x, y);
+	}
+
+	public screenPointToPoint(point: Point): LineToolPoint | null {
+		const baseValue = this.ownerSource()?.firstValue()?.value || 0;
+		const priceScale = this.priceScale();
+		const timeScale = this.timeScale();
+
+		if (!priceScale) {
+			return null;
+		}
+
+		const price = priceScale.coordinateToPrice(point.y, baseValue);
+		const timestamp = timeScale.coordinateToTime(point.x).timestamp;
+
+		return { price, timestamp };
+	}
+
+	public state(): State<T> {
+		return { id: this.id(), type: this._toolType, options: this._options };
+	}
+
+	public override priceScale(): PriceScale | null {
+		// TODO: iosif update to use the onwer source price scale
+		return this.model().panes()[0].rightPriceScale();
+		// return this._ownerSource ? this._ownerSource.priceScale() : null;
+	}
+
+	public timeScale(): TimeScale {
+		return this.model().timeScale();
+	}
+
+	public ownerSource(): IPriceDataSource | null {
+		return this._ownerSource;
+	}
+
+	public options(): LineToolOptionsInternal<T> {
+		return this._options;
+	}
+
+	public override visible(): boolean {
+		return this._options.visible;
+	}
+
+	public applyOptions(options: LineToolPartialOptionsInternal<T> | DeepPartial<LineToolOptionsCommon>): void {
+		merge(this._options, options);
+		this.model().updateSource(this);
+
+		this._paneViews.forEach((paneView: IUpdatablePaneView) => {
+			paneView.update('options');
+		});
+	}
+
+	public paneViews(pane?: Pane): readonly IPaneView[] {
+		return this._paneViews;
+	}
+
+	public updateAllViews(): void {
+		if (!this.options().visible) { return; }
+		this._updateAllPaneViews();
+
+		for (let i = 0; i < this._priceAxisViews.length; i++) {
+			this._priceAxisViews[i].update();
+		}
+
+		for (let i = 0; i < this._timeAxisViews.length; i++) {
+			this._timeAxisViews[i].update();
+		}
+	}
+
+	public hovered(): boolean {
+		return this._hovered;
+	}
+
+	public setHovered(hovered: boolean): boolean {
+		const changed = hovered !== this._hovered;
+		this._hovered = hovered;
+		return changed;
+	}
+
+	public selected(): boolean {
+		return this._selected;
+	}
+
+	public setSelected(selected: boolean): boolean {
+		const changed = selected !== this._selected;
+		this._selected = selected;
+
+		if (changed) { this.updateAllViews(); }
+		return changed;
+	}
+
+	public editing(): boolean {
+		return this._editing;
+	}
+
+	public setEditing(editing: boolean): boolean {
+		const changed = editing !== this._editing;
+		this._editing = editing;
+		return changed;
+	}
+
+	public creating(): boolean {
+		return this._creating;
+	}
+
+	public setCreating(creating: boolean): boolean {
+		const changed = creating !== this._creating;
+		this._creating = creating;
+		return changed;
+	}
+
+	// public model(): ChartModel {
+		// return this._model;
+	// }
+
+	public toolType(): LineToolType {
+		return this._toolType;
+	}
+
+	public destroy(): void {}
+
+	public timeAxisPoints(): LineToolPoint[] {
+		return this.points();
+	}
+
+	public priceAxisPoints(): LineToolPoint[] {
+		return this.points();
+	}
+
+	public timeAxisLabelColor(): string | null {
+		return this.selected() ? '#2962FF' : null;
+	}
+
+	public priceAxisLabelColor(): string | null {
+		return this.selected() ? '#2962FF' : null;
+	}
+
+	public override timeAxisViews(): readonly ITimeAxisView[] {
+		return this._timeAxisViews;
+	}
+
+	public override priceAxisViews(): readonly PriceAxisView[] {
+		return this._priceAxisViews;
+	}
+
+	public lineDrawnWithPressedButton(): boolean {
+		return false;
+	}
+
+	public hasMagnet(): boolean {
+		return true;
+	}
+
+	// implementation of IPriceDataSource
+	public minMove(): number {
+		return 0;
+		// return this._options.priceFormat.minMove;
+	}
+
+	public autoscaleInfo(startTimePoint: TimePointIndex, endTimePoint: TimePointIndex): AutoscaleInfoImpl | null {
+		return null;
+	}
+
+	public firstValue(): FirstValue | null {
+		return null;
+	}
+
+	public formatter(): IPriceFormatter {
+		return this._formatter;
+	}
+
+	public priceLineColor(lastBarColor: string): string {
+		return lastBarColor;
+	}
+
+	public exportLineToolToLineToolExport(): LineToolExport<T> {
+		return { id: this.id(), toolType: this._toolType, options: this.options(), points: this.points() };
+	}
+
+	protected _setPaneViews(paneViews: IUpdatablePaneView[]): void {
+		this._paneViews = paneViews;
+	}
+
+	protected _updateAllPaneViews(): void {
+		this._paneViews.forEach((paneView: IUpdatablePaneView) => paneView.update());
+	}
+}
diff --git a/src/model/line-tools.ts b/src/model/line-tools.ts
new file mode 100644
index 0000000..b492077
--- /dev/null
+++ b/src/model/line-tools.ts
@@ -0,0 +1,40 @@
+/* eslint-disable @typescript-eslint/naming-convention */
+import { LineTool } from './line-tool';
+import { LineToolArrow } from './line-tool-arrow';
+import { LineToolBrush } from './line-tool-brush';
+import { LineToolCrossLine } from './line-tool-cross-line';
+import { LineToolExtendedLine } from './line-tool-extended-line';
+import { LineToolFibRetracement } from './line-tool-fib-retracement';
+import { LineToolHighlighter } from './line-tool-highlighter';
+import { LineToolHorizontalLine } from './line-tool-horizontal-line';
+import { LineToolHorizontalRay } from './line-tool-horizontal-ray';
+import { LineToolType } from './line-tool-options';
+import { LineToolParallelChannel } from './line-tool-parallel-channel';
+import { LineToolPath } from './line-tool-path';
+import { LineToolRay } from './line-tool-ray';
+import { LineToolRectangle } from './line-tool-rectangle';
+import { LineToolText } from './line-tool-text';
+import { LineToolTrendLine } from './line-tool-trend-line';
+import { LineToolTriangle } from './line-tool-triangle';
+import { LineToolVerticalLine } from './line-tool-vertical-line';
+
+// eslint-disable-next-line @typescript-eslint/no-explicit-any
+export const LineTools: Record<LineToolType, new(...args: any) => LineTool<LineToolType>> = {
+	FibRetracement: LineToolFibRetracement,
+	ParallelChannel: LineToolParallelChannel,
+	HorizontalLine: LineToolHorizontalLine,
+	VerticalLine: LineToolVerticalLine,
+	Highlighter: LineToolHighlighter,
+	CrossLine: LineToolCrossLine,
+	TrendLine: LineToolTrendLine,
+	Rectangle: LineToolRectangle,
+	Triangle: LineToolTriangle,
+	Brush: LineToolBrush,
+	Path: LineToolPath,
+	Text: LineToolText,
+
+	Ray: LineToolRay,
+	Arrow: LineToolArrow,
+	ExtendedLine: LineToolExtendedLine,
+	HorizontalRay: LineToolHorizontalRay,
+};
diff --git a/src/model/magnet.ts b/src/model/magnet.ts
index 85b267a..9962316 100644
--- a/src/model/magnet.ts
+++ b/src/model/magnet.ts
@@ -9,17 +9,27 @@ import { Series } from './series';
 import { TimePointIndex } from './time-data';
 
 export class Magnet {
+	private _enabled: boolean = true;
 	private readonly _options: CrosshairOptions;
 
 	public constructor(options: CrosshairOptions) {
 		this._options = options;
 	}
 
+	public enable(): void {
+		this._enabled = true;
+	}
+
+	public disable(): void {
+		this._enabled = false;
+	}
+
 	public align(price: number, index: TimePointIndex, pane: Pane): number {
 		let res = price;
 		if (this._options.mode === CrosshairMode.Normal) {
 			return res;
 		}
+		if (!this._enabled) { return price; }
 
 		const defaultPriceScale = pane.defaultPriceScale();
 		const firstValue = defaultPriceScale.firstValue();
@@ -52,7 +62,12 @@ export class Magnet {
 
 				// convert bar to pixels
 				const firstPrice = ensure(series.firstValue());
-				return acc.concat([ps.priceToCoordinate(bar.value[PlotRowValueIndex.Close], firstPrice.value)]);
+				return acc.concat(
+					[ps.priceToCoordinate(bar.value[PlotRowValueIndex.Close], firstPrice.value)],
+					[ps.priceToCoordinate(bar.value[PlotRowValueIndex.Low], firstPrice.value)],
+					[ps.priceToCoordinate(bar.value[PlotRowValueIndex.High], firstPrice.value)],
+					[ps.priceToCoordinate(bar.value[PlotRowValueIndex.Open], firstPrice.value)]
+				);
 			},
 			[] as Coordinate[]);
 
@@ -63,7 +78,10 @@ export class Magnet {
 		candidates.sort((y1: Coordinate, y2: Coordinate) => Math.abs(y1 - y) - Math.abs(y2 - y));
 
 		const nearest = candidates[0];
-		res = defaultPriceScale.coordinateToPrice(nearest, firstValue);
+		// res = defaultPriceScale.coordinateToPrice(nearest, firstValue);
+		if (Math.abs(nearest - y) < this._options.magnetThreshold) {
+			res = defaultPriceScale.coordinateToPrice(nearest, firstValue);
+		}
 
 		return res;
 	}
diff --git a/src/model/pane.ts b/src/model/pane.ts
index 7373808..37df8e8 100644
--- a/src/model/pane.ts
+++ b/src/model/pane.ts
@@ -8,6 +8,8 @@ import { ChartModel, ChartOptions, OverlayPriceScaleOptions, VisiblePriceScaleOp
 import { DefaultPriceScaleId, isDefaultPriceScale } from './default-price-scale';
 import { Grid } from './grid';
 import { IPriceDataSource } from './iprice-data-source';
+import { LineTool } from './line-tool';
+import { LineToolType } from './line-tool-options';
 import { PriceScale, PriceScaleOptions, PriceScaleState } from './price-scale';
 import { sortSources } from './sort-sources';
 import { TimeScale } from './time-scale';
@@ -23,6 +25,19 @@ interface MinMaxOrderInfo {
 	maxZOrder: number;
 }
 
+export enum PaneCursorType {
+	Default = 'default',
+	Crosshair = 'crosshair',
+	Pointer = 'pointer',
+	Grabbing = 'grabbing',
+	ZoomIn = 'zoom-in',
+	VerticalResize = 'n-resize',
+	HorizontalResize = 'e-resize',
+	DiagonalNeSwResize = 'nesw-resize',
+	DiagonalNwSeResize = 'nwse-resize',
+	NotAllowed = 'not-allowed',
+}
+
 export class Pane implements IDestroyable {
 	private readonly _timeScale: TimeScale;
 	private readonly _model: ChartModel;
@@ -203,6 +218,19 @@ export class Pane implements IDestroyable {
 		this._cachedOrderedSources = null;
 	}
 
+	public getAllLineTools(): LineTool<LineToolType>[] {
+		return this._dataSources.filter((s: IPriceDataSource) => s instanceof LineTool).map((s: IPriceDataSource) => (s as LineTool<LineToolType>));
+	}
+
+	public getLineTool(id: string): LineTool<LineToolType> | null {
+		const lineTools = this._dataSources.filter((s: IPriceDataSource) => s instanceof LineTool && s.id() === id).map((s: IPriceDataSource) => (s as LineTool<LineToolType>));
+		return lineTools.length > 0 ? lineTools[0] : null;
+	}
+
+	public getSelectedLineTools(): LineTool<LineToolType>[] {
+		return this._dataSources.filter((s: IPriceDataSource) => s instanceof LineTool && (s as LineTool).selected()).map((s: IPriceDataSource) => (s as LineTool<LineToolType>));
+	}
+
 	public priceScalePosition(priceScale: PriceScale): PriceScalePosition {
 		if (priceScale === this._leftPriceScale) {
 			return 'left';
diff --git a/src/model/point.ts b/src/model/point.ts
index d18115d..ff945ce 100644
--- a/src/model/point.ts
+++ b/src/model/point.ts
@@ -1,15 +1,146 @@
 import { Coordinate } from './coordinate';
 
-/**
- * Represents a point on the chart.
- */
-export interface Point {
-	/**
-	 * The x coordinate.
-	 */
-	readonly x: Coordinate;
-	/**
-	 * The y coordinate.
-	 */
-	readonly y: Coordinate;
+// /**
+ // * Represents a point on the chart.
+ // */
+// export interface Point {
+	// /**
+	 // * The x coordinate.
+	 // */
+	// readonly x: Coordinate;
+	// /**
+	 // * The y coordinate.
+	 // */
+	// readonly y: Coordinate;
+// }
+
+
+export interface IPoint {
+	x: Coordinate;
+	y: Coordinate;
+}
+
+export class Point {
+	public x!: Coordinate;
+	public y!: Coordinate;
+
+	public constructor(x: number, y: number)
+	public constructor(x: Coordinate, y: Coordinate) {
+		(this.x as Coordinate) = x;
+		(this.y as Coordinate) = y;
+	}
+
+	public add(point: Point): Point {
+		return new Point(this.x + point.x, this.y + point.y);
+	}
+
+	public addScaled(point: Point, scale: number): Point {
+		return new Point(this.x + scale * point.x, this.y + scale * point.y);
+	}
+
+	public subtract(point: Point): Point {
+		return new Point(this.x - point.x, this.y - point.y);
+	}
+
+	public dotProduct(point: Point): number {
+		return this.x * point.x + this.y * point.y;
+	}
+
+	public crossProduct(point: Point): number {
+		return this.x * point.y - this.y * point.x;
+	}
+
+	public signedAngle(point: Point): number {
+		return Math.atan2(this.crossProduct(point), this.dotProduct(point));
+	}
+
+	public angle(point: Point): number {
+		return Math.acos(this.dotProduct(point) / (this.length() * point.length()));
+	}
+
+	public length(): number {
+		return Math.sqrt(this.x * this.x + this.y * this.y);
+	}
+
+	public scaled(scale: number): Point {
+		return new Point(this.x * scale, this.y * scale);
+	}
+
+	public normalized(): Point {
+		return this.scaled(1 / this.length());
+	}
+
+	public transposed(): Point {
+		return new Point(-this.y, this.x);
+	}
+
+	public clone(): Point {
+		return new Point(this.x, this.y);
+	}
+}
+
+export class Box {
+	public min: Point;
+	public max: Point;
+
+	public constructor(a: Point, b: Point) {
+		this.min = new Point(Math.min(a.x, b.x), Math.min(a.y, b.y));
+		this.max = new Point(Math.max(a.x, b.x), Math.max(a.y, b.y));
+	}
+}
+
+export class HalfPlane {
+	public edge: Line;
+	public isPositive: boolean;
+
+	public constructor(edge: Line, isPositive: boolean) {
+		this.edge = edge;
+		this.isPositive = isPositive;
+	}
+}
+
+export interface Rect {
+	x: number;
+	y: number;
+	width: number;
+	height: number;
+}
+
+export interface Line {
+	a: number;
+	b: number;
+	c: number;
+}
+
+export type Segment = [Point, Point];
+
+export function equalPoints(a: Point, b: Point): boolean {
+	return a.x === b.x && a.y === b.y;
+}
+
+export function line(a: number, b: number, c: number): Line {
+	return { a, b, c };
+}
+
+export function lineThroughPoints(a: Point, b: Point): Line {
+	if (equalPoints(a, b)) {throw new Error('Points should be distinct');}
+	return line(a.y - b.y, b.x - a.x, a.x * b.y - b.x * a.y);
+}
+
+export function lineSegment(a: Point, b: Point): Segment {
+	if (equalPoints(a, b)) { throw new Error('Points of a segment should be distinct'); }
+	return [a, b];
+}
+
+export function halfPlaneThroughPoint(edge: Line, point: Point): HalfPlane {
+	return new HalfPlane(edge, edge.a * point.x + edge.b * point.y + edge.c > 0);
+}
+
+export function pointInHalfPlane(point: Point, halfPlane: HalfPlane): boolean {
+	const edge = halfPlane.edge;
+	return edge.a * point.x + edge.b * point.y + edge.c > 0 === halfPlane.isPositive;
+}
+
+export function equalBoxes(a: Box, b: Box): boolean {
+	return equalPoints(a.min, b.min) && equalPoints(a.max, b.max);
 }
diff --git a/src/model/price-line-options.ts b/src/model/price-line-options.ts
index c46e0ea..6b43aa2 100644
--- a/src/model/price-line-options.ts
+++ b/src/model/price-line-options.ts
@@ -46,4 +46,16 @@ export interface PriceLineOptions {
 	 * @defaultValue `''`
 	 */
 	title: string;
+	/**
+	 * Whether the price line is a ray.
+	 *
+	 * @defaultValue `false`
+	 */
+	ray: boolean;
+	/**
+	 * Ray start date as a number.
+	 *
+	 * @defaultValue `0`
+	 */
+	rayStart: number;
 }
diff --git a/src/model/series-markers.ts b/src/model/series-markers.ts
index a05b173..948ee7c 100644
--- a/src/model/series-markers.ts
+++ b/src/model/series-markers.ts
@@ -1,12 +1,25 @@
 /**
  * Represents the position of a series marker relative to a bar.
  */
-export type SeriesMarkerPosition = 'aboveBar' | 'belowBar' | 'inBar';
+export type SeriesMarkerPosition = 'aboveBar' | 'belowBar' | 'inBar' | 'price';
 
 /**
  * Represents the shape of a series marker.
  */
-export type SeriesMarkerShape = 'circle' | 'square' | 'arrowUp' | 'arrowDown';
+export type SeriesMarkerShape = 'circle' | 'square' | 'arrowUp' | 'arrowDown' | 'triangle';
+
+/**
+ * Represents the anchor of a series marker.
+ */
+export type SeriesMarkerAnchor = 'top' | 'bottom' | 'left' | 'right' | 'center';
+
+/**
+ * Represents the stroke of a series marker.
+ */
+export interface SeriesMarkerStroke {
+	color: string;
+	width?: number;
+}
 
 /**
  * Represents a series marker.
@@ -42,6 +55,22 @@ export interface SeriesMarker<TimeType> {
 	 * @defaultValue `1`
 	 */
 	size?: number;
+	/**
+	 * The price position of the marker.
+	 */
+	price?: number;
+	/**
+	 * The anchor of the marker.
+	 */
+	anchor?: SeriesMarkerAnchor;
+	/**
+	 * The stroke of the marker.
+	 */
+	stroke?: SeriesMarkerStroke;
+	/**
+	 * The rotation of the marker.
+	 */
+	rotation?: number;
 }
 
 export interface InternalSeriesMarker<TimeType> extends SeriesMarker<TimeType> {
diff --git a/src/model/time-scale.ts b/src/model/time-scale.ts
index 66d370f..3cf52ec 100644
--- a/src/model/time-scale.ts
+++ b/src/model/time-scale.ts
@@ -283,6 +283,27 @@ export class TimeScale {
 		return this._points[index]?.time || null;
 	}
 
+	public floatIndexToTime(index: TimePointIndex): TimePoint | null {
+		const index1 = Math.floor(index);
+		const index2 = Math.ceil(index);
+
+		const time1 = this._points[index1]?.time.timestamp as number;
+		const time2 = this._points[index2]?.time.timestamp as number;
+		const firstTime = this._points[0]?.time.timestamp as number;
+		const lastTime = this._points[this._points.length - 1]?.time.timestamp as number;
+		const interval = this._points[1].time.timestamp - this._points[0].time.timestamp;
+
+		if (index >= this._points.length - 1) {
+			return { timestamp: (lastTime + interval * (index - this._points.length + 1 )) as UTCTimestamp };
+		} else if (index < 0) {
+			return { timestamp: (firstTime - interval * -index) as UTCTimestamp };
+		} else if (time1 && time2) {
+			return { timestamp: (time1 + (time2 - time1) * (index - index1)) as UTCTimestamp };
+		} else {
+			return null;
+		}
+	}
+
 	public timeToIndex(time: TimePoint, findNearest: boolean): TimePointIndex | null {
 		if (this._points.length < 1) {
 			// no time points available
@@ -421,10 +442,42 @@ export class TimeScale {
 		}
 	}
 
+	public timeToCoordinate(timePoint: TimePoint): Coordinate {
+		const index = this.timeToIndex(timePoint, true);
+		const timestamp = this._points[index as number].time.timestamp;
+		const x = this.indexToCoordinate(index as TimePointIndex);
+		if (timestamp === timePoint.timestamp) {
+			return x;
+		} else if (index === 0 || index === this._points.length - 1) {
+			const interval = this._points[1].time.timestamp - this._points[0].time.timestamp;
+			const timeDiff = timePoint.timestamp - timestamp;
+			const bars = timeDiff / interval;
+			return x + (bars * this.barSpacing()) as Coordinate;
+		} else {
+			return x;
+		}
+		
+	}
+
 	public coordinateToIndex(x: Coordinate): TimePointIndex {
 		return Math.ceil(this._coordinateToFloatIndex(x)) as TimePointIndex;
 	}
 
+	public coordinateToTime(x: Coordinate): TimePoint {
+		const interval = this._points[1].time.timestamp - this._points[0].time.timestamp;
+		const index = this.coordinateToIndex(x);
+
+		if (index >= this._points.length) {
+			const extraTime = interval * (index - this._points.length + 1);
+			return { timestamp: this._points[this._points.length - 1].time.timestamp + extraTime as UTCTimestamp };
+		} else if (index < 0) {
+			const extraTime = interval * -index;
+			return { timestamp: this._points[0].time.timestamp - extraTime as UTCTimestamp };
+		}
+
+		return this._points[index].time;
+	}
+
 	public setRightOffset(offset: number): void {
 		this._visibleRangeInvalidated = true;
 		this._rightOffset = offset;
diff --git a/src/renderers/composite-renderer.ts b/src/renderers/composite-renderer.ts
index 447562c..f747eb4 100644
--- a/src/renderers/composite-renderer.ts
+++ b/src/renderers/composite-renderer.ts
@@ -1,17 +1,54 @@
+import { Coordinate } from '../model/coordinate';
+import { HitTestResult } from '../model/hit-test-result';
+
 import { IPaneRenderer } from './ipane-renderer';
 
 export class CompositeRenderer implements IPaneRenderer {
-	private _renderers: readonly IPaneRenderer[] = [];
+	private _renderers: IPaneRenderer[] = [];
+	private _globalAlpha: number = 1;
+
+	public setGlobalAlpha(value: number): void {
+		this._globalAlpha = value;
+	}
+
+	public append(renderer: IPaneRenderer): void {
+		this._renderers.push(renderer);
+	}
+
+	public insert(renderer: IPaneRenderer, index: number): void {
+		this._renderers.splice(index, 0, renderer);
+	}
 
-	public setRenderers(renderers: readonly IPaneRenderer[]): void {
+	public clear(): void {
+		this._renderers.length = 0;
+	}
+
+	public isEmpty(): boolean {
+		return this._renderers.length === 0;
+	}
+
+	public setRenderers(renderers: IPaneRenderer[]): void {
 		this._renderers = renderers;
 	}
 
 	public draw(ctx: CanvasRenderingContext2D, pixelRatio: number, isHovered: boolean, hitTestData?: unknown): void {
 		this._renderers.forEach((r: IPaneRenderer) => {
 			ctx.save();
+			ctx.globalAlpha = this._globalAlpha;
 			r.draw(ctx, pixelRatio, isHovered, hitTestData);
 			ctx.restore();
 		});
 	}
+
+	public hitTest(x: Coordinate, y: Coordinate, ctx: CanvasRenderingContext2D): HitTestResult<unknown> | null {
+		let result = null;
+		for (let i = this._renderers.length - 1; i >= 0; i--) {
+			const renderer = this._renderers[i];
+			if (renderer.hitTest) {
+				result = renderer.hitTest(x, y, ctx) || null;
+			}
+			if (result) { break; }
+		}
+		return result;
+	}
 }
diff --git a/src/renderers/draw-line.ts b/src/renderers/draw-line.ts
index 0b841db..6592659 100644
--- a/src/renderers/draw-line.ts
+++ b/src/renderers/draw-line.ts
@@ -1,4 +1,6 @@
 import { Coordinate } from '../model/coordinate';
+import { intersectLineAndBox, intersectLineSegmentAndBox, intersectRayAndBox } from '../model/interesection';
+import { Box, equalPoints, lineSegment, lineThroughPoints, Point, Segment } from '../model/point';
 
 /**
  * Represents the width of a line.
@@ -19,6 +21,24 @@ export const enum LineType {
 	WithSteps,
 }
 
+/**
+ * Represents the possible line caps.
+ */
+export const enum LineEnd {
+	/**
+	 * No cap.
+	 */
+	Normal,
+	/**
+	 * Arrow cap.
+	 */
+	Arrow,
+	/**
+	 * Circle cap.
+	 */
+	Circle,
+}
+
 /**
  * A point on a line.
  */
@@ -57,19 +77,58 @@ export const enum LineStyle {
 	 * A dottled line with more space between dots.
 	 */
 	SparseDotted = 4,
+	/**
+	 * A dashed line with less space between dots.
+	 */
+	SmallDashed = 5,
+}
+
+export function computeDashPattern(ctx: CanvasRenderingContext2D): number[] {
+	return [
+		[ctx.lineWidth, ctx.lineWidth],
+		[2 * ctx.lineWidth, 2 * ctx.lineWidth],
+		[6 * ctx.lineWidth, 6 * ctx.lineWidth],
+		[ctx.lineWidth, 4 * ctx.lineWidth],
+		[2 * ctx.lineWidth, ctx.lineWidth],
+	][ctx.lineStyle - 1] || [];
+}
+
+export function computeEndLineSize(lineWidth: number): number {
+	let endLineMultiplier = 1;
+	switch (lineWidth) {
+		case 1:
+			endLineMultiplier = 3.5;
+			break;
+		case 2:
+			endLineMultiplier = 2;
+			break;
+		case 3:
+			endLineMultiplier = 1.5;
+			break;
+		case 4:
+			endLineMultiplier = 1.25;
+			break;
+		case 0:
+		default:
+			break;
+	}
+	return endLineMultiplier;
 }
 
 export function setLineStyle(ctx: CanvasRenderingContext2D, style: LineStyle): void {
-	const dashPatterns = {
-		[LineStyle.Solid]: [],
-		[LineStyle.Dotted]: [ctx.lineWidth, ctx.lineWidth],
-		[LineStyle.Dashed]: [2 * ctx.lineWidth, 2 * ctx.lineWidth],
-		[LineStyle.LargeDashed]: [6 * ctx.lineWidth, 6 * ctx.lineWidth],
-		[LineStyle.SparseDotted]: [ctx.lineWidth, 4 * ctx.lineWidth],
-	};
+	ctx.lineStyle = style;
+	const dashPattern = computeDashPattern(ctx);
+	setLineDash(ctx, dashPattern);
+}
 
-	const dashPattern = dashPatterns[style];
-	ctx.setLineDash(dashPattern);
+export function setLineDash(ctx: CanvasRenderingContext2D, dashPattern: number[]): void {
+	if (ctx.setLineDash) {
+		ctx.setLineDash(dashPattern);
+	} else if (ctx.mozDash !== undefined) {
+		ctx.mozDash = dashPattern;
+	} else if (ctx.webkitLineDash !== undefined) {
+		ctx.webkitLineDash = dashPattern;
+	}
 }
 
 export function drawHorizontalLine(ctx: CanvasRenderingContext2D, y: number, left: number, right: number): void {
@@ -88,6 +147,35 @@ export function drawVerticalLine(ctx: CanvasRenderingContext2D, x: number, top:
 	ctx.stroke();
 }
 
+export function drawSolidLine(ctx: CanvasRenderingContext2D, x1: number, y1: number, x2: number, y2: number): void {
+	ctx.beginPath();
+	ctx.moveTo(x1, y1);
+	ctx.lineTo(x2, y2);
+	ctx.stroke();
+}
+
+export function drawDashedLine(ctx: CanvasRenderingContext2D, x1: number, y1: number, x2: number, y2: number): void {
+	ctx.save();
+	ctx.beginPath();
+
+	const dashPattern = computeDashPattern(ctx);
+	setLineDash(ctx, dashPattern);
+
+	ctx.moveTo(x1, y1);
+	ctx.lineTo(x2, y2);
+	ctx.stroke();
+	ctx.restore();
+}
+
+export function drawLine(ctx: CanvasRenderingContext2D, x1: number, y1: number, x2: number, y2: number): void {
+	if (!isFinite(x1) || !isFinite(y1) || !isFinite(x2) || !isFinite(y2)) { return; }
+	if (ctx.lineStyle !== LineStyle.Solid) {
+		drawDashedLine(ctx, x1, y1, x2, y2);
+	} else {
+		drawSolidLine(ctx, x1, y1, x2, y2);
+	}
+}
+
 export function strokeInPixel(ctx: CanvasRenderingContext2D, drawFunction: () => void): void {
 	ctx.save();
 	if (ctx.lineWidth % 2) {
@@ -96,3 +184,82 @@ export function strokeInPixel(ctx: CanvasRenderingContext2D, drawFunction: () =>
 	drawFunction();
 	ctx.restore();
 }
+
+export function extendAndClipLineSegment(point0: Point, point1: Point, width: number, height: number, extendLeft: boolean, extendRight: boolean): Segment | null {
+	if (equalPoints(point0, point1)) {
+		return null;
+	}
+
+	const topLeft = new Point(0, 0);
+	const bottomRight = new Point(width, height);
+
+	if (extendLeft) {
+		if (extendRight) {
+			const points = intersectLineAndBox(lineThroughPoints(point0, point1), new Box(topLeft, bottomRight));
+			return Array.isArray(points) ? points : null;
+		} else {
+			const point = intersectRayAndBox(point1, point0, new Box(topLeft, bottomRight));
+			return point === null || equalPoints(point1, point) ? null : lineSegment(point1, point);
+		}
+	}
+
+	if (extendRight) {
+		const point = intersectRayAndBox(point0, point1, new Box(topLeft, bottomRight));
+		return point === null || equalPoints(point0, point) ? null : lineSegment(point0, point);
+	} else {
+		const points = intersectLineSegmentAndBox(lineSegment(point0, point1), new Box(topLeft, bottomRight));
+		return Array.isArray(points) ? points : null;
+	}
+}
+
+export function drawCircleEnd(point: Point, ctx: CanvasRenderingContext2D, width: number, pixelRatio: number): void {
+	const circleEndMultiplier = computeEndLineSize(width);
+	ctx.save();
+	ctx.fillStyle = '#000000';
+	ctx.beginPath();
+	ctx.arc(point.x * pixelRatio, point.y * pixelRatio, width * circleEndMultiplier * pixelRatio, 0, 2 * Math.PI, false);
+	ctx.fill();
+	ctx.restore();
+}
+
+export function drawArrowEnd(point0: Point, point1: Point, ctx: CanvasRenderingContext2D, width: number, pixelRatio: number): void {
+	if (point1.subtract(point0).length() < 1) {return;}
+	const arrowPoints = getArrowPoints(point0, point1, width);
+	for (let e = 0; e < arrowPoints.length; ++e) {
+		const first = arrowPoints[e][0];
+		const second = arrowPoints[e][1];
+		drawLine(ctx, first.x * pixelRatio, first.y * pixelRatio, second.x * pixelRatio, second.y * pixelRatio);
+	}
+}
+
+export function getArrowPoints(point0: Point, point1: Point, width: number): [[Point, Point], [Point, Point], [Point, Point], [Point, Point]] | [] {
+	const r = 0.5 * width;
+	const n = Math.sqrt(2);
+	const o = point1.subtract(point0);
+	const a = o.normalized();
+	const arrowheadMultiplier = computeEndLineSize(width);
+	const l = 5 * width * arrowheadMultiplier;
+	const c = 1 * r;
+
+	if (l * n * 0.2 <= c) { return []; }
+
+	const h = a.scaled(l);
+	const d = point1.subtract(h);
+	const u = a.transposed();
+	const p = 1 * l;
+	const z = u.scaled(p);
+	const m = d.add(z);
+	const g = d.subtract(z);
+	const f = m.subtract(point1).normalized().scaled(c);
+	const v = g.subtract(point1).normalized().scaled(c);
+	const S = point1.add(f);
+	const y = point1.add(v);
+	const b = r * (n - 1);
+	const w = u.scaled(b);
+	const C = Math.min(l - 1 * r / n, r * n * 1);
+	const P = a.scaled(C);
+	const T = point1.subtract(w);
+	const x = point1.add(w);
+	const I = point1.subtract(P);
+	return [[m, S], [g, y], [T, I.subtract(w)], [x, I.add(w)]];
+}
diff --git a/src/renderers/draw-rect.ts b/src/renderers/draw-rect.ts
new file mode 100644
index 0000000..5a98fa2
--- /dev/null
+++ b/src/renderers/draw-rect.ts
@@ -0,0 +1,125 @@
+import { Point } from '../model/point';
+
+import { LineStyle } from '..';
+import { setLineStyle } from './draw-line';
+
+export function drawRoundRect(ctx: CanvasRenderingContext2D, x: number, y: number, width: number, height: number, radius: number | number[], borderStyle?: number): void {
+	let a; let b; let c; let d;
+
+	if (Array.isArray(radius)) {
+		if (2 === radius.length) {
+			const e = Math.max(0, radius[0]);
+			const t = Math.max(0, radius[1]);
+			a = e;
+			b = e;
+			c = t;
+			d = t;
+		} else {
+			if (4 !== radius.length) { throw new Error('Wrong border radius - it should be like css border radius'); }
+			a = Math.max(0, radius[0]);
+			b = Math.max(0, radius[1]);
+			c = Math.max(0, radius[2]);
+			d = Math.max(0, radius[3]);
+		}
+	} else {
+		const e = Math.max(0, radius);
+		a = e;
+		b = e;
+		c = e;
+		d = e;
+	}
+
+	ctx.beginPath();
+
+	setLineStyle(ctx, borderStyle || LineStyle.Solid);
+
+	ctx.moveTo(x + a, y);
+	ctx.lineTo(x + width - b, y);
+	if (b !== 0) { ctx.arcTo(x + width, y, x + width, y + b, b); }
+	ctx.lineTo(x + width, y + height - c);
+	if (c !== 0) { ctx.arcTo(x + width, y + height, x + width - c, y + height, c); }
+	ctx.lineTo(x + d, y + height);
+	if (d !== 0) { ctx.arcTo(x, y + height, x, y + height - d, d); }
+	ctx.lineTo(x, y + a);
+	if (a !== 0) { ctx.arcTo(x, y, x + a, y, a); }
+	ctx.stroke();
+}
+
+// eslint-disable-next-line max-params
+export function fillRectWithBorder(
+	ctx: CanvasRenderingContext2D,
+	point0: Point,
+	point1: Point,
+	backgroundColor: string | undefined,
+	borderColor: string | undefined,
+	borderWidth: number = 0,
+	borderStyle: LineStyle,
+	borderAlign: 'outer' | 'center' | 'inner',
+	extendLeft: boolean,
+	extendRight: boolean,
+	containerWidth: number
+): void {
+	const x1 = extendLeft ? 0 : point0.x;
+	const x2 = extendRight ? containerWidth : point1.x;
+
+	if (backgroundColor !== undefined) {
+		ctx.fillStyle = backgroundColor;
+		ctx.fillRect(x1, point0.y, x2 - x1, point1.y - point0.y);
+	}
+
+	if (borderColor !== undefined && borderWidth > 0) {
+		ctx.beginPath();
+		setLineStyle(ctx, borderStyle || LineStyle.Solid);
+
+		let topLeft = new Point(0, 0);
+		let topRight = new Point(0, 0);
+		let bottomRight = new Point(0, 0);
+		let bottomLeft = new Point(0, 0);
+
+		switch (borderAlign) {
+			case 'outer':
+				{
+					const halfBordeWidth = 0.5 * borderWidth;
+					bottomRight = new Point(0, halfBordeWidth);
+					bottomLeft = new Point(0, halfBordeWidth);
+					topLeft = new Point(halfBordeWidth, -borderWidth);
+					topRight = new Point(halfBordeWidth, -borderWidth);
+					break;
+				}
+			case 'center':
+				{
+					const e = borderWidth % 2 ? 0.5 : 0;
+					const t = borderWidth % 2 ? 0.5 : 1;
+					const halfBordeWidth = 0.5 * borderWidth;
+
+					bottomRight = new Point(halfBordeWidth - e, -e);
+					bottomLeft = new Point(t + halfBordeWidth, -e);
+					topLeft = new Point(-e, e + halfBordeWidth);
+					topRight = new Point(t, e + halfBordeWidth);
+					break;
+				}
+			case 'inner':
+				{
+					const halfBordeWidth = 0.5 * borderWidth;
+					bottomRight = new Point(0, -halfBordeWidth);
+					bottomLeft = new Point(1, -halfBordeWidth);
+					topLeft = new Point(-halfBordeWidth, borderWidth);
+					topRight = new Point(1 - halfBordeWidth, borderWidth);
+					break;
+				}
+		}
+
+		ctx.lineWidth = borderWidth;
+		ctx.strokeStyle = borderColor;
+
+		ctx.moveTo(x1 - bottomRight.x, point0.y - bottomRight.y);
+		ctx.lineTo(x2 + bottomLeft.x, point0.y - bottomLeft.y);
+		ctx.moveTo(point1.x + topRight.x, point0.y + topRight.y);
+		ctx.lineTo(point1.x + topRight.x, point1.y - topRight.y);
+		ctx.moveTo(x1 - bottomRight.x, point1.y + bottomRight.y);
+		ctx.lineTo(x2 + bottomLeft.x, point1.y + bottomLeft.y);
+		ctx.moveTo(point0.x - topLeft.x, point0.y + topLeft.y);
+		ctx.lineTo(point0.x - topLeft.x, point1.y - topLeft.y);
+		ctx.stroke();
+	}
+}
diff --git a/src/renderers/horizontal-line-renderer.ts b/src/renderers/horizontal-line-renderer.ts
index 11176f4..2b74bfc 100644
--- a/src/renderers/horizontal-line-renderer.ts
+++ b/src/renderers/horizontal-line-renderer.ts
@@ -12,6 +12,8 @@ export interface HorizontalLineRendererData {
 	y: Coordinate;
 	visible?: boolean;
 	width: number;
+	ray: boolean;
+	rayStart: number;
 }
 
 export class HorizontalLineRenderer implements IPaneRenderer {
@@ -36,11 +38,17 @@ export class HorizontalLineRenderer implements IPaneRenderer {
 			return;
 		}
 
+		let start = 0;
+
+		if (this._data.ray === true) {
+			start = this._data.rayStart;
+		}
+
 		const width = Math.ceil(this._data.width * pixelRatio);
 		ctx.lineCap = 'butt';
 		ctx.strokeStyle = this._data.color;
 		ctx.lineWidth = Math.floor(this._data.lineWidth * pixelRatio);
 		setLineStyle(ctx, this._data.lineStyle);
-		drawHorizontalLine(ctx, y, 0, width);
+		drawHorizontalLine(ctx, y, start, width);
 	}
 }
diff --git a/src/renderers/ipane-renderer.ts b/src/renderers/ipane-renderer.ts
index c04873a..28672ac 100644
--- a/src/renderers/ipane-renderer.ts
+++ b/src/renderers/ipane-renderer.ts
@@ -1,8 +1,8 @@
-import { HoveredObject } from '../model/chart-model';
 import { Coordinate } from '../model/coordinate';
+import { HitTestResult } from '../model/hit-test-result';
 
 export interface IPaneRenderer {
 	draw(ctx: CanvasRenderingContext2D, pixelRatio: number, isHovered: boolean, hitTestData?: unknown): void;
 	drawBackground?(ctx: CanvasRenderingContext2D, pixelRatio: number, isHovered: boolean, hitTestData?: unknown): void;
-	hitTest?(x: Coordinate, y: Coordinate): HoveredObject | null;
+	hitTest?(x: Coordinate, y: Coordinate, ctx: CanvasRenderingContext2D): HitTestResult<unknown> | null;
 }
diff --git a/src/renderers/line-anchor-renderer.ts b/src/renderers/line-anchor-renderer.ts
new file mode 100644
index 0000000..bda87d6
--- /dev/null
+++ b/src/renderers/line-anchor-renderer.ts
@@ -0,0 +1,179 @@
+import { ensureNotNull } from '../helpers/assertions';
+import { merge } from '../helpers/strict-type-checks';
+
+import { Coordinate } from '../model/coordinate';
+import { HitTestResult, HitTestType } from '../model/hit-test-result';
+import { LineToolHitTestData } from '../model/line-tool';
+import { PaneCursorType } from '../model/pane';
+import { Point } from '../model/point';
+
+import { drawRoundRect } from './draw-rect';
+import { IPaneRenderer } from './ipane-renderer';
+import { interactionTolerance } from './optimal-bar-width';
+
+export class AnchorPoint extends Point {
+	public data: number;
+	public square: boolean;
+
+	public constructor(x: number, y: number, data?: number, square?: boolean)
+	public constructor(x: Coordinate, y: Coordinate, data: number, square: boolean) {
+		super(x, y);
+		this.data = data;
+		this.square = square;
+	}
+
+	public override clone(): AnchorPoint {
+		return new AnchorPoint(this.x, this.y, this.data, this.square);
+	}
+}
+
+export interface LineAnchorRendererData {
+	points: AnchorPoint[];
+	backgroundColors: string[];
+	pointsCursorType?: PaneCursorType[];
+	editedPointIndex: number | null;
+	currentPoint: Point;
+
+	color: string;
+	radius: number;
+	strokeWidth: number;
+	hoveredStrokeWidth: number;
+	selected: boolean;
+	visible: boolean;
+	hitTestType: HitTestType;
+}
+
+type DrawCallback = (ctx: CanvasRenderingContext2D, point: Point, radius: number, lineWidth: number) => void;
+
+export class LineAnchorRenderer implements IPaneRenderer {
+	protected _data: LineAnchorRendererData | null;
+
+	public constructor(data?: LineAnchorRendererData) {
+		this._data = data !== undefined ? data : null;
+	}
+
+	public setData(data: LineAnchorRendererData): void {
+		this._data = data;
+	}
+
+	public updateData(data: Partial<LineAnchorRendererData>): void {
+		this._data = merge(this._data as unknown as Record<string, unknown>, data) as LineAnchorRendererData;
+	}
+
+	public draw(ctx: CanvasRenderingContext2D, pixelRatio: number, isHovered: boolean, hitTestData?: unknown): void {
+		if (this._data === null || !this._data.visible) {
+			return;
+		}
+
+		const squarePoints: AnchorPoint[] = [];
+		const squareColors: string[] = [];
+		const circlePoints: AnchorPoint[] = [];
+		const circleColors: string[] = [];
+
+		for (let e = 0; e < this._data.points.length; ++e) {
+			const point = this._data.points[e];
+			const color = this._data.backgroundColors[e];
+			if (point.square) {
+				squarePoints.push(point);
+				squareColors.push(color);
+			} else {
+				circlePoints.push(point);
+				circleColors.push(color);
+			}
+		}
+
+		ctx.strokeStyle = this._data.color;
+
+		if (squarePoints.length) {
+			this._drawPoints(ctx, pixelRatio, squarePoints, squareColors, drawRectBody, drawRectShadow);
+		}
+
+		if (circlePoints.length) {
+			this._drawPoints(ctx, pixelRatio, circlePoints, circleColors, drawCircleBody, drawCircleShadow);
+		}
+	}
+
+	public hitTest(x: Coordinate, y: Coordinate): HitTestResult<LineToolHitTestData> | null {
+		if (null === this._data) { return null; }
+		const position = new Point(x, y);
+
+		for (let r = 0; r < this._data.points.length; ++r) {
+			const point = this._data.points[r];
+			if (point.subtract(position).length() <= this._data.radius + interactionTolerance.anchor) {
+				const cursorType = this._data.pointsCursorType !== undefined ? this._data.pointsCursorType[r] : PaneCursorType.Default;
+				const pointIndex = point.data;
+
+				return new HitTestResult(this._data.hitTestType, { pointIndex, cursorType });
+			}
+		}
+		return null;
+	}
+
+	protected _drawPoints(ctx: CanvasRenderingContext2D, pixelRatio: number, points: AnchorPoint[], colors: string[], drawBody: DrawCallback, drawShadow: DrawCallback): void {
+		const data = ensureNotNull(this._data);
+		const currentPoint = data.currentPoint;
+
+		let lineWidth = Math.max(1, Math.floor((data.strokeWidth || 2) * pixelRatio));
+		if (data.selected) { lineWidth += Math.max(1, Math.floor(pixelRatio / 2)); }
+
+		const pixelRatioInt = Math.max(1, Math.floor(pixelRatio));
+		let radius = Math.round(data.radius * pixelRatio * 2);
+		if (pixelRatio % 2 !== pixelRatioInt % 2) { radius += 1; }
+		const shift = pixelRatioInt % 2 / 2;
+
+		for (let d = 0; d < points.length; ++d) {
+			const point = points[d];
+			ctx.fillStyle = colors[d];
+
+			if (!(Number.isInteger(point.data) && data.editedPointIndex === point.data)) {
+				const x = Math.round(point.x * pixelRatio) + shift;
+				const y = Math.round(point.y * pixelRatio) + shift;
+
+				drawBody(ctx, new AnchorPoint(x, y, point.data, point.square), radius / 2, lineWidth);
+				if (point.subtract(currentPoint).length() <= data.radius + interactionTolerance.anchor) {
+					const hoveredLineWidth = Math.max(1, Math.floor(data.hoveredStrokeWidth * pixelRatio));
+					drawShadow(ctx, new AnchorPoint(x, y, point.data, point.square), radius / 2, hoveredLineWidth);
+				}
+			}
+		}
+	}
+}
+
+function drawRect(ctx: CanvasRenderingContext2D, point: Point, radius: number, lineWidth: number): void {
+	ctx.lineWidth = lineWidth;
+	const n = radius + lineWidth / 2;
+	drawRoundRect(ctx, point.x - n, point.y - n, 2 * n, 2 * n, (radius + lineWidth) / 2);
+	ctx.closePath();
+}
+
+function drawRectShadow(ctx: CanvasRenderingContext2D, point: Point, radius: number, lineWidth: number): void {
+	ctx.globalAlpha = 0.2;
+	drawRect(ctx, point, radius, lineWidth);
+	ctx.stroke();
+	ctx.globalAlpha = 1;
+}
+
+function drawRectBody(ctx: CanvasRenderingContext2D, point: Point, radius: number, lineWidth: number): void {
+	drawRect(ctx, point, radius - lineWidth, lineWidth);
+	ctx.fill();
+	ctx.stroke();
+}
+
+function drawCircleShadow(ctx: CanvasRenderingContext2D, point: Point, radius: number, lineWidth: number): void {
+	ctx.lineWidth = lineWidth;
+	ctx.globalAlpha = 0.2;
+	ctx.beginPath();
+	ctx.arc(point.x, point.y, radius + lineWidth / 2, 0, 2 * Math.PI, true);
+	ctx.closePath();
+	ctx.stroke();
+	ctx.globalAlpha = 1;
+}
+
+function drawCircleBody(ctx: CanvasRenderingContext2D, point: Point, radius: number, lineWidth: number): void {
+	ctx.lineWidth = lineWidth;
+	ctx.beginPath();
+	ctx.arc(point.x, point.y, radius - lineWidth / 2, 0, 2 * Math.PI, true);
+	ctx.closePath();
+	ctx.fill();
+	ctx.stroke();
+}
diff --git a/src/renderers/optimal-bar-width.ts b/src/renderers/optimal-bar-width.ts
index 7a458e4..bec4de3 100644
--- a/src/renderers/optimal-bar-width.ts
+++ b/src/renderers/optimal-bar-width.ts
@@ -17,3 +17,12 @@ export function optimalCandlestickWidth(barSpacing: number, pixelRatio: number):
 	const optimal = Math.min(res, scaledBarSpacing);
 	return Math.max(Math.floor(pixelRatio), optimal);
 }
+
+export const interactionTolerance = {
+	line: 3,
+	minDistanceBetweenPoints: 5,
+	series: 2,
+	curve: 3,
+	anchor: 2,
+	esd: 0,
+};
diff --git a/src/renderers/parallel-channel-renderer.ts b/src/renderers/parallel-channel-renderer.ts
new file mode 100644
index 0000000..543962d
--- /dev/null
+++ b/src/renderers/parallel-channel-renderer.ts
@@ -0,0 +1,150 @@
+import { ensureNotNull } from '../helpers/assertions';
+import { DeepPartial } from '../helpers/strict-type-checks';
+
+import { Coordinate } from '../model/coordinate';
+import { HitTestResult, HitTestType } from '../model/hit-test-result';
+import { distanceToLine, distanceToSegment, intersectPolygonAndHalfPlane } from '../model/interesection';
+import { LineToolParallelChannelOptions } from '../model/line-tool-options';
+import { equalPoints, halfPlaneThroughPoint, lineThroughPoints, Point, Segment } from '../model/point';
+
+import { LineStyle } from '..';
+import { drawLine, extendAndClipLineSegment, setLineStyle } from './draw-line';
+import { AnchorPoint } from './line-anchor-renderer';
+import { ScaledRenderer } from './scaled-renderer';
+
+export type ParallelChannelRendererData = DeepPartial<LineToolParallelChannelOptions> & { points: AnchorPoint[]; hitTestBackground?: boolean };
+
+export class ParallelChannelRenderer extends ScaledRenderer {
+	protected _backHitTest: HitTestResult<void>;
+	protected _hitTest: HitTestResult<void>;
+	protected _data: ParallelChannelRendererData | null;
+	
+	private _cssHeight: number = 1000;
+	private _cssWidth: number = 1000;
+
+	public constructor(hitTest?: HitTestResult<void>, backHitTest?: HitTestResult<void>) {
+		super();
+		this._backHitTest = backHitTest || new HitTestResult(HitTestType.MovePointBackground);
+		this._hitTest = hitTest || new HitTestResult(HitTestType.MovePoint);
+		this._data = null;
+	}
+
+	public setData(data: ParallelChannelRendererData): void {
+		this._data = data;
+	}
+
+	public hitTest(x: Coordinate, y: Coordinate): HitTestResult<void> | null {
+		if (this._data === null || this._data.points.length < 2) { return null; }
+		const [end0, end1] = this._data.points;
+		const point = new Point(x, y);
+		const firsLineHitResult = this._extendAndHitTestLineSegment(point, end0, end1);
+		if (firsLineHitResult !== null) { return firsLineHitResult; }
+		if (this._data.points.length === 4) {
+			const [,, end2, end3] = this._data.points;
+			const secondLineHitResult = this._extendAndHitTestLineSegment(point, end2, end3);
+			if (null !== secondLineHitResult) { return secondLineHitResult; }
+			if (this._data.showMiddleLine) {
+				const end4 = end0.add(end2).scaled(0.5);
+				const end5 = end1.add(end3).scaled(0.5);
+				const middleLineHitResult = this._extendAndHitTestLineSegment(point, end4, end5);
+				if (null !== middleLineHitResult) { return middleLineHitResult; }
+			}
+		}
+		return this._data.hitTestBackground ? this._hitTestBackground(point) : null;
+	}
+
+	protected _drawImpl(ctx: CanvasRenderingContext2D): void {
+		if (null === this._data || this._data.points.length < 2) { return; }
+		setLineStyle(ctx, this._data.channelLine?.style || LineStyle.Solid);
+		ctx.strokeStyle = this._data.channelLine?.color || 'transparent';
+		ctx.lineWidth = this._data.channelLine?.width || 0;
+		ctx.lineCap = 'butt';
+		this._cssWidth = ctx.canvas.width;
+		this._cssHeight = ctx.canvas.height;
+
+		const [end0, end1] = this._data.points;
+		this._extendAndDrawLineSegment(ctx, end0, end1);
+
+		if (this._data.points.length === 4) {
+			const [,, end2, end3] = this._data.points;
+			this._extendAndDrawLineSegment(ctx, end2, end3);
+			this._drawBackground(ctx, this._data.points,);
+
+			if (this._data.showMiddleLine) {
+				setLineStyle(ctx, this._data.middleLine?.style || LineStyle.Solid);
+				ctx.strokeStyle = this._data.middleLine?.color || 'transparent';
+				ctx.lineWidth = this._data.middleLine?.width || 0;
+				const end4 = end0.add(end2).scaled(0.5);
+				const end5 = end1.add(end3).scaled(0.5);
+				this._extendAndDrawLineSegment(ctx, end4, end5);
+			}
+		}
+	}
+
+	protected _extendAndDrawLineSegment(ctx: CanvasRenderingContext2D, end0: Point, end1: Point): void {
+		const line = this._extendAndClipLineSegment(end0, end1);
+		if (line !== null) { drawLine(ctx, line[0].x, line[0].y, line[1].x, line[1].y); }
+	}
+
+	protected _extendAndHitTestLineSegment(point: Point, end0: Point, end1: Point): HitTestResult<void> | null {
+		const line = this._extendAndClipLineSegment(end0, end1);
+		if (line !== null && distanceToSegment(line[0], line[1], point).distance <= 3) { return this._hitTest; }
+		return null;
+	}
+
+	protected _extendAndClipLineSegment(end0: Point, end1: Point): Segment | null {
+		const data = ensureNotNull(this._data);
+		const cssWidth = this._cssWidth;
+		const cssHeight = this._cssHeight;
+		return extendAndClipLineSegment(end0, end1, cssWidth, cssHeight, !!data.extend?.left, !!data.extend?.right);
+	}
+
+	protected _drawBackground(ctx: CanvasRenderingContext2D, points: Point[]): void {
+		const data = ensureNotNull(this._data);
+		const [end0, end1, end2, end3] = points;
+		const cssWidth = ctx.canvas.width;
+		const cssHeight = ctx.canvas.height;
+
+		if (equalPoints(end0, end1) || equalPoints(end2, end3)) { return; }
+		if (cssWidth <= 0 || cssHeight <= 0) { return; }
+		if (distanceToLine(end0, end1, end2).distance < 1e-6 || distanceToLine(end0, end1, end3).distance < 1e-6) { return; }
+
+		let computedPoints: Point[] | null = [new Point(0, 0), new Point(cssWidth, 0), new Point(cssWidth, cssHeight), new Point(0, cssHeight)];
+		computedPoints = this._computePoints(computedPoints, end0, end1, end3);
+		if (!data.extend?.right) { computedPoints = this._computePoints(computedPoints, end1, end3, end2); }
+		computedPoints = this._computePoints(computedPoints, end3, end2, end0);
+		if (!data.extend?.left) { computedPoints = this._computePoints(computedPoints, end2, end0, end1);}
+
+		if (computedPoints !== null) {
+			ctx.beginPath();
+			ctx.moveTo(computedPoints[0].x, computedPoints[0].y);
+
+			for (let e = 1; e < computedPoints.length; e++) {
+				ctx.lineTo(computedPoints[e].x, computedPoints[e].y);
+			}
+
+			ctx.fillStyle = this._data?.background?.color || 'transparent';
+			if (this._data?.background?.color) { ctx.fill(); }
+		}
+	}
+
+	protected _hitTestBackground(point: Point): HitTestResult<void> | null {
+		const data = ensureNotNull(this._data);
+		if (data.points.length !== 4) { return null; }
+		const [end0, end1, end2] = data.points;
+		const l = (end1.y - end0.y) / (end1.x - end0.x);
+		const pointLine1Y = end2.y + l * (point.x - end2.x);
+		const pointLine0Y = end0.y + l * (point.x - end0.x);
+		const bottom = Math.max(pointLine0Y, pointLine1Y);
+		const top = Math.min(pointLine0Y, pointLine1Y);
+		const maxX = Math.max(end0.x, end1.x);
+		const minX = Math.min(end0.x, end1.x);
+
+		if (!data.extend?.left && point.x < minX || !data.extend?.right && point.x > maxX) { return null; }
+		return point.y >= top && point.y <= bottom ? this._backHitTest : null;
+	}
+
+	protected _computePoints(points: Point[] | null, end0: Point, end1: Point, end2: Point): Point[] | null {
+		return points !== null ? intersectPolygonAndHalfPlane(points, halfPlaneThroughPoint(lineThroughPoints(end0, end1), end2)) : null;
+	}
+}
diff --git a/src/renderers/polygon-renderer.ts b/src/renderers/polygon-renderer.ts
new file mode 100644
index 0000000..78fce42
--- /dev/null
+++ b/src/renderers/polygon-renderer.ts
@@ -0,0 +1,126 @@
+// import { CanvasRenderParams } from '../model/canvas-render-params';
+import { Coordinate } from '../model/coordinate';
+import { HitTestResult, HitTestType } from '../model/hit-test-result';
+import { distanceToSegment, pointInCircle, pointInPolygon } from '../model/interesection';
+import { BackroundOptions, LineCap, LineJoin, LineOptions } from '../model/line-tool-options';
+import { Point } from '../model/point';
+
+import { LineEnd, LineStyle } from '..';
+import { drawArrowEnd, setLineStyle } from './draw-line';
+import { AnchorPoint } from './line-anchor-renderer';
+import { interactionTolerance } from './optimal-bar-width';
+import { ScaledRenderer } from './scaled-renderer';
+
+export interface PolygonRendererData {
+	points: AnchorPoint[];
+	line: Partial<Omit<LineOptions, 'extend'>>;
+	background?: Omit<BackroundOptions, 'inflation'>;
+}
+
+export class PolygonRenderer extends ScaledRenderer {
+	protected _data: PolygonRendererData | null;
+	protected _backHitTest: HitTestResult<void>;
+	protected _hitTest: HitTestResult<void>;
+
+	public constructor(hitTest?: HitTestResult<void>) {
+		super();
+		this._backHitTest = new HitTestResult(HitTestType.MovePointBackground);
+		this._hitTest = hitTest || new HitTestResult(HitTestType.MovePoint);
+		this._data = null;
+	}
+
+	public setData(data: PolygonRendererData): void {
+		this._data = data;
+	}
+
+	public hitTest(x: Coordinate, y: Coordinate): HitTestResult<void> | null {
+		if (this._data === null) { return null; }
+		const lineWidth = this._data.line.width || 1;
+
+		const point = new Point(x, y);
+		const distance = Math.max(interactionTolerance.line, Math.ceil(lineWidth / 2));
+		const pointsCount = this._data.points.length;
+
+		if (pointsCount === 1) {
+			return pointInCircle(point, this._data.points[0], distance) ? this._hitTest : null;
+		}
+
+		for (let n = 1; n < pointsCount; n++) {
+			if (distanceToSegment(this._data.points[n - 1], this._data.points[n], point).distance <= distance) {
+				return this._hitTest;
+			}
+		}
+
+		if (this._data.background && pointsCount > 0) {
+			if (distanceToSegment(this._data.points[0], this._data.points[pointsCount - 1], point).distance <= distance) {
+				return this._hitTest;
+			}
+		}
+
+		return this._data.background && pointInPolygon(point, this._data.points) ? this._backHitTest : null;
+	}
+
+	// eslint-disable-next-line complexity
+	protected _drawImpl(ctx: CanvasRenderingContext2D, isHovered: boolean, hitTestData?: unknown): void {
+		if (this._data === null || !this._data.points || !this._data.points.length) { return; }
+
+		const pointsCount = this._data.points.length;
+		const lineStyle = this._data.line.style || LineStyle.Solid;
+		const lineJoin = this._data.line.join || LineJoin.Round;
+		const lineCap = this._data.line.cap || LineCap.Butt;
+		const lineColor = this._data.line.color || 'white';
+		const lineWidth = this._data.line.width || 1;
+
+		if (pointsCount === 1) { return this._drawPoint(ctx, this._data.points[0], pointsCount / 2, lineColor); }
+
+		ctx.beginPath();
+		ctx.lineCap = lineCap;
+		ctx.lineJoin = lineJoin;
+		ctx.lineWidth = lineWidth;
+		ctx.strokeStyle = lineColor;
+		setLineStyle(ctx, lineStyle);
+
+		ctx.moveTo(this._data.points[0].x, this._data.points[0].y);
+		for (const e of this._data.points) {
+			ctx.lineTo(e.x, e.y);
+		}
+
+		if (this._data.background) {
+			ctx.fillStyle = this._data.background.color;
+			ctx.fill();
+		}
+
+		if (lineWidth > 0) { ctx.stroke(); }
+
+		if (pointsCount > 1) {
+			if (lineCap !== 'butt') { ctx.lineCap = 'butt'; }
+
+			if (this._data.line.end?.left === LineEnd.Arrow) {
+				const points = this._correctArrowPoints(this._data.points[1], this._data.points[0], lineWidth, lineCap);
+				drawArrowEnd(points[0], points[1], ctx, lineWidth, 1);
+			}
+			if (this._data.line.end?.right === LineEnd.Arrow) {
+				const points = this._correctArrowPoints(this._data.points[pointsCount - 2], this._data.points[pointsCount - 1], lineWidth, lineCap);
+				drawArrowEnd(points[0], points[1], ctx, lineWidth, 1);
+			}
+		}
+	}
+
+	protected _drawPoint(ctx: CanvasRenderingContext2D, point: Point, lineWidth: number, color: string): void {
+		if (lineWidth !== 0) { return; }
+		ctx.beginPath();
+		ctx.fillStyle = color;
+		ctx.arc(point.x, point.y, lineWidth, 0, 2 * Math.PI, true);
+		ctx.fill();
+		ctx.closePath();
+	}
+
+	protected _correctArrowPoints(point0: Point, point1: Point, lineWidth: number, lineCap: LineCap): Point[] {
+		const heading = point1.subtract(point0);
+		const distance = heading.length();
+		if ('butt' === lineCap || distance < 1) { return [point0, point1]; }
+
+		const correctedDistance = distance + lineWidth / 2;
+		return [point0, heading.scaled(correctedDistance / distance).add(point0)];
+	}
+}
diff --git a/src/renderers/price-axis-background-renderer.ts b/src/renderers/price-axis-background-renderer.ts
new file mode 100644
index 0000000..522edba
--- /dev/null
+++ b/src/renderers/price-axis-background-renderer.ts
@@ -0,0 +1,43 @@
+import { drawScaled } from '../helpers/canvas-helpers';
+
+import { /*IPriceAxisViewRenderer, PriceAxisViewRendererCommonData,*/ PriceAxisViewRendererOptions } from './iprice-axis-view-renderer';
+
+export interface PriceAxisBackgroundRendererData {
+	coordinate: number;
+	color: string;
+	height: number;
+	visible: boolean;
+}
+
+export class PriceAxisBackgroundRenderer {
+	private _data: PriceAxisBackgroundRendererData | null;
+	//private _commonData: PriceAxisViewRendererCommonData | null;
+
+	public constructor() {
+		this._data = null;
+		//this._commonData = null;
+	}
+
+	public setData(data: PriceAxisBackgroundRendererData/*, commonData: PriceAxisViewRendererCommonData*/): void {
+		this._data = data;
+		//this._commonData = commonData;
+	}
+
+	public drawBackground(ctx: CanvasRenderingContext2D, rendererOptions: PriceAxisViewRendererOptions, pixelRatio: number): void {
+		if (this._data === null || this._data.visible === false) {
+			return;
+		}
+
+		const { coordinate: y, height, color } = this._data;
+		const width = ctx.canvas.clientWidth;
+
+		drawScaled(ctx, pixelRatio, () => {
+			ctx.fillStyle = color;
+			ctx.fillRect(0, y, width, height);
+		});		
+		
+		// if (this._commonData === null) {
+			// return;
+		// }
+	}
+}
diff --git a/src/renderers/rectangle-renderer.ts b/src/renderers/rectangle-renderer.ts
new file mode 100644
index 0000000..518f362
--- /dev/null
+++ b/src/renderers/rectangle-renderer.ts
@@ -0,0 +1,112 @@
+import { ensureNotNull } from '../helpers/assertions';
+import { DeepPartial } from '../helpers/strict-type-checks';
+
+import { Coordinate } from '../model/coordinate';
+import { HitTestResult, HitTestType } from '../model/hit-test-result';
+import { distanceToSegment, pointInBox } from '../model/interesection';
+import { RectangleOptions } from '../model/line-tool-options';
+import { Box, equalPoints, Point, Segment } from '../model/point';
+
+import { LineStyle } from '..';
+import { fillRectWithBorder } from './draw-rect';
+import { IPaneRenderer } from './ipane-renderer';
+import { AnchorPoint } from './line-anchor-renderer';
+
+export type RectangleRendererData = DeepPartial<RectangleOptions> & { points: AnchorPoint[]; hitTestBackground?: boolean };
+
+export class RectangleRenderer implements IPaneRenderer {
+	protected _backHitTest: HitTestResult<void>;
+	protected _hitTest: HitTestResult<void>;
+	protected _data: RectangleRendererData | null;
+
+	public constructor(hitTest?: HitTestResult<void>, backHitTest?: HitTestResult<void>) {
+		this._backHitTest = backHitTest || new HitTestResult(HitTestType.MovePointBackground);
+		this._hitTest = hitTest || new HitTestResult(HitTestType.MovePoint);
+		this._data = null;
+	}
+
+	public setData(data: RectangleRendererData): void {
+		this._data = data;
+	}
+
+	public hitTest(x: Coordinate, y: Coordinate, ctx: CanvasRenderingContext2D): HitTestResult<void> | null {
+		if (null === this._data || this._data.points.length < 2) { return null; }
+		const pixelRatio = ctx.canvas.ownerDocument && ctx.canvas.ownerDocument.defaultView && ctx.canvas.ownerDocument.defaultView.devicePixelRatio || 1;
+		const physicalWidth = ctx.canvas.width;
+		const scaledPoint = new Point(x, y);
+		const [topLeft, bottomRight] = this._getPointsInPhysicalSpace(pixelRatio);
+		const topRight = new Point(bottomRight.x, topLeft.y);
+		const bottomLeft = new Point(topLeft.x, bottomRight.y);
+
+		const topLineHitResult = this._extendAndHitTestLineSegment(scaledPoint, topLeft, topRight, physicalWidth);
+		if (topLineHitResult !== null) { return topLineHitResult; }
+
+		const bottomLineHitResult = this._extendAndHitTestLineSegment(scaledPoint, bottomLeft, bottomRight, physicalWidth);
+		if (bottomLineHitResult !== null) { return bottomLineHitResult; }
+
+		const rightSegmentDistance = distanceToSegment(topRight, bottomRight, scaledPoint);
+		if (rightSegmentDistance.distance <= 3) { return this._hitTest; }
+
+		const leftSegmentDistance = distanceToSegment(topLeft, bottomLeft, scaledPoint);
+		if (leftSegmentDistance.distance <= 3) { return this._hitTest; }
+
+		const backgroundHitResult = this._hitTestBackground(scaledPoint, topLeft, bottomRight, physicalWidth);
+		if (this._data.hitTestBackground && backgroundHitResult !== null) { return backgroundHitResult; }
+
+		return null;
+	}
+
+	public draw(ctx: CanvasRenderingContext2D, pixelRatio: number, isHovered: boolean, hitTestData?: unknown): void {
+		const borderWidth = this._data?.border?.width || 0;
+		const borderColor = this._data?.border?.color;
+		const background = this._data?.background?.color;
+
+		if (null === this._data || this._data.points.length < 2 || (borderWidth <= 0 && !background)) { return; }
+
+		ctx.save();
+		const scaledBorderWidth = borderWidth ? Math.max(1, Math.floor(borderWidth * pixelRatio)) : 0;
+		const borderStyle = this._data.border?.style || LineStyle.Solid;
+		const [point0, point1] = this._getPointsInPhysicalSpace(pixelRatio);
+		const { left, right } = this._data.extend || {};
+
+		const physicalWidth = ctx.canvas.width;
+		fillRectWithBorder(ctx, point0, point1, background, borderColor, scaledBorderWidth, borderStyle, 'center', !!left, !!right, physicalWidth);
+		ctx.restore();
+	}
+
+	protected _getPointsInPhysicalSpace(pixelRatio: number): Segment {
+		const data = ensureNotNull(this._data);
+		const [point0, point1] = data.points;
+		const minX = Math.min(point0.x, point1.x);
+		const maxX = Math.max(point0.x, point1.x);
+		const minY = Math.min(point0.y, point1.y);
+		const maxY = Math.max(point0.y, point1.y);
+		const scaledMinX = Math.round(minX * pixelRatio);
+		const scaledMax = Math.round(maxX * pixelRatio);
+		const scaledMinY = Math.round(minY * pixelRatio);
+		const scaledMaxY = Math.round(maxY * pixelRatio);
+		return [new Point(scaledMinX, scaledMinY), new Point(scaledMax, scaledMaxY)];
+	}
+
+	protected _extendAndClipLineSegment(end0: Point, end1: Point, physicalWidth: number): Segment | null {
+		const data = ensureNotNull(this._data);
+		if (equalPoints(end0, end1)) { return null; }
+
+		const minX = Math.min(end0.x, end1.x);
+		const maxX = Math.max(end0.x, end1.x);
+		const x1 = data.extend?.left ? 0 : Math.max(minX, 0);
+		const x2 = data.extend?.right ? physicalWidth : Math.min(maxX, physicalWidth);
+		return x1 > x2 || x2 <= 0 || x1 >= physicalWidth ? null : [new Point(x1, end0.y), new Point(x2, end1.y)];
+	}
+
+	protected _extendAndHitTestLineSegment(point: Point, end0: Point, end1: Point, physicalWidth: number): HitTestResult<void> | null {
+		const line = this._extendAndClipLineSegment(end0, end1, physicalWidth);
+		if (line !== null && distanceToSegment(line[0], line[1], point).distance <= 3) { return this._hitTest; }
+		return null;
+	}
+
+	protected _hitTestBackground(point: Point, end0: Point, end1: Point, physicalWidth: number): HitTestResult<void> | null {
+		const line = this._extendAndClipLineSegment(end0, end1, physicalWidth);
+		return line !== null && pointInBox(point, new Box(line[0], line[1])) ? this._backHitTest : null;
+	}
+}
diff --git a/src/renderers/segment-renderer.ts b/src/renderers/segment-renderer.ts
new file mode 100644
index 0000000..431ca6d
--- /dev/null
+++ b/src/renderers/segment-renderer.ts
@@ -0,0 +1,106 @@
+import { ensureNotNull } from '../helpers/assertions';
+import { DeepPartial } from '../helpers/strict-type-checks';
+
+import { Coordinate } from '../model/coordinate';
+import { HitTestResult, HitTestType } from '../model/hit-test-result';
+import { distanceToSegment } from '../model/interesection';
+import { LineOptions } from '../model/line-tool-options';
+import { Point } from '../model/point';
+
+import { LineStyle } from '..';
+import { drawArrowEnd, drawCircleEnd, drawHorizontalLine, drawLine, drawVerticalLine, extendAndClipLineSegment, LineEnd, setLineStyle } from './draw-line';
+import { IPaneRenderer } from './ipane-renderer';
+import { AnchorPoint } from './line-anchor-renderer';
+import { interactionTolerance } from './optimal-bar-width';
+
+export interface SegmentRendererData {
+	line: DeepPartial<Omit<LineOptions, 'join' | 'cap'>>;
+	points: AnchorPoint[];
+}
+
+export class SegmentRenderer implements IPaneRenderer {
+	protected _hitTest: HitTestResult<void>;
+	protected _data: SegmentRendererData | null;
+
+	private _cssHeight: number = 1000;
+	private _cssWidth: number = 1000;
+	
+	public constructor() {
+		this._data = null;
+		this._hitTest = new HitTestResult(HitTestType.MovePoint);
+	}
+
+	public setData(data: SegmentRendererData): void {
+		this._data = data;
+	}
+
+	public setHitTest(hitTest: HitTestResult<void>): void {
+		this._hitTest = hitTest;
+	}
+
+	public draw(ctx: CanvasRenderingContext2D, pixelRatio: number, isHovered: boolean, hitTestData?: unknown): void {
+		if (!this._data || this._data.points.length < 2) { return; }
+
+		this._cssWidth = ctx.canvas.width;
+		this._cssHeight = ctx.canvas.height;
+		
+		const lineWidth = this._data.line.width || 1;
+		const lineColor = this._data.line.color || 'white';
+		const lineStyle = this._data.line.style || LineStyle.Solid;
+
+		ctx.lineCap = 'butt';
+		ctx.strokeStyle = lineColor;
+		ctx.lineWidth = Math.max(1, Math.floor(lineWidth * pixelRatio));
+
+		setLineStyle(ctx, lineStyle);
+		const point0 = this._data.points[0];
+		const point1 = this._data.points[1];
+
+		this._drawEnds(ctx, [point0, point1], lineWidth, pixelRatio);
+		const line = this._extendAndClipLineSegment(point0, point1);
+
+		if (line !== null && lineWidth > 0) {
+			if (line[0].x === line[1].x) {
+				drawVerticalLine(ctx, Math.round(line[0].x * pixelRatio), line[0].y * pixelRatio, line[1].y * pixelRatio);
+			} else if (line[0].y === line[1].y) {
+				drawHorizontalLine(ctx, Math.round(line[0].y * pixelRatio), line[0].x * pixelRatio, line[1].x * pixelRatio);
+			} else {
+				drawLine(ctx, line[0].x * pixelRatio, line[0].y * pixelRatio, line[1].x * pixelRatio, line[1].y * pixelRatio);
+			}
+		}
+	}
+
+	public hitTest(x: Coordinate, y: Coordinate): HitTestResult<void> | null {
+		if (this._data === null || this._data.points.length < 2) { return null; }
+
+		const tolerance = interactionTolerance.line;
+		const line = this._extendAndClipLineSegment(this._data.points[0], this._data.points[1]);
+		if (null !== line && distanceToSegment(line[0], line[1], new Point(x,y)).distance <= tolerance) { return this._hitTest; }
+		return null;
+	}
+
+	private _extendAndClipLineSegment(end0: Point, end1: Point): Point[] | null {
+		const data = ensureNotNull(this._data);
+		const cssWidth = this._cssWidth;
+		const cssHeight = this._cssHeight;
+		return extendAndClipLineSegment(end0, end1, cssWidth, cssHeight, !!data.line.extend?.left, !!data.line.extend?.right);
+	}
+
+	private _drawEnds(ctx: CanvasRenderingContext2D, points: Point[], width: number, pixelRatio: number): void {
+		const data = ensureNotNull(this._data);
+		switch (data.line.end?.left) {
+			case LineEnd.Arrow:
+				drawArrowEnd(points[1], points[0], ctx, width, pixelRatio);
+				break;
+			case LineEnd.Circle:
+				drawCircleEnd(points[0], ctx, width, pixelRatio);
+		}
+		switch (data.line.end?.right) {
+			case LineEnd.Arrow:
+				drawArrowEnd(points[0], points[1], ctx, width, pixelRatio);
+				break;
+			case LineEnd.Circle:
+				drawCircleEnd(points[1], ctx, width, pixelRatio);
+		}
+	}
+}
diff --git a/src/renderers/series-markers-renderer.ts b/src/renderers/series-markers-renderer.ts
index a3d7d12..90a5872 100644
--- a/src/renderers/series-markers-renderer.ts
+++ b/src/renderers/series-markers-renderer.ts
@@ -1,17 +1,18 @@
 import { ensureNever } from '../helpers/assertions';
 import { makeFont } from '../helpers/make-font';
 
-import { HoveredObject } from '../model/chart-model';
 import { Coordinate } from '../model/coordinate';
-import { SeriesMarkerShape } from '../model/series-markers';
+import { HitTestResult } from '../model/hit-test-result';
+import { SeriesMarkerAnchor, SeriesMarkerShape, SeriesMarkerStroke } from '../model/series-markers';
 import { TextWidthCache } from '../model/text-width-cache';
 import { SeriesItemsIndexesRange, TimedValue } from '../model/time-data';
 
 import { ScaledRenderer } from './scaled-renderer';
-import { drawArrow, hitTestArrow } from './series-markers-arrow';
-import { drawCircle, hitTestCircle } from './series-markers-circle';
-import { drawSquare, hitTestSquare } from './series-markers-square';
-import { drawText, hitTestText } from './series-markers-text';
+import { drawArrow } from './series-markers-arrow';
+import { drawCircle } from './series-markers-circle';
+import { drawSquare } from './series-markers-square';
+import { drawText } from './series-markers-text';
+import { drawTriangle } from './series-markers-triangle';
 
 export interface SeriesMarkerText {
 	content: string;
@@ -24,6 +25,9 @@ export interface SeriesMarkerRendererDataItem extends TimedValue {
 	y: Coordinate;
 	size: number;
 	shape: SeriesMarkerShape;
+	stroke?: SeriesMarkerStroke;
+	anchor?: SeriesMarkerAnchor;
+	rotation?: number;
 	color: string;
 	internalId: number;
 	externalId?: string;
@@ -55,20 +59,20 @@ export class SeriesMarkersRenderer extends ScaledRenderer {
 		}
 	}
 
-	public hitTest(x: Coordinate, y: Coordinate): HoveredObject | null {
-		if (this._data === null || this._data.visibleRange === null) {
-			return null;
-		}
-
-		for (let i = this._data.visibleRange.from; i < this._data.visibleRange.to; i++) {
-			const item = this._data.items[i];
-			if (hitTestItem(item, x, y)) {
-				return {
-					hitTestData: item.internalId,
-					externalId: item.externalId,
-				};
-			}
-		}
+	public hitTest(x: Coordinate, y: Coordinate): HitTestResult<void> | null {
+		// if (this._data === null || this._data.visibleRange === null) {
+			// return null;
+		// }
+
+		// for (let i = this._data.visibleRange.from; i < this._data.visibleRange.to; i++) {
+			// const item = this._data.items[i];
+			// if (hitTestItem(item, x, y)) {
+				// return {
+					// hitTestData: item.internalId,
+					// externalId: item.externalId,
+				// };
+			// }
+		// }
 
 		return null;
 	}
@@ -93,13 +97,27 @@ export class SeriesMarkersRenderer extends ScaledRenderer {
 }
 
 function drawItem(item: SeriesMarkerRendererDataItem, ctx: CanvasRenderingContext2D): void {
+	const rotation = item.rotation || (item.anchor === 'bottom' ? 180 : item.anchor === 'right' ? 90 : item.anchor === 'left' ? -90 : 0);
+	ctx.strokeStyle = item.stroke?.color || 'transparent';
+	ctx.lineWidth = item.stroke?.width || 1;
 	ctx.fillStyle = item.color;
 
 	if (item.text !== undefined) {
 		drawText(ctx, item.text.content, item.x - item.text.width / 2, item.text.y);
 	}
 
+	if (rotation) {
+		ctx.save();
+		ctx.translate(item.x, item.y);
+		ctx.rotate(rotation * (Math.PI / 180));
+		ctx.translate(-item.x, -item.y);
+	}
+
 	drawShape(item, ctx);
+
+	if (rotation) {
+		ctx.restore();
+	}
 }
 
 function drawShape(item: SeriesMarkerRendererDataItem, ctx: CanvasRenderingContext2D): void {
@@ -108,6 +126,9 @@ function drawShape(item: SeriesMarkerRendererDataItem, ctx: CanvasRenderingConte
 	}
 
 	switch (item.shape) {
+		case 'triangle':
+			drawTriangle(ctx, item.x, item.y, item.size);
+			return;
 		case 'arrowDown':
 			drawArrow(false, ctx, item.x, item.y, item.size);
 			return;
@@ -125,27 +146,27 @@ function drawShape(item: SeriesMarkerRendererDataItem, ctx: CanvasRenderingConte
 	ensureNever(item.shape);
 }
 
-function hitTestItem(item: SeriesMarkerRendererDataItem, x: Coordinate, y: Coordinate): boolean {
-	if (item.text !== undefined && hitTestText(item.x, item.text.y, item.text.width, item.text.height, x, y)) {
-		return true;
-	}
-
-	return hitTestShape(item, x, y);
-}
-
-function hitTestShape(item: SeriesMarkerRendererDataItem, x: Coordinate, y: Coordinate): boolean {
-	if (item.size === 0) {
-		return false;
-	}
-
-	switch (item.shape) {
-		case 'arrowDown':
-			return hitTestArrow(true, item.x, item.y, item.size, x, y);
-		case 'arrowUp':
-			return hitTestArrow(false, item.x, item.y, item.size, x, y);
-		case 'circle':
-			return hitTestCircle(item.x, item.y, item.size, x, y);
-		case 'square':
-			return hitTestSquare(item.x, item.y, item.size, x, y);
-	}
-}
+// function hitTestItem(item: SeriesMarkerRendererDataItem, x: Coordinate, y: Coordinate): boolean {
+	// if (item.text !== undefined && hitTestText(item.x, item.text.y, item.text.width, item.text.height, x, y)) {
+		// return true;
+	// }
+
+	// return hitTestShape(item, x, y);
+// }
+
+// function hitTestShape(item: SeriesMarkerRendererDataItem, x: Coordinate, y: Coordinate): boolean {
+	// if (item.size === 0) {
+		// return false;
+	// }
+
+	// switch (item.shape) {
+		// case 'arrowDown':
+			// return hitTestArrow(true, item.x, item.y, item.size, x, y);
+		// case 'arrowUp':
+			// return hitTestArrow(false, item.x, item.y, item.size, x, y);
+		// case 'circle':
+			// return hitTestCircle(item.x, item.y, item.size, x, y);
+		// case 'square':
+			// return hitTestSquare(item.x, item.y, item.size, x, y);
+	// }
+// }
diff --git a/src/renderers/series-markers-triangle.ts b/src/renderers/series-markers-triangle.ts
new file mode 100644
index 0000000..c559736
--- /dev/null
+++ b/src/renderers/series-markers-triangle.ts
@@ -0,0 +1,20 @@
+import { Coordinate } from '../model/coordinate';
+
+import { hitTestSquare } from './series-markers-square';
+
+export function drawTriangle(ctx: CanvasRenderingContext2D, centerX: Coordinate, centerY: Coordinate, size: number): void {
+	const halfArrowSize = size / 2;
+
+	ctx.beginPath();
+	ctx.moveTo(centerX, centerY - halfArrowSize);
+	ctx.lineTo(centerX + halfArrowSize, centerY + halfArrowSize);
+	ctx.lineTo(centerX - halfArrowSize, centerY + halfArrowSize);
+
+	ctx.closePath();
+	ctx.fill();
+	ctx.stroke();
+}
+
+export function hitTestTriangle(centerX: Coordinate, centerY: Coordinate, size: number, x: Coordinate, y: Coordinate): boolean {
+	return hitTestSquare(centerX, centerY, size, x, y);
+}
diff --git a/src/renderers/series-markers-utils.ts b/src/renderers/series-markers-utils.ts
index ae2a22b..b9cee66 100644
--- a/src/renderers/series-markers-utils.ts
+++ b/src/renderers/series-markers-utils.ts
@@ -17,6 +17,7 @@ export function shapeSize(shape: SeriesMarkerShape, originalSize: number): numbe
 	switch (shape) {
 		case 'arrowDown':
 		case 'arrowUp':
+		case 'triangle':
 			return size(originalSize, 1);
 		case 'circle':
 			return size(originalSize, 0.8);
diff --git a/src/renderers/text-renderer.ts b/src/renderers/text-renderer.ts
new file mode 100644
index 0000000..18c575e
--- /dev/null
+++ b/src/renderers/text-renderer.ts
@@ -0,0 +1,561 @@
+import { ensureDefined, ensureNotNull } from '../helpers/assertions';
+import { drawScaled } from '../helpers/canvas-helpers';
+import { DeepPartial } from '../helpers/strict-type-checks';
+
+import { Coordinate } from '../model/coordinate';
+import { HitTestResult, HitTestType } from '../model/hit-test-result';
+import { pointInBox, pointInPolygon } from '../model/interesection';
+import { BoxHorizontalAlignment, BoxVerticalAlignment, TextAlignment, TextOptions } from '../model/line-tool-options';
+import { Box, Point, Rect } from '../model/point';
+
+import { drawRoundRect } from './draw-rect';
+import { IPaneRenderer } from './ipane-renderer';
+
+interface LinesInfo {
+	lines: string[];
+	linesMaxWidth: number;
+}
+
+interface FontInfo {
+	fontSize: number;
+	fontStyle: string;
+}
+
+interface BoxSize {
+	width: number;
+	height: number;
+}
+
+interface InternalData {
+	boxLeft: number;
+	boxTop: number;
+	boxWidth: number;
+	boxHeight: number;
+	textStart: number;
+	textTop: number;
+	textAlign: TextAlignment;
+}
+
+export interface TextRendererData {
+	text: DeepPartial<TextOptions>;
+	points?: Point[];
+}
+
+export class TextRenderer implements IPaneRenderer {
+	protected _internalData: InternalData | null = null;
+	protected _polygonPoints: Point[] | null = null;
+	protected _linesInfo: LinesInfo | null = null;
+	protected _fontInfo: FontInfo | null = null;
+	protected _boxSize: BoxSize | null = null;
+	protected _data: TextRendererData | null = null;
+
+	protected _hitTest: HitTestResult<void>;
+
+	public constructor(data?: TextRendererData, hitTest?: HitTestResult<void>) {
+		this._hitTest = hitTest || new HitTestResult(HitTestType.MovePoint);
+		if (data !== undefined) { this.setData(data); }
+	}
+
+	public setData(data: TextRendererData): void {
+		// eslint-disable-next-line complexity
+		function checkUnchanged(before: TextRendererData | null, after: TextRendererData | null): boolean {
+			if (null === before || null === after) { return null === before === (null === after);}
+			if (before.points === undefined !== (after.points === undefined)) { return false; }
+
+			if (before.points !== undefined && after.points !== undefined) {
+				if (before.points.length !== after.points.length) { return false; }
+
+				for (let i = 0; i < before.points.length; ++i) {
+					if (before.points[i].x !== after.points[i].x || before.points[i].y !== after.points[i].y) { return false; }
+				}
+			}
+
+			return before.text?.forceCalculateMaxLineWidth === after.text?.forceCalculateMaxLineWidth
+                && before.text?.forceTextAlign === after.text?.forceTextAlign
+                && before.text?.wordWrapWidth === after.text?.wordWrapWidth
+                && before.text?.padding === after.text?.padding
+                && before.text?.value === after.text?.value
+                && before.text?.alignment === after.text?.alignment
+                && before.text?.font?.bold === after.text?.font?.bold
+                && before.text?.font?.size === after.text?.font?.size
+                && before.text?.font?.family === after.text?.font?.family
+                && before.text?.font?.italic === after.text?.font?.italic
+                && before.text?.box?.angle === after.text?.box?.angle
+                && before.text?.box?.scale === after.text?.box?.scale
+                && before.text?.box?.offset?.x === after.text?.box?.offset?.x
+                && before.text?.box?.offset?.y === after.text?.box?.offset?.y
+                && before.text?.box?.maxHeight === after.text?.box?.maxHeight
+                && before.text?.box?.padding?.x === after.text?.box?.padding?.x
+                && before.text?.box?.padding?.y === after.text?.box?.padding?.y
+                && before.text?.box?.alignment?.vertical === after.text?.box?.alignment?.vertical
+                && before.text?.box?.alignment?.horizontal === after.text?.box?.alignment?.horizontal
+                && before.text?.box?.background?.inflation?.x === after.text?.box?.background?.inflation?.x
+                && before.text?.box?.background?.inflation?.y === after.text?.box?.background?.inflation?.y
+                && before.text?.box?.border?.highlight === after.text?.box?.border?.highlight
+                && before.text?.box?.border?.radius === after.text?.box?.border?.radius
+                && before.text?.box?.shadow?.offset === after.text?.box?.shadow?.offset
+                && before.text?.box?.shadow?.color === after.text?.box?.shadow?.color
+                && before.text?.box?.shadow?.blur === after.text?.box?.shadow?.blur;
+		}
+
+		if (checkUnchanged(this._data, data)) {
+			this._data = data;
+		} else {
+			this._data = data;
+			this._polygonPoints = null;
+			this._internalData = null;
+			this._linesInfo = null;
+			this._fontInfo = null;
+			this._boxSize = null;
+		}
+	}
+
+	public hitTest(x: Coordinate, y: Coordinate): HitTestResult<void> | null {
+		if (this._data === null || this._data.points === undefined || this._data.points.length === 0) {
+			return null;
+		} else if (pointInPolygon(new Point(x, y), this._getPolygonPoints())) {
+			return this._hitTest;
+		} else {
+			return null;
+		}
+	}
+
+	public doesIntersectWithBox(box: Box): boolean {
+		if (this._data === null || this._data.points === undefined || this._data.points.length === 0) {
+			return false;
+		} else {
+			return pointInBox(this._data.points[0], box);
+		}
+	}
+
+	public measure(): BoxSize {
+		if (this._data === null) { return { width: 0, height: 0 }; }
+		return this._getBoxSize();
+	}
+
+	public rect(): Rect {
+		if (this._data === null) { return { x: 0, y: 0, width: 0, height: 0 }; }
+		const internalData = this._getInternalData();
+		return { x: internalData.boxLeft, y: internalData.boxTop, width: internalData.boxWidth, height: internalData.boxHeight };
+	}
+
+	public isOutOfScreen(width: number, height: number): boolean {
+		if (null === this._data || void 0 === this._data.points || 0 === this._data.points.length) { return true; }
+
+		const internalData = this._getInternalData();
+		if (internalData.boxLeft + internalData.boxWidth < 0 || internalData.boxLeft > width) {
+			const screenBox = new Box(new Point(0, 0), new Point(width, height));
+			return this._getPolygonPoints().every((point: Point) => !pointInBox(point, screenBox));
+		}
+
+		return false;
+	}
+
+	public setPoints(points: Point[], hitTest: HitTestResult<void>): void {
+		ensureNotNull(this._data).points = points;
+		this._hitTest = hitTest || new HitTestResult(HitTestType.MovePoint);
+	}
+
+	public fontStyle(): string {
+		return this._data === null ? '' : this._getFontInfo().fontStyle;
+	}
+
+	public wordWrap(test: string, wrapWidth?: number, font?: string): string[] {
+		return textWrap(test, font || this.fontStyle(), wrapWidth);
+	}
+
+    // eslint-disable-next-line complexity
+	public draw(ctx: CanvasRenderingContext2D, pixelRatio: number): void {
+		if (this._data === null || this._data.points === undefined || this._data.points.length === 0) { return; }
+		const cssWidth = ctx.canvas.width;
+		const cssHeight = ctx.canvas.height;
+		if (this.isOutOfScreen(cssWidth, cssHeight)) { return; }
+
+		const textData = this._data.text;
+		const internalData = this._getInternalData();
+		const pivot = this._getRotationPoint().scaled(pixelRatio);
+		const angleDegrees = textData.box?.angle || 0;
+		const angle = -angleDegrees * Math.PI / 180;
+
+		ctx.save();
+		ctx.translate(pivot.x, pivot.y);
+		ctx.rotate(angle);
+		ctx.translate(-pivot.x, -pivot.y);
+
+		const fontSize = this._getFontInfo().fontSize;
+		ctx.textAlign = internalData.textAlign;
+		ctx.textBaseline = 'middle';
+		ctx.font = this.fontStyle();
+
+		const scaledTop = Math.round(internalData.boxTop * pixelRatio);
+		const scaledLeft = Math.round(internalData.boxLeft * pixelRatio);
+		const scaledRight = scaledLeft + Math.round(internalData.boxWidth * pixelRatio);
+		const scaledBottom = scaledTop + Math.round(internalData.boxHeight * pixelRatio);
+
+		if (textData.box?.background?.color || textData.box?.border?.color || textData.box?.border?.highlight && textData.wordWrapWidth) {
+			const borderWidth = Math.round((textData.box?.border?.width || Math.max(fontSize / 12, 1)) * pixelRatio);
+			const halfBorderWidth = borderWidth / 2;
+			let ctxUpdated = false;
+
+			if (textData.box?.shadow) {
+				const { color, blur, offset } = textData.box?.shadow;
+				ctx.save();
+				ctx.shadowColor = color as string;
+				ctx.shadowBlur = blur as number;
+				ctx.shadowOffsetX = offset?.x || 0;
+				ctx.shadowOffsetY = offset?.y || 0;
+				ctxUpdated = true;
+			}
+
+			if (textData.box.border?.width) {
+				if (textData.box.border?.color) {
+					ctx.strokeStyle = textData.box.border.color;
+				}
+				ctx.lineWidth = borderWidth;
+
+				const radius = textData.box?.border?.radius ?? 0 * pixelRatio + borderWidth;
+				const textBoxBorderStyle = textData.box?.border?.style;
+				drawRoundRect(ctx, scaledLeft - halfBorderWidth, scaledTop - halfBorderWidth, scaledRight - scaledLeft + borderWidth, scaledBottom - scaledTop + borderWidth, radius, textBoxBorderStyle);
+
+				if (textData.box.background?.color) {
+					ctx.fillStyle = textData.box.background.color;
+					ctx.fill();
+				}
+
+				if (ctxUpdated) { ctx.restore(); ctxUpdated = false; }
+			} else {
+				if (textData.box.background?.color) {
+					ctx.fillStyle = textData.box.background.color;
+					ctx.fillRect(scaledLeft, scaledTop, scaledRight - scaledLeft, scaledBottom - scaledTop);
+				}
+				if (ctxUpdated) { ctx.restore(); ctxUpdated = false; }
+			}
+		}
+
+		ctx.fillStyle = textData.font?.color as string;
+		const { lines } = this._getLinesInfo();
+		const extraSpace = 0.05 * fontSize;
+		const linePadding = getScaledPadding(this._data);
+		const x = (scaledLeft + Math.round(internalData.textStart * pixelRatio)) / pixelRatio;
+		let y = (scaledTop + Math.round((internalData.textTop + extraSpace) * pixelRatio)) / pixelRatio;
+
+		for (const line of lines) {
+			// eslint-disable-next-line @typescript-eslint/no-loop-func
+			drawScaled(ctx, pixelRatio, () => ctx.fillText(line, x, y));
+			y += fontSize + linePadding;
+		}
+		ctx.restore();
+	}
+
+    // eslint-disable-next-line complexity
+	private _getInternalData(): InternalData {
+		if (this._internalData !== null) { return this._internalData; }
+		const data = ensureNotNull(this._data);
+
+		const paddingX = getScaledBoxPaddingX(data);
+		const paddingY = getScaledBoxPaddingY(data);
+		const inflationPaddingX = getScaledBackgroundInflationX(data) + paddingX;
+		const inflationPaddingY = getScaledBackgroundInflationY(data) + paddingY;
+
+		const anchor = ensureDefined(data.points)[0];
+		const boxSize = this._getBoxSize();
+		const boxWidth = boxSize.width;
+		const boxHeight = boxSize.height;
+		let anchorY = anchor.y as number;
+		let anchorX = anchor.x as number;
+
+		switch (data.text?.box?.alignment?.vertical) {
+			case BoxVerticalAlignment.Top:
+				anchorY -= boxHeight + (data.text?.box?.offset?.y || 0);
+				break;
+			case BoxVerticalAlignment.Middle:
+				anchorY -= boxHeight / 2;
+				break;
+			case BoxVerticalAlignment.Bottom:
+				anchorY += (data.text?.box?.offset?.y || 0);
+		}
+
+		const textY = anchorY + (inflationPaddingY) + getScaledFontSize(data) / 2;
+		let textAlign = TextAlignment.Start;
+		let textX = 0;
+
+		switch (data.text?.box?.alignment?.horizontal) {
+			case BoxHorizontalAlignment.Left:
+				anchorX += (data.text?.box?.offset?.x || 0);
+				break;
+			case BoxHorizontalAlignment.Center:
+				anchorX -= boxWidth / 2;
+				break;
+			case BoxHorizontalAlignment.Right:
+				anchorX -= boxWidth + (data.text?.box?.offset?.x || 0);
+		}
+		switch (ensureDefined(data.text?.alignment)) {
+			case TextAlignment.Start:
+			case TextAlignment.Left: {
+				textAlign = TextAlignment.Start;
+				textX = anchorX + inflationPaddingX;
+
+				if (isRtl()) {
+					if (data.text?.forceTextAlign) {
+						textAlign = TextAlignment.Left;
+					} else {
+						textX = anchorX + boxWidth - inflationPaddingX;
+						textAlign = TextAlignment.Right;
+					}
+				}
+				break;
+			}
+			case TextAlignment.Center:
+				textAlign = TextAlignment.Center;
+				textX = anchorX + boxWidth / 2;
+				break;
+			case TextAlignment.Right:
+			case TextAlignment.End:
+				textAlign = TextAlignment.End;
+				textX = anchorX + boxWidth - inflationPaddingX;
+				if (isRtl() && data.text?.forceTextAlign) {
+					textAlign = TextAlignment.Right;
+				}
+				break;
+		}
+
+		this._internalData = {
+			boxLeft: anchorX,
+			boxTop: anchorY,
+			boxWidth: boxWidth,
+			boxHeight: boxHeight,
+			textAlign: textAlign,
+			textTop: textY - anchorY,
+			textStart: textX - anchorX,
+		};
+
+		return this._internalData;
+	}
+
+	private _getLinesMaxWidth(lines: string[]): number {
+		if (!cacheCanvas) { createCacheCanvas(); }
+		cacheCanvas.textBaseline = 'alphabetic';
+		cacheCanvas.font = this.fontStyle();
+
+		if (this._data !== null && this._data.text?.wordWrapWidth && !this._data.text?.forceCalculateMaxLineWidth) {
+			return this._data.text?.wordWrapWidth * getFontAwareScale(this._data);
+		}
+
+		let maxWidth = 0;
+		for (const line of lines) {
+			maxWidth = Math.max(maxWidth, cacheCanvas.measureText(line).width);
+		}
+		return maxWidth;
+	}
+
+	private _getLinesInfo(): LinesInfo {
+		if (null === this._linesInfo) {
+			const data = ensureNotNull(this._data);
+			let lines = this.wordWrap(data.text?.value || '', data.text?.wordWrapWidth);
+
+			if (data.text?.box?.maxHeight !== undefined) {
+				const maxHeight = ensureDefined(data.text?.box?.maxHeight);
+				const scaledFontSize = getScaledFontSize(data);
+				const scaledPadding = getScaledPadding(data);
+				const maxLines = Math.floor((maxHeight + scaledPadding) / (scaledFontSize + scaledPadding));
+				if (lines.length > maxLines) { lines = lines.slice(0, maxLines); }
+			}
+
+			this._linesInfo = { linesMaxWidth: this._getLinesMaxWidth(lines), lines };
+		}
+		return this._linesInfo;
+	}
+
+	private _getFontInfo(): FontInfo {
+		if (this._fontInfo === null) {
+			const data = ensureNotNull(this._data);
+			const fontSize = getScaledFontSize(data);
+			const fontStyle = (data.text?.font?.bold ? 'bold ' : '') + (data.text?.font?.italic ? 'italic ' : '') + fontSize + 'px ' + data.text?.font?.family;
+			this._fontInfo = { fontStyle: fontStyle, fontSize: fontSize };
+		}
+		return this._fontInfo;
+	}
+
+	private _getBoxSize(): BoxSize {
+		if (null === this._boxSize) {
+			const linesInfo = this._getLinesInfo();
+			const data = ensureNotNull(this._data);
+			this._boxSize = {
+				width: getBoxWidth(data, linesInfo.linesMaxWidth),
+				height: getBoxHeight(data, linesInfo.lines.length),
+			};
+		}
+		return this._boxSize;
+	}
+
+	private _getPolygonPoints(): Point[] {
+		if (null !== this._polygonPoints) {return this._polygonPoints;}
+		if (null === this._data) {return [];}
+
+		const { boxLeft, boxTop, boxWidth, boxHeight } = this._getInternalData();
+		const pivot = this._getRotationPoint();
+		const angleDegrees = this._data.text?.box?.angle || 0;
+		const angle = -angleDegrees * Math.PI / 180;
+		this._polygonPoints = [
+			rotatePoint(new Point(boxLeft, boxTop), pivot, angle),
+			rotatePoint(new Point(boxLeft + boxWidth, boxTop), pivot, angle),
+			rotatePoint(new Point(boxLeft + boxWidth, boxTop + boxHeight), pivot, angle),
+			rotatePoint(new Point(boxLeft, boxTop + boxHeight), pivot, angle),
+		];
+
+		return this._polygonPoints;
+	}
+
+	private _getRotationPoint(): Point {
+		const { boxLeft, boxTop, boxWidth, boxHeight } = this._getInternalData();
+		const { horizontal, vertical } = ensureDefined(this._data?.text?.box?.alignment);
+		let x = 0;
+		let y = 0;
+
+		switch (horizontal) {
+			case BoxHorizontalAlignment.Center:
+				x = boxLeft + boxWidth / 2;
+				break;
+			case BoxHorizontalAlignment.Left:
+				x = boxLeft;
+				break;
+			case BoxHorizontalAlignment.Right:
+				x = boxLeft + boxWidth;
+		}
+		switch (vertical) {
+			case BoxVerticalAlignment.Middle:
+				y = boxTop + boxHeight / 2;
+				break;
+			case BoxVerticalAlignment.Bottom:
+				y = boxTop;
+				break;
+			case BoxVerticalAlignment.Top:
+				y = boxTop + boxHeight;
+		}
+		return new Point(x, y);
+	}
+}
+
+// eslint-disable-next-line complexity
+function textWrap(text: string, font: string, lineWrapWidth: number | string | undefined): string[] {
+	if (!cacheCanvas) {createCacheCanvas();}
+	lineWrapWidth = Object.prototype.toString.call(lineWrapWidth) === '[object String]' ? parseInt(lineWrapWidth as string) : lineWrapWidth as number;
+	text += '';
+	const lines = !Number.isInteger(lineWrapWidth) || !isFinite(lineWrapWidth) || lineWrapWidth <= 0
+        ? text.split(/\r\n|\r|\n|$/)
+        : text.split(/[^\S\r\n]*(?:\r\n|\r|\n|$)/);
+
+	if (!lines[lines.length - 1]) { lines.pop(); }
+	if (!Number.isInteger(lineWrapWidth) || !isFinite(lineWrapWidth) || lineWrapWidth <= 0) { return lines; }
+
+	cacheCanvas.font = font;
+	const wrappedLines = [];
+	for (let i = 0; i < lines.length; i++) {
+		const line = lines[i];
+		const lineWidth = cacheCanvas.measureText(line).width;
+		if (lineWidth <= lineWrapWidth) {
+			wrappedLines.push(line);
+			continue;
+		}
+
+		const splitedLine = line.split(/([-)\]},.!?:;])|(\s+)/);
+		for (; splitedLine.length;) {
+			let space = Math.floor(lineWrapWidth / lineWidth * (splitedLine.length + 2) / 3);
+
+			if (space <= 0 || cacheCanvas.measureText(splitedLine.slice(0, 3 * space - 1).join('')).width <= lineWrapWidth) {
+				for (; cacheCanvas.measureText(splitedLine.slice(0, 3 * (space + 1) - 1).join('')).width <= lineWrapWidth;) {space++;}
+			} else {
+				// eslint-disable-next-line no-empty
+				for (; space > 0 && cacheCanvas.measureText(splitedLine.slice(0, 3 * --space - 1).join('')).width > lineWrapWidth;) {}
+			}
+
+			if (space > 0) {
+				wrappedLines.push(splitedLine.slice(0, 3 * space - 1).join(''));
+				splitedLine.splice(0, 3 * space);
+			} else {
+				const paragraph = splitedLine[0] + (splitedLine[1] || '');
+				let subspace = Math.floor(lineWrapWidth / cacheCanvas.measureText(paragraph).width * paragraph.length);
+
+				if (cacheCanvas.measureText(paragraph.substring(0, subspace)).width <= lineWrapWidth) {
+					for (; cacheCanvas.measureText(paragraph.substring(0, subspace + 1)).width <= lineWrapWidth;) {subspace++;}
+				} else {
+					// eslint-disable-next-line no-empty
+					for (; subspace > 1 && cacheCanvas.measureText(paragraph.substring(0, --subspace)).width > lineWrapWidth;) {}
+				}
+
+				subspace = Math.max(1, subspace);
+				wrappedLines.push(paragraph.substring(0, subspace));
+				splitedLine[0] = paragraph.substring(subspace);
+				splitedLine[1] = '';
+			}
+
+			if (cacheCanvas.measureText(splitedLine.join('')).width <= lineWrapWidth) {
+				wrappedLines.push(splitedLine.join(''));
+				break;
+			}
+		}
+	}
+	return wrappedLines;
+}
+
+let cacheCanvas: CanvasRenderingContext2D;
+function createCacheCanvas(): void {
+	const canvas = document.createElement('canvas');
+	canvas.width = 0;
+	canvas.height = 0;
+	cacheCanvas = ensureNotNull(canvas.getContext('2d'));
+}
+
+function rotatePoint(point: Point, pivot: Point, angle: number): Point {
+	if (0 === angle) { return point.clone(); }
+	const x = (point.x - pivot.x) * Math.cos(angle) - (point.y - pivot.y) * Math.sin(angle) + pivot.x;
+	const y = (point.x - pivot.x) * Math.sin(angle) + (point.y - pivot.y) * Math.cos(angle) + pivot.y;
+	return new Point(x, y);
+}
+
+function getBoxWidth(data: TextRendererData, maxLineWidth: number): number {
+	return maxLineWidth + 2 * getScaledBackgroundInflationX(data) + 2 * getScaledBoxPaddingX(data);
+}
+
+function getBoxHeight(data: TextRendererData, linesCount: number): number {
+	return getScaledFontSize(data) * linesCount + getScaledPadding(data) * (linesCount - 1) + 2 * getScaledBackgroundInflationY(data) + 2 * getScaledBoxPaddingY(data);
+}
+
+function getScaledBoxPaddingY(data: TextRendererData): number {
+	return data.text?.box?.padding?.y !== undefined ? data.text?.box?.padding?.y * getFontAwareScale(data) : getScaledFontSize(data) / 3;
+}
+
+function getScaledBoxPaddingX(data: TextRendererData): number {
+	return data.text?.box?.padding?.x ? data.text?.box?.padding?.x * getFontAwareScale(data) : getScaledFontSize(data) / 3;
+}
+
+function getScaledBackgroundInflationY(data: TextRendererData): number {
+	return (data.text?.box?.background?.inflation?.y || 0) * getFontAwareScale(data);
+}
+
+function getScaledBackgroundInflationX(data: TextRendererData): number {
+	return (data.text?.box?.background?.inflation?.x || 0) * getFontAwareScale(data);
+}
+
+function getScaledPadding(data: TextRendererData): number {
+	return (data.text?.padding || 0) * getFontAwareScale(data);
+}
+
+function getScaledFontSize(data: TextRendererData): number {
+	return Math.ceil(getFontSize(data) * getFontAwareScale(data));
+}
+
+function getFontSize(data: TextRendererData): number {
+	return data.text?.font?.size || 30;
+}
+
+function getFontAwareScale(data: TextRendererData): number {
+	const scale = Math.min(1, Math.max(0.2, data.text?.box?.scale || 1));
+	if (scale === 1) {return scale;}
+	const fontSize = getFontSize(data);
+	return Math.ceil(scale * fontSize) / fontSize;
+}
+
+function isRtl(): boolean {
+	return 'rtl' === window.document.dir;
+}
diff --git a/src/renderers/time-axis-background-renderer.ts b/src/renderers/time-axis-background-renderer.ts
new file mode 100644
index 0000000..5c5509b
--- /dev/null
+++ b/src/renderers/time-axis-background-renderer.ts
@@ -0,0 +1,37 @@
+import { drawScaled } from '../helpers/canvas-helpers';
+
+import { ITimeAxisViewRenderer, TimeAxisViewRendererOptions } from './itime-axis-view-renderer';
+
+export interface TimeAxisBackgroundRendererData {
+	coordinate: number;
+	color: string;
+	width: number;
+	visible: boolean;
+}
+
+export class TimeAxisBackgroundRenderer implements ITimeAxisViewRenderer {
+	private _data: TimeAxisBackgroundRendererData | null;
+
+	public constructor() {
+		this._data = null;
+	}
+
+	public setData(data: TimeAxisBackgroundRendererData): void {
+		this._data = data;
+	}
+
+	public draw(ctx: CanvasRenderingContext2D, rendererOptions: TimeAxisViewRendererOptions, pixelRatio: number): void {
+	//public drawBackground(ctx: CanvasRenderingContext2D, rendererOptions: TimeAxisViewRendererOptions, pixelRatio: number): void {
+		if (this._data === null || this._data.visible === false) {
+			return;
+		}
+
+		const { coordinate: x, width, color } = this._data;
+		const height = ctx.canvas.clientHeight;
+
+		drawScaled(ctx, pixelRatio, () => {
+			ctx.fillStyle = color;
+			ctx.fillRect(x, 0, width, height);
+		});
+	}
+}
diff --git a/src/renderers/triangle-renderer.ts b/src/renderers/triangle-renderer.ts
new file mode 100644
index 0000000..aeccbe7
--- /dev/null
+++ b/src/renderers/triangle-renderer.ts
@@ -0,0 +1,67 @@
+import { DeepPartial } from '../helpers/strict-type-checks';
+
+import { Coordinate } from '../model/coordinate';
+import { HitTestResult, HitTestType } from '../model/hit-test-result';
+import { distanceToSegment, pointInTriangle } from '../model/interesection';
+import { TriangleOptions } from '../model/line-tool-options';
+import { Point } from '../model/point';
+
+import { setLineStyle } from './draw-line';
+import { AnchorPoint } from './line-anchor-renderer';
+import { interactionTolerance } from './optimal-bar-width';
+import { ScaledRenderer } from './scaled-renderer';
+
+export type TriangleRendererData = DeepPartial<TriangleOptions> & { points: AnchorPoint[]; hitTestBackground?: boolean };
+
+export class TriangleRenderer extends ScaledRenderer {
+	protected _data: TriangleRendererData | null = null;
+
+	public setData(data: TriangleRendererData): void {
+		this._data = data;
+	}
+
+	public hitTest(x: Coordinate, y: Coordinate): HitTestResult<void> | null {
+		if (null === this._data || this._data.points.length < 2) { return null; }
+		const [end0, end1] = this._data.points;
+		const point = new Point(x, y);
+
+		if (distanceToSegment(end0, end1, point).distance <= interactionTolerance.line) {
+			return new HitTestResult(HitTestType.MovePoint);
+		}
+
+		if (this._data.points.length !== 3) { return null; }
+		const end3 = this._data.points[2];
+
+		if (distanceToSegment(end1, end3, point).distance <= interactionTolerance.line) {
+			return new HitTestResult(HitTestType.MovePoint);
+		} else if (distanceToSegment(end3, end0, point).distance <= interactionTolerance.line) {
+			return new HitTestResult(HitTestType.MovePoint);
+		}
+
+		if (this._data.hitTestBackground && pointInTriangle(point, end0, end1, end3)) {
+			return new HitTestResult(HitTestType.MovePointBackground);
+		}
+
+		return null;
+	}
+
+	protected _drawImpl(ctx: CanvasRenderingContext2D): void {
+		if (this._data === null || this._data.points.length < 2) { return; }
+		const [point0, point1] = this._data.points;
+		const point2 = 2 === this._data.points.length ? point1 : this._data.points[2];
+
+		ctx.lineCap = 'butt';
+		ctx.lineWidth = this._data.border?.width || 0;
+		ctx.strokeStyle = this._data.border?.color || 'transparent';
+		if (this._data.border?.style !== undefined) { setLineStyle(ctx, this._data.border.style); }
+
+		ctx.beginPath();
+		ctx.fillStyle = this._data.background?.color || 'transparent';
+		ctx.moveTo(point0.x, point0.y);
+		ctx.lineTo(point1.x, point1.y);
+		ctx.lineTo(point2.x, point2.y);
+		ctx.lineTo(point0.x, point0.y);
+		ctx.fill();
+		ctx.stroke();
+	}
+}
diff --git a/src/typings/_global-types/index.d.ts b/src/typings/_global-types/index.d.ts
index 9f3342a..ef79047 100644
--- a/src/typings/_global-types/index.d.ts
+++ b/src/typings/_global-types/index.d.ts
@@ -1,25 +1,35 @@
-/**
- * This type should be used when you need to save result of the setTimeout/setInterval functions.
- * It makes the compilation with non-composite project happy.
- */
-type TimerId = ReturnType<typeof setTimeout>;
+import { LineStyle } from '../..';
 
-/**
- * The type declares compile-time constants for mouse buttons.
- * e.button values for MouseEvents.
- * It's NOT e.buttons (with s)!
- */
-declare const enum MouseEventButton {
-	Left = 0,
-	Middle = 1,
-	Right = 2,
-	Fourth = 3,
-	Fifth = 4,
-}
+declare global {
+	/**
+	 * This type should be used when you need to save result of the setTimeout/setInterval functions.
+	 * It makes the compilation with non-composite project happy.
+	 */
+	type TimerId = ReturnType<typeof setTimeout>;
 
-/**
- * Removes "readonly" from all properties
- */
-type Mutable<T> = {
-	-readonly [P in keyof T]: T[P];
-};
+	/**
+	 * The type declares compile-time constants for mouse buttons.
+	 * e.button values for MouseEvents.
+	 * It's NOT e.buttons (with s)!
+	 */
+	const enum MouseEventButton {
+		Left = 0,
+		Middle = 1,
+		Right = 2,
+		Fourth = 3,
+		Fifth = 4,
+	}
+
+	/**
+	 * Removes "readonly" from all properties
+	 */
+	type Mutable<T> = {
+		-readonly [P in keyof T]: T[P];
+	};
+
+	interface CanvasRenderingContext2D extends CanvasCompositing, CanvasDrawImage, CanvasDrawPath, CanvasFillStrokeStyles, CanvasFilters, CanvasImageData, CanvasImageSmoothing, CanvasPath, CanvasPathDrawingStyles, CanvasRect, CanvasShadowStyles, CanvasState, CanvasText, CanvasTextDrawingStyles, CanvasTransform, CanvasUserInterface {
+		lineStyle: LineStyle;
+		mozDash?: number[];
+		webkitLineDash?: number[];
+	}
+}
\ No newline at end of file
diff --git a/src/views/pane/brush-pane-view.ts b/src/views/pane/brush-pane-view.ts
new file mode 100644
index 0000000..d478d12
--- /dev/null
+++ b/src/views/pane/brush-pane-view.ts
@@ -0,0 +1,67 @@
+
+import { ChartModel } from '../../model/chart-model';
+import { LineTool } from '../../model/line-tool';
+import { LineToolBrush } from '../../model/line-tool-brush';
+import { LineToolType } from '../../model/line-tool-options';
+import { Point } from '../../model/point';
+import { CompositeRenderer } from '../../renderers/composite-renderer';
+import { AnchorPoint } from '../../renderers/line-anchor-renderer';
+import { PolygonRenderer } from '../../renderers/polygon-renderer';
+
+import { LineToolPaneView } from './line-tool-pane-view';
+
+export class BrushPaneView extends LineToolPaneView {
+	protected _polygonRenderer: PolygonRenderer = new PolygonRenderer();
+
+	public constructor(source: LineTool<LineToolType>, model: ChartModel) {
+		super(source, model);
+		this._renderer = null;
+	}
+
+	protected override _updateImpl(): void {
+		super._updateImpl();
+		this._renderer = null;
+		if (this._points.length === 0) { return; }
+
+		const options = (this._source as LineToolBrush).getBrushOptions();
+		const smooth = Math.max(1, (this._source as LineToolBrush).smooth());
+
+		const computedPoints: Point[] = [this._points[0]];
+		for (let i = 1; i < this._points.length; i++) {
+			const heading = this._points[i].subtract(this._points[i - 1]);
+			const distance = heading.length();
+			const iterations = Math.min(5, Math.floor(distance / smooth));
+			const segment = heading.normalized().scaled(distance / iterations);
+			for (let j = 0; j < iterations - 1; j++) {
+				computedPoints.push(this._points[i - 1].add(segment.scaled(j)));
+			}
+			computedPoints.push(this._points[i]);
+		}
+
+		const points = this._smoothArray(computedPoints, smooth) as AnchorPoint[];
+		this._polygonRenderer.setData({ line: options.line, background: options.background, points: points });
+
+		const compositeRenderer = new CompositeRenderer();
+		compositeRenderer.append(this._polygonRenderer);
+		this._renderer = compositeRenderer;
+	}
+
+	protected _smoothArray(points: Point[], interval: number): Point[] {
+		const computedPoints = new Array(points.length) as Point[];
+		if (points.length === 1) { return points; }
+
+		for (let j = 0; j < points.length; j++) {
+			let current = new Point(0, 0);
+			for (let i = 0; i < interval; i++) {
+				const t = Math.max(j - i, 0);
+				const r = Math.min(j + i, points.length - 1);
+				current = current.add(points[t]);
+				current = current.add(points[r]);
+			}
+			computedPoints[j] = current.scaled(0.5 / interval);
+		}
+
+		computedPoints.push(points[points.length - 1]);
+		return computedPoints;
+	}
+}
diff --git a/src/views/pane/cross-line-pane-view.ts b/src/views/pane/cross-line-pane-view.ts
new file mode 100644
index 0000000..7c1e32f
--- /dev/null
+++ b/src/views/pane/cross-line-pane-view.ts
@@ -0,0 +1,59 @@
+import { deepCopy } from '../../helpers/deep-copy';
+
+import { ChartModel } from '../../model/chart-model';
+import { HitTestResult, HitTestType } from '../../model/hit-test-result';
+import { LineTool, LineToolOptionsInternal } from '../../model/line-tool';
+import { LineToolType } from '../../model/line-tool-options';
+import { CompositeRenderer } from '../../renderers/composite-renderer';
+import { AnchorPoint } from '../../renderers/line-anchor-renderer';
+import { SegmentRenderer } from '../../renderers/segment-renderer';
+
+import { LineEnd } from '../..';
+import { LineToolPaneView } from './line-tool-pane-view';
+
+export class CrossLinePaneView extends LineToolPaneView {
+	protected _verticalLineRenderer: SegmentRenderer = new SegmentRenderer();
+	protected _horizontalLineRenderer: SegmentRenderer = new SegmentRenderer();
+
+	public constructor(source: LineTool<LineToolType>, model: ChartModel) {
+		super(source, model);
+		this._renderer = null;
+		this._verticalLineRenderer.setHitTest(new HitTestResult(HitTestType.MovePoint));
+		this._horizontalLineRenderer.setHitTest(new HitTestResult(HitTestType.MovePoint));
+	}
+
+	protected override _updateImpl(height: number, width: number): void {
+		this._renderer = null;
+
+		const priceScale = this._source.priceScale();
+		const timeScale = this._model.timeScale();
+		if (!priceScale || priceScale.isEmpty() || timeScale.isEmpty()) { return; }
+
+		const points = this._source.points();
+		if (points.length < 1) { return; }
+
+		super._updateImpl();
+		const options = this._source.options() as LineToolOptionsInternal<'CrossLine'>;
+		if (this._points.length < 1) { return; }
+
+		const point = this._points[0];
+		const startVertical = new AnchorPoint(point.x, height, 0);
+		const endVertical = new AnchorPoint(point.x, 0, 1);
+
+		const startHorizontal = new AnchorPoint(0, point.y, 0);
+		const endHorizontal = new AnchorPoint(width, point.y, 1);
+
+		const extend = { left: false, right: false };
+		const ends = { left: LineEnd.Normal, right: LineEnd.Normal };
+
+		const compositeRenderer = new CompositeRenderer();
+		this._verticalLineRenderer.setData({ line: { ...deepCopy(options.line), end: ends, extend }, points: [startVertical, endVertical] });
+		this._horizontalLineRenderer.setData({ line: { ...deepCopy(options.line), end: ends, extend }, points: [startHorizontal, endHorizontal] });
+
+		compositeRenderer.append(this._verticalLineRenderer);
+		compositeRenderer.append(this._horizontalLineRenderer);
+
+		this.addAnchors(compositeRenderer);
+		this._renderer = compositeRenderer;
+	}
+}
diff --git a/src/views/pane/custom-price-line-pane-view.ts b/src/views/pane/custom-price-line-pane-view.ts
index ba1ccc0..63fd771 100644
--- a/src/views/pane/custom-price-line-pane-view.ts
+++ b/src/views/pane/custom-price-line-pane-view.ts
@@ -1,5 +1,7 @@
+import { Coordinate } from '../../model/coordinate';
 import { CustomPriceLine } from '../../model/custom-price-line';
 import { Series } from '../../model/series';
+import { UTCTimestamp } from '../../model/time-data';
 
 import { SeriesHorizontalLinePaneView } from './series-horizontal-line-pane-view';
 
@@ -11,6 +13,11 @@ export class CustomPriceLinePaneView extends SeriesHorizontalLinePaneView {
 		this._priceLine = priceLine;
 	}
 
+	public xCoord(): Coordinate | null {
+		const lineOptions = this._priceLine.options();
+		return this._xCoord(lineOptions.rayStart as UTCTimestamp);
+	}
+
 	protected _updateImpl(height: number, width: number): void {
 		const data = this._lineRendererData;
 		data.visible = false;
@@ -26,6 +33,11 @@ export class CustomPriceLinePaneView extends SeriesHorizontalLinePaneView {
 			return;
 		}
 
+		const rayStartCord = this.xCoord();
+		if (rayStartCord === null) {
+			return;
+		}
+
 		data.visible = true;
 		data.y = y;
 		data.color = lineOptions.color;
@@ -33,5 +45,19 @@ export class CustomPriceLinePaneView extends SeriesHorizontalLinePaneView {
 		data.height = height;
 		data.lineWidth = lineOptions.lineWidth;
 		data.lineStyle = lineOptions.lineStyle;
+		data.ray = lineOptions.ray;
+		data.rayStart = rayStartCord;
+	}
+
+	private _xCoord(time: UTCTimestamp): Coordinate | null {
+		const series = this._series;
+		const timeScale = series.model().timeScale();
+		const timeIndex = timeScale.timeToIndex({ timestamp: time }, true);
+
+		if (timeScale.isEmpty() || timeIndex === null) {
+			return null;
+		}
+
+		return timeScale.indexToCoordinate(timeIndex);
 	}
 }
diff --git a/src/views/pane/fib-retracement-pane-view.ts b/src/views/pane/fib-retracement-pane-view.ts
new file mode 100644
index 0000000..1d7fbcc
--- /dev/null
+++ b/src/views/pane/fib-retracement-pane-view.ts
@@ -0,0 +1,108 @@
+import { applyAlpha } from '../../helpers/color';
+import { defaultFontFamily } from '../../helpers/make-font';
+
+import { ChartModel } from '../../model/chart-model';
+import { LineTool, LineToolOptionsInternal } from '../../model/line-tool';
+import { BoxHorizontalAlignment, BoxVerticalAlignment, FibRetracementLevel, LineToolType, TextAlignment } from '../../model/line-tool-options';
+import { CompositeRenderer } from '../../renderers/composite-renderer';
+import { AnchorPoint } from '../../renderers/line-anchor-renderer';
+import { RectangleRenderer } from '../../renderers/rectangle-renderer';
+import { SegmentRenderer } from '../../renderers/segment-renderer';
+import { TextRenderer } from '../../renderers/text-renderer';
+
+import { LineToolPaneView } from './line-tool-pane-view';
+
+export class FibRetracementPaneView extends LineToolPaneView {
+	protected _rectangleRenderers: RectangleRenderer[] = [];
+	protected _labelRenderers: TextRenderer[] = [];
+	protected _lineRenderers: SegmentRenderer[] = [];
+
+	public constructor(source: LineTool<LineToolType>, model: ChartModel) {
+		super(source, model);
+		this._renderer = null;
+	}
+
+	// eslint-disable-next-line complexity
+	protected override _updateImpl(): void {
+		this._renderer = null;
+		this._invalidated = false;
+
+		const priceScale = this._source.priceScale();
+		const timeScale = this._model.timeScale();
+
+		if (!priceScale || priceScale.isEmpty() || timeScale.isEmpty()) { return; }
+		const strictRange = timeScale.visibleTimeRange();
+		if (strictRange === null) { return; }
+		const points = this._source.points();
+		if (points.length < 2) { return; }
+
+		const options = this._source.options() as LineToolOptionsInternal<'FibRetracement'>;
+		const isOutsideView = Math.max(points[0].timestamp, points[1].timestamp) < strictRange.from.timestamp;
+
+		if (!isOutsideView || options.extend.left || options.extend.right) {
+			super._updateImpl();
+
+			if (this._points.length < 2) { return; }
+			const compositeRenderer = new CompositeRenderer();
+			const minX = Math.min(this._points[0].x, this._points[1].x);
+			const maxX = Math.max(this._points[0].x, this._points[1].x);
+			const levelCoordinates = this._levelsData(this._source.points()[0].price, this._source.points()[1].price, options.levels);
+
+			for (let i = 0, j = -1; i < levelCoordinates.length; i++, j++) {
+				if (!this._lineRenderers[i]) {
+					this._lineRenderers.push(new SegmentRenderer());
+					this._labelRenderers.push(new TextRenderer());
+				}
+
+				const linePoints = [
+					new AnchorPoint(minX, levelCoordinates[i].coordinate, 0),
+					new AnchorPoint(maxX, levelCoordinates[i].coordinate, 0),
+				];
+
+				this._lineRenderers[i].setData({
+					line: { ...options.line, extend: options.extend, color: options.levels[i].color },
+					points: linePoints,
+				});
+				this._labelRenderers[i].setData({
+					text: {
+						alignment: TextAlignment.Right,
+						value: `${options.levels[i].coeff}(${levelCoordinates[i].price})`,
+						font: { color: options.levels[i].color, size: 11, family: defaultFontFamily },
+						box: { alignment: { horizontal: BoxHorizontalAlignment.Right, vertical: BoxVerticalAlignment.Middle } },
+					},
+					points: linePoints,
+				});
+
+				compositeRenderer.append(this._labelRenderers[i]);
+				compositeRenderer.append(this._lineRenderers[i]);
+
+				if (j < 0) { continue; }
+
+				if (!this._rectangleRenderers[j]) { this._rectangleRenderers.push(new RectangleRenderer()); }
+				this._rectangleRenderers[j].setData({
+					...options.line,
+					extend: options.extend,
+					background: { color: applyAlpha(options.levels[i].color, options.levels[i].opacity) },
+					points: [new AnchorPoint(minX, levelCoordinates[i - 1].coordinate, 0), new AnchorPoint(maxX, levelCoordinates[i].coordinate, 0)],
+				});
+				compositeRenderer.append(this._rectangleRenderers[j]);
+			}
+
+			this.addAnchors(compositeRenderer);
+			this._renderer = compositeRenderer;
+		}
+	}
+
+	protected _levelsData(min: number, max: number, levels: FibRetracementLevel[]): { coordinate: number; price: string }[] {
+		const baseValue = this._source.ownerSource()?.firstValue()?.value || 0;
+		const priceScale = this._source.priceScale();
+		const gap = max - min;
+		if (!priceScale || !baseValue) { return []; }
+
+		return levels.map((level: FibRetracementLevel) => {
+			const price = max - level.coeff * gap;
+			const coordinate = priceScale.priceToCoordinate(price, baseValue);
+			return { coordinate, price: priceScale.formatPrice(price, baseValue) };
+		});
+	}
+}
diff --git a/src/views/pane/horizontal-line-pane-view.ts b/src/views/pane/horizontal-line-pane-view.ts
new file mode 100644
index 0000000..037000b
--- /dev/null
+++ b/src/views/pane/horizontal-line-pane-view.ts
@@ -0,0 +1,83 @@
+import { deepCopy } from '../../helpers/deep-copy';
+
+import { ChartModel } from '../../model/chart-model';
+import { Coordinate } from '../../model/coordinate';
+import { HitTestResult, HitTestType } from '../../model/hit-test-result';
+import { LineTool, LineToolOptionsInternal } from '../../model/line-tool';
+import { BoxHorizontalAlignment, LineToolType } from '../../model/line-tool-options';
+import { Point } from '../../model/point';
+import { CompositeRenderer } from '../../renderers/composite-renderer';
+import { AnchorPoint } from '../../renderers/line-anchor-renderer';
+import { SegmentRenderer } from '../../renderers/segment-renderer';
+import { TextRenderer } from '../../renderers/text-renderer';
+
+import { LineEnd } from '../..';
+import { LineToolPaneView } from './line-tool-pane-view';
+
+export class HorizontalLinePaneView extends LineToolPaneView {
+	protected _lineRenderer: SegmentRenderer = new SegmentRenderer();
+	protected _labelRenderer: TextRenderer = new TextRenderer();
+
+	public constructor(source: LineTool<LineToolType>, model: ChartModel) {
+		super(source, model);
+		this._renderer = null;
+		this._lineRenderer.setHitTest(new HitTestResult(HitTestType.MovePoint));
+	}
+
+	// eslint-disable-next-line complexity
+	protected override _updateImpl(height: number, width: number): void {
+		this._renderer = null;
+
+		const priceScale = this._source.priceScale();
+		const timeScale = this._model.timeScale();
+		if (!priceScale || priceScale.isEmpty() || timeScale.isEmpty()) { return; }
+
+		const points = this._source.points();
+		if (points.length < 1) { return; }
+
+		const startTime = timeScale.coordinateToTime(0 as Coordinate);
+		const endTime = timeScale.coordinateToTime(width as Coordinate);
+		const options = this._source.options() as LineToolOptionsInternal<'HorizontalLine'>;
+
+		const { left, right } = options.line.extend || {};
+		const isOutsideView = (!left && points[0].timestamp > endTime.timestamp) || (!right && points[0].timestamp < startTime.timestamp);
+
+		if (!isOutsideView) {
+			super._updateImpl();
+			if (this._points.length < 1) { return; }
+
+			const point = this._points[0];
+			const start = left ? new AnchorPoint(0, point.y, 0) : new AnchorPoint(point.x, point.y, 0);
+			const end = right ? new AnchorPoint(width, point.y, 1) : new AnchorPoint(point.x, point.y, 1);
+
+			if (Math.floor(start.x) === Math.floor(end.x) || Math.max(start.x, end.x) <= 0 || end.x < start.x) { return; }
+
+			if (left && right) {
+				point.x = width / 2 as Coordinate;
+				point.square = true;
+			}
+
+			const ends = { left: LineEnd.Normal, right: LineEnd.Normal };
+			const compositeRenderer = new CompositeRenderer();
+			this._lineRenderer.setData({ line: { ...deepCopy(options.line), end: ends }, points: [start, end] });
+
+			compositeRenderer.append(this._lineRenderer);
+			if (options.text.value) {
+				const angle = Math.atan((end.y - start.y) / (end.x - start.x)) / Math.PI * -180;
+				const align = options.text.box.alignment.horizontal;
+				const pivot = align === BoxHorizontalAlignment.Left
+					? start.clone() : align === BoxHorizontalAlignment.Right
+					? end.clone() : new Point((start.x + end.x) / 2, (start.y + end.y) / 2);
+
+				const labelOptions = deepCopy(options.text);
+				labelOptions.box = { ...labelOptions.box, angle };
+
+				this._labelRenderer.setData({ text: labelOptions, points: [pivot] });
+				compositeRenderer.append(this._labelRenderer);
+			}
+
+			this.addAnchors(compositeRenderer);
+			this._renderer = compositeRenderer;
+		}
+	}
+}
diff --git a/src/views/pane/line-tool-pane-view.ts b/src/views/pane/line-tool-pane-view.ts
new file mode 100644
index 0000000..e25257f
--- /dev/null
+++ b/src/views/pane/line-tool-pane-view.ts
@@ -0,0 +1,341 @@
+import { IInputEventListener, InputEventType, TouchMouseEvent } from '../../gui/mouse-event-handler';
+import { PaneWidget } from '../../gui/pane-widget';
+
+import { ensureNotNull } from '../../helpers/assertions';
+import { clone } from '../../helpers/strict-type-checks';
+
+import { BarPrice } from '../../model/bar';
+import { ChartModel } from '../../model/chart-model';
+import { Coordinate } from '../../model/coordinate';
+import { HitTestResult, HitTestType } from '../../model/hit-test-result';
+import { LineTool, LineToolHitTestData, LineToolPoint } from '../../model/line-tool';
+import { LineToolType } from '../../model/line-tool-options';
+import { PaneCursorType } from '../../model/pane';
+import { Point } from '../../model/point';
+import { CompositeRenderer } from '../../renderers/composite-renderer';
+import { IPaneRenderer } from '../../renderers/ipane-renderer';
+import { AnchorPoint, LineAnchorRenderer } from '../../renderers/line-anchor-renderer';
+
+import { IUpdatablePaneView } from './iupdatable-pane-view';
+
+export interface CreateAnchorData {
+	points: AnchorPoint[];
+	pointsCursorType?: PaneCursorType[];
+}
+
+export abstract class LineToolPaneView implements IUpdatablePaneView, IInputEventListener {
+	protected readonly _source: LineTool<LineToolType>;
+	protected readonly _model: ChartModel;
+	protected _points: AnchorPoint[] = [];
+
+	protected _invalidated: boolean = true;
+	protected _lastMovePoint: Point | null = null;
+	protected _editedPointIndex: number | null = null;
+	protected _lineAnchorRenderers: LineAnchorRenderer[] = [];
+	protected _renderer: IPaneRenderer | null = null;
+
+	public constructor(source: LineTool<LineToolType>, model: ChartModel) {
+		this._source = source;
+		this._model = model;
+	}
+
+	// eslint-disable-next-line complexity
+	public onInputEvent(paneWidget: PaneWidget, ctx: CanvasRenderingContext2D, eventType: InputEventType, event?: TouchMouseEvent): void {
+		if (!event || (!this._renderer || !this._renderer.hitTest) && this._source.finished()) { return; }
+
+		const crossHair = this._model.crosshairSource();
+		const appliedPoint = new Point(crossHair.appliedX(), crossHair.appliedY());
+		const originPoint = new Point(crossHair.originCoordX(), crossHair.originCoordY());
+
+		const changed = eventType === InputEventType.PressedMouseMove && !event.consumed
+			? this._onPressedMouseMove(paneWidget, ctx, originPoint, appliedPoint, event)
+			: eventType === InputEventType.MouseMove
+			? this._onMouseMove(paneWidget, ctx, originPoint, appliedPoint, event)
+			: eventType === InputEventType.MouseDown
+			? this._onMouseDown(paneWidget, ctx, originPoint, appliedPoint, event)
+			: eventType === InputEventType.MouseUp
+			? this._onMouseUp(paneWidget)
+			: false;
+
+		event.consumed ||= this._source.editing() || !this._source.finished();
+		if (changed || this._source.hovered() || this._source.editing() || ! this._source.finished()) {
+			this.updateLineAnchors();
+		}
+	}
+
+	public renderer(height: number, width: number, addAnchors?: boolean | undefined): IPaneRenderer | null {
+		if (this._invalidated) { this._updateImpl(height, width); }
+		return this._source.visible() ? this._renderer : null;
+	}
+
+	public priceToCoordinate(price: BarPrice): Coordinate | null {
+		const priceScale = this._source.priceScale();
+		const ownerSource = this._source.ownerSource();
+
+		if (priceScale === null) { return null; }
+
+		const basePrice = ownerSource !== null ? ownerSource.firstValue() : null;
+		return basePrice === null ? null : priceScale.priceToCoordinate(price, basePrice.value);
+	}
+
+	public currentPoint(): Point {
+		const crossHair = this._model.crosshairSource();
+		return new Point(crossHair.originCoordX(), crossHair.originCoordY());
+	}
+
+	public editedPointIndex(): number | null {
+		return this._source.editing() ? this._editedPointIndex : null;
+	}
+
+	public areAnchorsVisible(): boolean {
+		return this._source.hovered() || this._source.selected() || this._source.editing() || !this._source.finished();
+	}
+
+	public update(): void {
+		this._invalidated = true;
+	}
+
+	public addAnchors(renderer: CompositeRenderer): void {
+		renderer.append(this.createLineAnchor({ points: this._points }, 0));
+	}
+
+	public updateLineAnchors(): void {
+		this._lineAnchorRenderers.forEach((renderer: LineAnchorRenderer) => {
+			renderer.updateData({
+				points: this._points,
+				selected: this._source.selected(),
+				visible: this.areAnchorsVisible(),
+				currentPoint: this.currentPoint(),
+				editedPointIndex: this.editedPointIndex(),
+			});
+		});
+		this._model.updateSource(this._source);
+		this._source.updateAllViews();
+	}
+
+	public createLineAnchor(data: CreateAnchorData, index: number): LineAnchorRenderer {
+		const renderer = this._getLineAnchorRenderer(index);
+		renderer.setData({
+			...data,
+			radius: 6,
+			strokeWidth: 1,
+			color: '#1E53E5',
+			hoveredStrokeWidth: 4,
+			selected: this._source.selected(),
+			visible: this.areAnchorsVisible(),
+			currentPoint: this.currentPoint(),
+			backgroundColors: this._lineAnchorColors(data.points),
+			editedPointIndex: this._source.editing() ? this.editedPointIndex() : null,
+			hitTestType: HitTestType.ChangePoint,
+		});
+
+		return renderer;
+	}
+
+	public getSelectedAndFireAfterEdit(paneWidget: PaneWidget, stage: string, orderID: string): void {
+		// finised editing or creating a line tool, execute AfterEdit event
+		// get the specific lineTool that was pathFinished, lineToolFinished, lineToolEdited and pass it on to the front end
+		const modifiedLineTool = paneWidget.state().getLineTool(orderID);
+		// if not null, the id exists, so pass it to frontend
+		if (modifiedLineTool !== null) {
+			// create a new lineToolExport to make sure that any change in the lineTool exported in not immediately applied.
+			const selectedLineTool = clone(modifiedLineTool.exportLineToolToLineToolExport());
+			this._model.fireLineToolsAfterEdit(selectedLineTool, stage);
+		}
+	}
+
+	protected _onMouseUp(paneWidget: PaneWidget): boolean {
+		if (!this._source.finished()) {
+			this._source.tryFinish();
+
+			const orderID = this._source.id();
+
+			// did a line tool just finish being created, if so fire AfterEdit
+			if (!this._source.editing() && !this._source.creating()) {
+				// finished creating a line tool, fire after edit event
+				this.getSelectedAndFireAfterEdit(paneWidget, 'lineToolFinished', orderID);
+			} else if (this._source.finished()) {
+				// this will detect if a path is finished being created
+				this.getSelectedAndFireAfterEdit(paneWidget, 'pathFinished', orderID);
+			}
+		} else if (this._source.editing()) {
+			this._model.magnet().disable();
+			this._updateSourcePoints();
+
+			this._lastMovePoint = null;
+			this._editedPointIndex = null;
+			this._source.setEditing(false);
+			this._source.setCreating(false);
+
+			// pass along the id of the lineTool
+			const orderID = this._source.id();
+
+			// finished editing an existing line tool, fire after edit event
+			this.getSelectedAndFireAfterEdit(paneWidget, 'lineToolEdited', orderID);
+
+			return true;
+		}
+
+		return false;
+	}
+
+	protected _onPressedMouseMove(paneWidget: PaneWidget, ctx: CanvasRenderingContext2D, originPoint: Point, appliedPoint: Point, event: TouchMouseEvent): boolean {
+		if (!this._source.finished()) {
+			if (this._source.lineDrawnWithPressedButton()) {
+				this._source.addPoint(this._source.screenPointToPoint(appliedPoint) as LineToolPoint);
+			}
+			return false;
+		}
+
+		if (!this._source.selected()) { return false; }
+
+		if (!this._source.editing()) {
+			const hitResult = this._hitTest(paneWidget, ctx, originPoint);
+			const hitData = hitResult?.data();
+			this._source.setEditing(this._source.hovered() || !!hitResult);
+
+			this._lastMovePoint = appliedPoint;
+			this._editedPointIndex = hitData?.pointIndex ?? this._editedPointIndex;
+			if (hitData) { this._model.magnet().enable(); }
+		} else {
+			paneWidget.setCursor(this._editedPointIndex !== null ? PaneCursorType.Default : PaneCursorType.Grabbing);
+
+			if (this._editedPointIndex !== null) {
+				this._tryApplyLineToolShift(appliedPoint, event, true);
+
+				this._source.setPoint(this._editedPointIndex, this._source.screenPointToPoint(appliedPoint) as LineToolPoint);
+			} else if (this._lastMovePoint) {
+				const diff = appliedPoint.subtract(this._lastMovePoint);
+				this._points.forEach((point: Point) => {
+					point.x = (point.x + diff.x) as Coordinate;
+					point.y = (point.y + diff.y) as Coordinate;
+				});
+
+				this._lastMovePoint = appliedPoint;
+				this._updateSourcePoints();
+			}
+		}
+		return false;
+	}
+
+	protected _onMouseMove(paneWidget: PaneWidget, ctx: CanvasRenderingContext2D, originPoint: Point, appliedPoint: Point, event: TouchMouseEvent): boolean {
+		if (!this._source.finished()) {
+			if (this._source.hasMagnet()) { this._model.magnet().enable(); }
+
+			this._tryApplyLineToolShift(appliedPoint, event, false);
+
+			this._source.setLastPoint(this._source.screenPointToPoint(appliedPoint) as LineToolPoint);
+		} else {
+			const hitResult = this._hitTest(paneWidget, ctx, originPoint);
+			const changed = this._source.setHovered(hitResult !== null && !event.consumed);
+
+			if (this._source.hovered() && !event.consumed) {
+				if (this._source.options().editable === true) {
+					paneWidget.setCursor(hitResult?.data()?.cursorType || PaneCursorType.Pointer);
+					this._editedPointIndex = hitResult?.data()?.pointIndex ?? null;
+				} else {
+					paneWidget.setCursor(hitResult?.data()?.cursorType || PaneCursorType.NotAllowed);
+				}
+			}
+
+			return changed;
+		}
+
+		return false;
+	}
+
+	protected _onMouseDown(paneWidget: PaneWidget, ctx: CanvasRenderingContext2D, originPoint: Point, appliedPoint: Point, event: TouchMouseEvent): boolean {
+		if (!this._source.finished()) {
+			this._tryApplyLineToolShift(appliedPoint, event, false);
+
+			this._source.addPoint(this._source.screenPointToPoint(appliedPoint) as LineToolPoint);
+			return false;
+		} else {
+			if (this._source.options().editable === true) {
+				const hitResult = this._hitTest(paneWidget, ctx, originPoint);
+				return this._source.setSelected(hitResult !== null && !event.consumed);
+			} else {
+				return false;
+			}
+		}
+	}
+
+	protected _updateSourcePoints(): void {
+		this._source.setPoints(this._points.map((point: Point) => this._source.screenPointToPoint(point) as LineToolPoint));
+	}
+
+	protected _hitTest(paneWidget: PaneWidget, ctx: CanvasRenderingContext2D, point: Point): HitTestResult<LineToolHitTestData> | null {
+		if (!this._renderer?.hitTest) { return null; }
+		return this._renderer.hitTest(point.x, point.y, ctx) as HitTestResult<LineToolHitTestData> | null;
+	}
+
+	protected _lineAnchorColors(points: AnchorPoint[]): string[] {
+		const height = ensureNotNull(this._model.paneForSource(this._source)).height();
+		return points.map((point: AnchorPoint) => this._model.backgroundColorAtYPercentFromTop(point.y / height));
+	}
+
+	protected _updateImpl(height?: number, width?: number): void {
+		this._invalidated = false;
+
+		if (this._model.timeScale().isEmpty()) { return; }
+		if (!this._validatePriceScale()) { return; }
+
+		this._points = [] as AnchorPoint[];
+		const sourcePoints = this._source.points();
+		for (let i = 0; i < sourcePoints.length; i++) {
+			const point = this._source.pointToScreenPoint(sourcePoints[i]) as AnchorPoint;
+			if (!point) { return; }
+			point.data = i;
+			this._points.push(point);
+		}
+	}
+
+	protected _validatePriceScale(): boolean {
+		const priceScale = this._source.priceScale();
+		return null !== priceScale && !priceScale.isEmpty();
+	}
+
+	protected _getLineAnchorRenderer(index: number): LineAnchorRenderer {
+		for (; this._lineAnchorRenderers.length <= index;) {this._lineAnchorRenderers.push(new LineAnchorRenderer());}
+		return this._lineAnchorRenderers[index];
+	}
+
+	protected _tryApplyLineToolShift(appliedPoint: Point, event: TouchMouseEvent, useEditedPointIndex: boolean): void {
+		const isTrendLine = this._isTrendLine();
+
+		// if shift, isTrendLine = true and at least 1 point exists already
+		if (event.shiftKey === true && isTrendLine === true && this._points.length > 0) {
+			// override point
+			if (useEditedPointIndex) {
+				if (this._editedPointIndex === 1) {
+					appliedPoint.y = this._points[0].y;
+				} else if (this._editedPointIndex === 0) {
+					appliedPoint.y = this._points[1].y;
+				} else if (this._editedPointIndex === 2) {
+					// parallelChannel is the only tool supporting holding shift that has 3-4 points
+					// points does not track point 3, so i have to use the diference from 0 and 1 and offset 2 so it now match what point 3 is without knowing anything about 3
+					const dif = this._points[0].y - this._points[1].y;
+					appliedPoint.y = (this._points[2].y - dif) as Coordinate;
+				} else if (this._editedPointIndex === 3) {
+					// parallelChannel is the only tool supporting holding shift that has 3-4 points
+					appliedPoint.y = this._points[2].y;
+				}
+			} else {
+				// if shift, isTrendLine = true and at least 1 point exists already
+				if (event.shiftKey === true && isTrendLine === true && this._points.length > 0) {
+					// override point 2's y with point 1's y
+					appliedPoint.y = this._points[0].y;
+				}
+			}
+		}
+	}
+
+	protected _isTrendLine(): boolean {
+		let isTrendLine = false;
+		const toolTypeStr = String(this._source.toolType());
+		if (toolTypeStr === 'TrendLine' || toolTypeStr === 'Ray' || toolTypeStr === 'Arrow' || toolTypeStr === 'ExtendedLine' || toolTypeStr === 'ParallelChannel') {
+			isTrendLine = true;
+		}
+		return isTrendLine;
+	}
+}
diff --git a/src/views/pane/parallel-channel-pane-view.ts b/src/views/pane/parallel-channel-pane-view.ts
new file mode 100644
index 0000000..649e594
--- /dev/null
+++ b/src/views/pane/parallel-channel-pane-view.ts
@@ -0,0 +1,72 @@
+import { deepCopy } from '../../helpers/deep-copy';
+
+import { ChartModel } from '../../model/chart-model';
+import { LineTool, LineToolOptionsInternal } from '../../model/line-tool';
+import { LineToolType } from '../../model/line-tool-options';
+import { PaneCursorType } from '../../model/pane';
+import { CompositeRenderer } from '../../renderers/composite-renderer';
+import { AnchorPoint } from '../../renderers/line-anchor-renderer';
+import { ParallelChannelRenderer } from '../../renderers/parallel-channel-renderer';
+
+import { LineToolPaneView } from './line-tool-pane-view';
+
+const pointsCursorType = [PaneCursorType.Default, PaneCursorType.Default, PaneCursorType.Default, PaneCursorType.Default, PaneCursorType.VerticalResize, PaneCursorType.VerticalResize];
+export class ParallelChannelPaneView extends LineToolPaneView {
+	protected _channelRenderer: ParallelChannelRenderer = new ParallelChannelRenderer();
+
+	public constructor(source: LineTool<LineToolType>, model: ChartModel) {
+		super(source, model);
+		this._renderer = null;
+	}
+
+	protected override _updateImpl(): void {
+		super._updateImpl();
+		this._renderer = null;
+
+		const priceScale = this._source.priceScale();
+		if (!priceScale || priceScale.isEmpty()) { return; }
+		if (this._source.points().length === 0) { return; }
+		if (this._points.length <= 1) { return; }
+
+		const end0 = this._points[0];
+		const end1 = this._points[1];
+		let end2: AnchorPoint | null = null;
+		let end3: AnchorPoint | null = null;
+
+		if (this._points.length === 3) {
+			const height = this._points[2].y - this._points[0].y;
+			end2 = new AnchorPoint(end0.x, end0.y + height, 2);
+			end3 = new AnchorPoint(end1.x, end1.y + height, 3);
+		}
+
+		const points = end2 && end3 ? [end0, end1, end2, end3] : [end0, end1];
+		const options = this._source.options() as LineToolOptionsInternal<'ParallelChannel'>;
+		this._channelRenderer.setData({ ...deepCopy(options), points, hitTestBackground: false });
+
+		const compositeRenderer = new CompositeRenderer();
+		compositeRenderer.append(this._channelRenderer);
+
+		const anchorPoints: AnchorPoint[] = [];
+
+		if (this._points[0]) { anchorPoints.push(new AnchorPoint(end0.x, end0.y, 0)); }
+		if (this._points[1]) { anchorPoints.push(new AnchorPoint(end1.x, end1.y, 1)); }
+
+		if (end2 && end3) {
+			anchorPoints.push(new AnchorPoint(end2.x, end2.y, 2), new AnchorPoint(end3.x, end3.y, 3));
+
+			const middle0 = end2.add(end3).scaled(0.5) as AnchorPoint;
+			middle0.data = 4;
+			middle0.square = true;
+			anchorPoints.push(middle0);
+
+			const middle1 = anchorPoints[0].add(anchorPoints[1]).scaled(0.5) as AnchorPoint;
+			middle1.square = true;
+			middle1.data = 5;
+			anchorPoints.push(middle1);
+		}
+
+		const anchorData = { points: anchorPoints, pointsCursorType };
+		compositeRenderer.append(this.createLineAnchor(anchorData, 0));
+		this._renderer = compositeRenderer;
+	}
+}
diff --git a/src/views/pane/path-pane-view.ts b/src/views/pane/path-pane-view.ts
new file mode 100644
index 0000000..abf2cc8
--- /dev/null
+++ b/src/views/pane/path-pane-view.ts
@@ -0,0 +1,32 @@
+import { deepCopy } from '../../helpers/deep-copy';
+
+import { ChartModel } from '../../model/chart-model';
+import { LineTool } from '../../model/line-tool';
+import { LineToolPathOptions, LineToolType } from '../../model/line-tool-options';
+import { CompositeRenderer } from '../../renderers/composite-renderer';
+import { PolygonRenderer } from '../../renderers/polygon-renderer';
+
+import { LineToolPaneView } from './line-tool-pane-view';
+
+export class PathPaneView extends LineToolPaneView {
+	protected _polygonRenderer: PolygonRenderer = new PolygonRenderer();
+
+	public constructor(source: LineTool<LineToolType>, model: ChartModel) {
+		super(source, model);
+		this._renderer = null;
+	}
+
+	protected override _updateImpl(): void {
+		super._updateImpl();
+		this._renderer = null;
+
+		const options = this._source.options() as LineToolPathOptions;
+		this._polygonRenderer.setData({ line: deepCopy(options.line), points: this._points });
+
+		const compositeRenderer = new CompositeRenderer();
+		compositeRenderer.append(this._polygonRenderer);
+
+		this._renderer = compositeRenderer;
+		this.addAnchors(compositeRenderer);
+	}
+}
diff --git a/src/views/pane/rectangle-pane-view.ts b/src/views/pane/rectangle-pane-view.ts
new file mode 100644
index 0000000..ce22963
--- /dev/null
+++ b/src/views/pane/rectangle-pane-view.ts
@@ -0,0 +1,132 @@
+import { deepCopy } from '../../helpers/deep-copy';
+
+import { ChartModel } from '../../model/chart-model';
+import { Coordinate } from '../../model/coordinate';
+import { LineTool, LineToolOptionsInternal } from '../../model/line-tool';
+import { BoxHorizontalAlignment, BoxVerticalAlignment, LineToolType } from '../../model/line-tool-options';
+import { PaneCursorType } from '../../model/pane';
+import { CompositeRenderer } from '../../renderers/composite-renderer';
+import { AnchorPoint } from '../../renderers/line-anchor-renderer';
+import { RectangleRenderer } from '../../renderers/rectangle-renderer';
+import { TextRenderer } from '../../renderers/text-renderer';
+
+import { LineToolPaneView } from './line-tool-pane-view';
+
+export class RectanglePaneView extends LineToolPaneView {
+	protected _rectangleRenderer: RectangleRenderer = new RectangleRenderer();
+	protected _labelRenderer: TextRenderer = new TextRenderer();
+
+	public constructor(source: LineTool<LineToolType>, model: ChartModel) {
+		super(source, model);
+		this._renderer = null;
+	}
+
+	// eslint-disable-next-line complexity
+	protected override _updateImpl(): void {
+		this._renderer = null;
+		this._invalidated = false;
+
+		const priceScale = this._source.priceScale();
+		const timeScale = this._model.timeScale();
+
+		if (!priceScale || priceScale.isEmpty() || timeScale.isEmpty()) { return; }
+		const strictRange = timeScale.visibleTimeRange();
+		if (strictRange === null) { return; }
+		const points = this._source.points();
+		if (points.length < 2) { return; }
+
+		const options = this._source.options() as LineToolOptionsInternal<'Rectangle'>;
+		const isOutsideView = Math.max(points[0].timestamp, points[1].timestamp) < strictRange.from.timestamp;
+
+		if (!isOutsideView || options.rectangle.extend.left || options.rectangle.extend.right) {
+			super._updateImpl();
+			if (this._points.length < 2) { return; }
+			const compositeRenderer = new CompositeRenderer();
+			this._rectangleRenderer.setData({ ...deepCopy(options.rectangle), points: this._points, hitTestBackground: false });
+
+			compositeRenderer.append(this._rectangleRenderer);
+			const point0 = this._points[0];
+			const point1 = this._points[1];
+
+			if (options.text.value) {
+				const minX = Math.min(point0.x, point1.x);
+				const maxX = Math.max(point0.x, point1.x);
+				const minY = Math.min(point0.y, point1.y);
+				const maxY = Math.max(point0.y, point1.y);
+
+				const pivot = point0.clone();
+				const textHalfSize = options.text.font.size / 3;
+				let hoirzontalPadding = 0;
+
+				switch (options.text.box.alignment.vertical) {
+					case BoxVerticalAlignment.Middle:
+						pivot.y = (minY + maxY) / 2 as Coordinate;
+						hoirzontalPadding = textHalfSize;
+						break;
+					case BoxVerticalAlignment.Top:
+						pivot.y = minY as Coordinate;
+						break;
+					case BoxVerticalAlignment.Bottom:
+						pivot.y = maxY as Coordinate;
+				}
+
+				switch (options.text.box.alignment.horizontal) {
+					case BoxHorizontalAlignment.Center:
+						pivot.x = (minX + maxX) / 2 as Coordinate;
+						break;
+					case BoxHorizontalAlignment.Left:
+						pivot.x = minX as Coordinate;
+						break;
+					case BoxHorizontalAlignment.Right:
+						pivot.x = maxX as Coordinate;
+				}
+
+				const labelOptions = deepCopy(options.text);
+				labelOptions.box = { ...labelOptions.box, padding: { y: textHalfSize, x: hoirzontalPadding } };
+
+				if (options.text.box.alignment.vertical === BoxVerticalAlignment.Middle) {
+					// if (options.text.forceCalculateMaxLineWidth) {
+					//	labelOptions.wordWrapWidth = maxX - minX - 2 * hoirzontalPadding;
+					// }
+					labelOptions.box.maxHeight = maxY - minY;
+				}
+
+				this._labelRenderer.setData({ text: labelOptions, points: [pivot] });
+				compositeRenderer.append(this._labelRenderer);
+			}
+
+			this._addAnchors(point0, point1, compositeRenderer);
+			this._renderer = compositeRenderer;
+		}
+	}
+
+	protected _addAnchors(topLeft: AnchorPoint, bottomRight: AnchorPoint, renderer: CompositeRenderer): void {
+		const bottomLeft = new AnchorPoint(topLeft.x, bottomRight.y, 2);
+		const topRight = new AnchorPoint(bottomRight.x, topLeft.y, 3);
+		const middleLeft = new AnchorPoint(topLeft.x, 0.5 * (topLeft.y + bottomRight.y), 4, true);
+		const middleRight = new AnchorPoint(bottomRight.x, 0.5 * (topLeft.y + bottomRight.y), 5, true);
+		const topCenter = new AnchorPoint(0.5 * (topLeft.x + bottomRight.x), topLeft.y, 6, true);
+		const bottomCenter = new AnchorPoint(0.5 * (topLeft.x + bottomRight.x), bottomRight.y, 7, true);
+
+		const xDiff = topLeft.x - bottomRight.x;
+		const yDiff = topLeft.y - bottomRight.y;
+		const sign = Math.sign(xDiff * yDiff);
+
+		const pointsCursorType = [
+			sign < 0 ? PaneCursorType.DiagonalNeSwResize : PaneCursorType.DiagonalNwSeResize,
+			sign < 0 ? PaneCursorType.DiagonalNeSwResize : PaneCursorType.DiagonalNwSeResize,
+			sign > 0 ? PaneCursorType.DiagonalNeSwResize : PaneCursorType.DiagonalNwSeResize,
+			sign > 0 ? PaneCursorType.DiagonalNeSwResize : PaneCursorType.DiagonalNwSeResize,
+			PaneCursorType.HorizontalResize,
+			PaneCursorType.HorizontalResize,
+			PaneCursorType.VerticalResize,
+			PaneCursorType.VerticalResize,
+		];
+
+		const anchorData = {
+			points: [topLeft, bottomRight, bottomLeft, topRight, middleLeft, middleRight, topCenter, bottomCenter],
+			pointsCursorType,
+		};
+		renderer.append(this.createLineAnchor(anchorData, 0));
+	}
+}
diff --git a/src/views/pane/series-horizontal-line-pane-view.ts b/src/views/pane/series-horizontal-line-pane-view.ts
index 602994a..82edd50 100644
--- a/src/views/pane/series-horizontal-line-pane-view.ts
+++ b/src/views/pane/series-horizontal-line-pane-view.ts
@@ -16,6 +16,8 @@ export abstract class SeriesHorizontalLinePaneView implements IPaneView {
 		lineWidth: 1,
 		lineStyle: LineStyle.Solid,
 		visible: false,
+		ray: false,
+		rayStart: 0 as Coordinate,
 	};
 
 	protected readonly _series: Series;
diff --git a/src/views/pane/series-last-price-animation-pane-view.ts b/src/views/pane/series-last-price-animation-pane-view.ts
index dcafb14..2ff8553 100644
--- a/src/views/pane/series-last-price-animation-pane-view.ts
+++ b/src/views/pane/series-last-price-animation-pane-view.ts
@@ -205,10 +205,10 @@ export class SeriesLastPriceAnimationPaneView implements IUpdatablePaneView {
 			return;
 		}
 
-		const lastValuePoint: Point = {
-			x: timeScale.indexToCoordinate(lastValue.index),
-			y: this._series.priceScale().priceToCoordinate(lastValue.price, firstValue.value),
-		};
+		const lastValuePoint: Point = new Point(
+			timeScale.indexToCoordinate(lastValue.index),
+			this._series.priceScale().priceToCoordinate(lastValue.price, firstValue.value)
+		);
 
 		const seriesLineColor = lastValue.color;
 		const seriesLineWidth = this._series.options().lineWidth;
diff --git a/src/views/pane/series-markers-pane-view.ts b/src/views/pane/series-markers-pane-view.ts
index 0bc6d7a..e69d3c0 100644
--- a/src/views/pane/series-markers-pane-view.ts
+++ b/src/views/pane/series-markers-pane-view.ts
@@ -53,6 +53,21 @@ function fillSizeAndY(
 	rendererItem.size = shapeSize;
 
 	switch (marker.position) {
+		case 'price': {
+			const markerPrice = marker.price || inBarPrice;
+			const anchor = marker.anchor || 'center';
+
+			const displaceY = anchor === 'top' ? 1 : anchor === 'bottom' ? -1 : 0;
+			const displaceX = anchor === 'left' ? 1 : anchor === 'right' ? -1 : 0;
+
+			rendererItem.y = (priceScale.priceToCoordinate(markerPrice, firstValue) + halfSize * displaceY) as Coordinate;
+			rendererItem.x = (rendererItem.x + halfSize * displaceX) as Coordinate;
+			if (rendererItem.text !== undefined) {
+				rendererItem.text.y = (rendererItem.y + (halfSize + shapeMargin + textHeight * (0.5 + Constants.TextMargin)) * displaceY ||
+					1) as Coordinate;
+			}
+			return;
+		}
 		case 'inBar': {
 			rendererItem.y = priceScale.priceToCoordinate(inBarPrice, firstValue);
 			if (rendererItem.text !== undefined) {
diff --git a/src/views/pane/text-pane-view.ts b/src/views/pane/text-pane-view.ts
new file mode 100644
index 0000000..9c14e8d
--- /dev/null
+++ b/src/views/pane/text-pane-view.ts
@@ -0,0 +1,42 @@
+import { deepCopy } from '../../helpers/deep-copy';
+
+import { ChartModel } from '../../model/chart-model';
+import { LineTool, LineToolOptionsInternal } from '../../model/line-tool';
+import { BoxHorizontalAlignment, BoxVerticalAlignment, LineToolType, TextAlignment, TextOptions } from '../../model/line-tool-options';
+import { CompositeRenderer } from '../../renderers/composite-renderer';
+import { TextRenderer } from '../../renderers/text-renderer';
+
+import { LineToolPaneView } from './line-tool-pane-view';
+
+export class TextPaneView extends LineToolPaneView {
+	protected _labelRenderer: TextRenderer = new TextRenderer();
+
+	public constructor(source: LineTool<LineToolType>, model: ChartModel) {
+		super(source, model);
+		this._renderer = null;
+	}
+
+	protected override _updateImpl(height: number, width: number): void {
+		this._renderer = null;
+
+		const priceScale = this._source.priceScale();
+		const timeScale = this._model.timeScale();
+		if (!priceScale || priceScale.isEmpty() || timeScale.isEmpty()) { return; }
+
+		super._updateImpl();
+		if (this._points.length < 1) { return; }
+
+		const options = this._source.options() as LineToolOptionsInternal<'Text'>;
+		const data = deepCopy(options.text) as TextOptions;
+		data.box.alignment = { vertical: BoxVerticalAlignment.Top, horizontal: BoxHorizontalAlignment.Center };
+		data.alignment = TextAlignment.Center;
+		const point = this._points[0].clone();
+
+		const compositeRenderer = new CompositeRenderer();
+		this._labelRenderer.setData({ text: data, points: [point] });
+
+		compositeRenderer.append(this._labelRenderer);
+		this.addAnchors(compositeRenderer);
+		this._renderer = compositeRenderer;
+	}
+}
diff --git a/src/views/pane/trend-line-pane-view.ts b/src/views/pane/trend-line-pane-view.ts
new file mode 100644
index 0000000..96111d5
--- /dev/null
+++ b/src/views/pane/trend-line-pane-view.ts
@@ -0,0 +1,70 @@
+import { deepCopy } from '../../helpers/deep-copy';
+
+import { ChartModel } from '../../model/chart-model';
+import { LineTool, LineToolOptionsInternal } from '../../model/line-tool';
+import { BoxHorizontalAlignment, LineToolType } from '../../model/line-tool-options';
+import { Point } from '../../model/point';
+import { CompositeRenderer } from '../../renderers/composite-renderer';
+import { SegmentRenderer } from '../../renderers/segment-renderer';
+import { TextRenderer } from '../../renderers/text-renderer';
+
+import { LineToolPaneView } from './line-tool-pane-view';
+
+export class TrendLinePaneView extends LineToolPaneView {
+	protected _lineRenderer: SegmentRenderer = new SegmentRenderer();
+	protected _labelRenderer: TextRenderer = new TextRenderer();
+
+	public constructor(source: LineTool<LineToolType>, model: ChartModel) {
+		super(source, model);
+		this._renderer = null;
+	}
+
+	// eslint-disable-next-line complexity
+	protected override _updateImpl(): void {
+		this._renderer = null;
+		this._invalidated = false;
+
+		const priceScale = this._source.priceScale();
+		const timeScale = this._model.timeScale();
+
+		if (!priceScale || priceScale.isEmpty() || timeScale.isEmpty()) { return; }
+		const strictRange = timeScale.visibleTimeRange();
+		if (strictRange === null) { return; }
+		const points = this._source.points();
+		if (points.length < 2) { return; }
+
+		const options = this._source.options() as LineToolOptionsInternal<'TrendLine'>;
+		const isOutsideView = Math.max(points[0].timestamp, points[1].timestamp) < strictRange.from.timestamp;
+
+		if (!isOutsideView || options.line.extend.left || options.line.extend.right) {
+			super._updateImpl();
+
+			if (this._points.length < 2) { return; }
+			const compositeRenderer = new CompositeRenderer();
+			this._lineRenderer.setData({ line: options.line, points: this._points });
+
+			compositeRenderer.append(this._lineRenderer);
+			if (options.text.value) {
+				const point0 = this._points[0];
+				const point1 = this._points[1];
+				const start = point0.x < point1.x ? point0 : point1;
+				const end = start === point0 ? point1 : point0;
+
+				const angle = Math.atan((end.y - start.y) / (end.x - start.x)) / Math.PI * -180;
+				const align = options.text.box.alignment.horizontal;
+				const pivot = align === BoxHorizontalAlignment.Left
+					? start.clone() : align === BoxHorizontalAlignment.Right
+					? end.clone() : new Point((point0.x + point1.x) / 2, (point0.y + point1.y) / 2);
+
+				const labelOptions = deepCopy(options.text);
+				labelOptions.box = { ...labelOptions.box, angle };
+
+				this._labelRenderer.setData({ text: labelOptions, points: [pivot] });
+				compositeRenderer.append(this._labelRenderer);
+			}
+
+			this.addAnchors(compositeRenderer);
+			this._renderer = compositeRenderer;
+		}
+	}
+}
diff --git a/src/views/pane/triangle-pane-view.ts b/src/views/pane/triangle-pane-view.ts
new file mode 100644
index 0000000..6b22ff7
--- /dev/null
+++ b/src/views/pane/triangle-pane-view.ts
@@ -0,0 +1,28 @@
+import { ChartModel } from '../../model/chart-model';
+import { LineTool, LineToolOptionsInternal } from '../../model/line-tool';
+import { LineToolType } from '../../model/line-tool-options';
+import { CompositeRenderer } from '../../renderers/composite-renderer';
+import { TriangleRenderer } from '../../renderers/triangle-renderer';
+
+import { LineToolPaneView } from './line-tool-pane-view';
+
+export class TrianglePaneView extends LineToolPaneView {
+	protected _triangleRenderer: TriangleRenderer = new TriangleRenderer();
+
+	public constructor(source: LineTool<LineToolType>, model: ChartModel) {
+		super(source, model);
+		this._renderer = null;
+	}
+
+	protected override _updateImpl(): void {
+		const options = this._source.options() as LineToolOptionsInternal<'Triangle'>;
+		super._updateImpl();
+		this._renderer = null;
+
+		this._triangleRenderer.setData({ ...options.triangle, points: this._points, hitTestBackground: false });
+		const compositeRenderer = new CompositeRenderer();
+		compositeRenderer.append(this._triangleRenderer);
+		this.addAnchors(compositeRenderer);
+		this._renderer = compositeRenderer;
+	}
+}
diff --git a/src/views/pane/vertical-line-pane-view.ts b/src/views/pane/vertical-line-pane-view.ts
new file mode 100644
index 0000000..b7632f0
--- /dev/null
+++ b/src/views/pane/vertical-line-pane-view.ts
@@ -0,0 +1,79 @@
+import { deepCopy } from '../../helpers/deep-copy';
+
+import { ChartModel } from '../../model/chart-model';
+import { Coordinate } from '../../model/coordinate';
+import { HitTestResult, HitTestType } from '../../model/hit-test-result';
+import { LineTool, LineToolOptionsInternal } from '../../model/line-tool';
+import { BoxHorizontalAlignment, LineToolType } from '../../model/line-tool-options';
+import { Point } from '../../model/point';
+import { CompositeRenderer } from '../../renderers/composite-renderer';
+import { AnchorPoint } from '../../renderers/line-anchor-renderer';
+import { SegmentRenderer } from '../../renderers/segment-renderer';
+import { TextRenderer } from '../../renderers/text-renderer';
+
+import { LineEnd } from '../..';
+import { LineToolPaneView } from './line-tool-pane-view';
+
+export class VerticalLinePaneView extends LineToolPaneView {
+	protected _lineRenderer: SegmentRenderer = new SegmentRenderer();
+	protected _labelRenderer: TextRenderer = new TextRenderer();
+
+	public constructor(source: LineTool<LineToolType>, model: ChartModel) {
+		super(source, model);
+		this._renderer = null;
+		this._lineRenderer.setHitTest(new HitTestResult(HitTestType.MovePoint));
+	}
+
+	protected override _updateImpl(height: number, width: number): void {
+		this._renderer = null;
+
+		const priceScale = this._source.priceScale();
+		const timeScale = this._model.timeScale();
+		if (!priceScale || priceScale.isEmpty() || timeScale.isEmpty()) { return; }
+
+		const points = this._source.points();
+		if (points.length < 1) { return; }
+
+		const startTime = timeScale.coordinateToTime(0 as Coordinate);
+		const endTime = timeScale.coordinateToTime(width as Coordinate);
+		const options = this._source.options() as LineToolOptionsInternal<'VerticalLine'>;
+
+		const isOutsideView = (points[0].timestamp > endTime.timestamp) || (points[0].timestamp < startTime.timestamp);
+
+		if (!isOutsideView) {
+			super._updateImpl();
+			if (this._points.length < 1) { return; }
+
+			const point = this._points[0];
+			const start = new AnchorPoint(point.x, height, 0);
+			const end = new AnchorPoint(point.x, 0, 1);
+
+			point.y = height / 2 as Coordinate;
+			point.square = true;
+
+			const ends = { left: LineEnd.Normal, right: LineEnd.Normal };
+			const extend = { left: false, right: false };
+
+			const compositeRenderer = new CompositeRenderer();
+			this._lineRenderer.setData({ line: { ...deepCopy(options.line), end: ends, extend }, points: [start, end] });
+
+			compositeRenderer.append(this._lineRenderer);
+			if (options.text.value) {
+				const angle = Math.atan((end.y - start.y) / (end.x - start.x)) / Math.PI * -180;
+				const align = options.text.box.alignment.horizontal;
+				const pivot = align === BoxHorizontalAlignment.Left
+					? start.clone() : align === BoxHorizontalAlignment.Right
+					? end.clone() : new Point((start.x + end.x) / 2, (start.y + end.y) / 2);
+
+				const labelOptions = deepCopy(options.text);
+				labelOptions.box = { ...labelOptions.box, angle };
+
+				this._labelRenderer.setData({ text: labelOptions, points: [pivot] });
+				compositeRenderer.append(this._labelRenderer);
+			}
+
+			this.addAnchors(compositeRenderer);
+			this._renderer = compositeRenderer;
+		}
+	}
+}
diff --git a/src/views/price-axis/line-tool-price-axis-background-view.ts b/src/views/price-axis/line-tool-price-axis-background-view.ts
new file mode 100644
index 0000000..f57238b
--- /dev/null
+++ b/src/views/price-axis/line-tool-price-axis-background-view.ts
@@ -0,0 +1,44 @@
+import { ChartModel } from '../../model/chart-model';
+import { LineTool, LineToolPoint } from '../../model/line-tool';
+import { PriceAxisBackgroundRenderer, PriceAxisBackgroundRendererData } from '../../renderers/price-axis-background-renderer';
+
+import { PriceAxisView } from './price-axis-view';
+
+export class LineToolPriceAxisBackgroundView extends PriceAxisView {
+	protected _renderer: PriceAxisBackgroundRenderer = new PriceAxisBackgroundRenderer();
+	protected _source: LineTool;
+	protected _model: ChartModel;
+
+	protected _rendererData: PriceAxisBackgroundRendererData = {
+		color: 'rgba(41, 98, 255, 0.25)',
+		visible: false,
+		coordinate: 0,
+		height: 0,
+	};
+
+	public constructor(lineTool: LineTool) {
+		super();
+		this._source = lineTool;
+		this._model = lineTool.model();
+		this._renderer.setData(this._rendererData);
+	}
+
+	protected _updateRendererData(): void {
+		this._rendererData.visible = false;
+		const priceScale = this._source.priceScale();
+
+		if (!priceScale || priceScale.isEmpty()) { return; }
+		if (!this._source.selected()) { return; }
+
+		const x = this._source.priceAxisPoints().map((point: LineToolPoint) => {
+			return priceScale.priceToCoordinate(point.price, point.price);
+		});
+
+		const max = Math.max(...x);
+		const min = Math.min(...x);
+
+		this._rendererData.coordinate = min;
+		this._rendererData.height = max - min;
+		this._rendererData.visible = true;
+	}
+}
diff --git a/src/views/price-axis/line-tool-price-axis-label-view.ts b/src/views/price-axis/line-tool-price-axis-label-view.ts
new file mode 100644
index 0000000..5d9cac6
--- /dev/null
+++ b/src/views/price-axis/line-tool-price-axis-label-view.ts
@@ -0,0 +1,60 @@
+import { generateContrastColors } from '../../helpers/color';
+
+import { LineTool } from '../../model/line-tool';
+import { PriceAxisViewRendererCommonData, PriceAxisViewRendererData } from '../../renderers/iprice-axis-view-renderer';
+
+import { PriceAxisView } from './price-axis-view';
+
+export class LineToolPriceAxisLabelView extends PriceAxisView {
+	protected _active: boolean = false;
+	protected _source: LineTool;
+	protected _pointIndex: number;
+
+	public constructor(lineTool: LineTool, pointIndex: number) {
+		super();
+		this._active = false;
+		this._source = lineTool;
+		this._pointIndex = pointIndex;
+	}
+
+	public setActive(active: boolean): void {
+		this._active = active;
+	}
+
+	protected _updateRendererData(
+		axisRenderData: PriceAxisViewRendererData,
+		paneRenderData: PriceAxisViewRendererData,
+		commonRendererData: PriceAxisViewRendererCommonData
+	): void {
+		axisRenderData.visible = false;
+		const chartModel = this._source.model();
+		if (!chartModel.timeScale() || chartModel.timeScale().isEmpty()) { return; }
+
+		const background = this._getBackgroundColor();
+		if (background === null) { return; }
+
+		const priceScale = this._source.priceScale();
+		if (priceScale === null || priceScale.isEmpty()) { return; }
+		if (chartModel.timeScale().visibleStrictRange() === null) { return; }
+
+		const points = this._source.priceAxisPoints();
+		if (points.length <= this._pointIndex) { return; }
+
+		const point = points[this._pointIndex];
+		if (!isFinite(point.price)) { return; }
+
+		const ownerSource = this._source.ownerSource();
+		const firstValue = null !== ownerSource ? ownerSource.firstValue() : null;
+		if (null === firstValue) {return;}
+
+		commonRendererData.background = background;
+		commonRendererData.color = generateContrastColors(commonRendererData.background).foreground;
+		commonRendererData.coordinate = priceScale.priceToCoordinate(point.price, firstValue.value);
+		axisRenderData.text = this._source.priceScale()?.formatPrice(point.price, firstValue.value) || '';
+		axisRenderData.visible = true;
+	}
+
+	protected _getBackgroundColor(): string| null {
+		return this._source.priceAxisLabelColor();
+	}
+}
diff --git a/src/views/time-axis/crosshair-time-axis-view.ts b/src/views/time-axis/crosshair-time-axis-view.ts
index a9b2023..74c72ac 100644
--- a/src/views/time-axis/crosshair-time-axis-view.ts
+++ b/src/views/time-axis/crosshair-time-axis-view.ts
@@ -58,15 +58,17 @@ export class CrosshairTimeAxisView implements ITimeAxisView {
 			return;
 		}
 
-		const currentTime = timeScale.indexToTime(this._crosshair.appliedIndex());
+		const currentTime = timeScale.floatIndexToTime(this._crosshair.appliedIndex());
 		data.width = timeScale.width();
 
+		// Useless. Not removed just to keep constructor arguments untouched.
 		const value = this._valueProvider();
-		if (!value.time) {
+		data.coordinate = value.coordinate;
+		/*if (!value.time) {
 			return;
-		}
+		}*/
 
-		data.coordinate = value.coordinate;
+		data.coordinate = timeScale.timeToCoordinate(ensureNotNull(currentTime));
 		data.text = timeScale.formatDateTime(ensureNotNull(currentTime));
 		data.visible = true;
 
diff --git a/src/views/time-axis/itime-axis-view.ts b/src/views/time-axis/itime-axis-view.ts
index cda658e..bc641dc 100644
--- a/src/views/time-axis/itime-axis-view.ts
+++ b/src/views/time-axis/itime-axis-view.ts
@@ -1,5 +1,6 @@
-import { TimeAxisViewRenderer } from '../../renderers/time-axis-view-renderer';
+import { ITimeAxisViewRenderer } from '../../renderers/itime-axis-view-renderer';
 
 export interface ITimeAxisView {
-	renderer(): TimeAxisViewRenderer;
+	renderer(): ITimeAxisViewRenderer;
+	update(): void;
 }
diff --git a/src/views/time-axis/line-tool-time-axis-background-view.ts b/src/views/time-axis/line-tool-time-axis-background-view.ts
new file mode 100644
index 0000000..a871818
--- /dev/null
+++ b/src/views/time-axis/line-tool-time-axis-background-view.ts
@@ -0,0 +1,56 @@
+import { ChartModel } from '../../model/chart-model';
+import { LineTool, LineToolPoint } from '../../model/line-tool';
+import { UTCTimestamp } from '../../model/time-data';
+import { TimeAxisBackgroundRenderer as TimeAxisBackgroundRenderer, TimeAxisBackgroundRendererData } from '../../renderers/time-axis-background-renderer';
+import { ITimeAxisViewRenderer } from '../../renderers/itime-axis-view-renderer';
+
+import { ITimeAxisView } from './itime-axis-view';
+
+export class LineToolTimeAxisBackgroundView implements ITimeAxisView {
+	protected _renderer: TimeAxisBackgroundRenderer = new TimeAxisBackgroundRenderer();
+	protected _invalidated: boolean = true;
+	protected _source: LineTool;
+	protected _model: ChartModel;
+
+	protected _rendererData: TimeAxisBackgroundRendererData = {
+		color: 'rgba(41, 98, 255, 0.25)',
+		visible: false,
+		coordinate: 0,
+		width: 0,
+	};
+
+	public constructor(lineTool: LineTool) {
+		this._source = lineTool;
+		this._model = lineTool.model();
+		this._renderer.setData(this._rendererData);
+	}
+
+	public update(): void {
+		this._invalidated = true;
+	}
+
+	public renderer(): ITimeAxisViewRenderer {
+		if (this._invalidated) { this._updateImpl(); }
+		this._invalidated = false;
+		return this._renderer;
+	}
+
+	protected _updateImpl(): void {
+		this._rendererData.visible = false;
+
+		if (this._model.timeScale().isEmpty()) { return; }
+		if (!this._source.selected()) { return; }
+
+		const y = this._source.timeAxisPoints().map((point: LineToolPoint) => {
+			return this._model.timeScale().timeToCoordinate({ timestamp: point.timestamp as UTCTimestamp });
+		});
+
+		const max = Math.max(...y);
+		const min = Math.min(...y);
+
+		this._rendererData.coordinate = min;
+		this._rendererData.width = max - min;
+		this._rendererData.visible = true;
+		this._invalidated = false;
+	}
+}
diff --git a/src/views/time-axis/line-tool-time-axis-label-view.ts b/src/views/time-axis/line-tool-time-axis-label-view.ts
new file mode 100644
index 0000000..9e1967b
--- /dev/null
+++ b/src/views/time-axis/line-tool-time-axis-label-view.ts
@@ -0,0 +1,84 @@
+import { generateContrastColors } from '../../helpers/color';
+
+import { ChartModel } from '../../model/chart-model';
+import { LineTool } from '../../model/line-tool';
+import { UTCTimestamp } from '../../model/time-data';
+import { TimeAxisViewRenderer } from '../../renderers/time-axis-view-renderer';
+
+
+import { ITimeAxisView } from './itime-axis-view';
+
+export interface TimeAxisLabelRendererData {
+	width: number;
+	text: string;
+	tickVisible: boolean;
+	coordinate: number;
+	color: string;
+	background: string;
+	visible: boolean;
+}
+
+export class LineToolTimeAxisLabelView implements ITimeAxisView {
+	protected _source: LineTool;
+	protected _pointIndex: number;
+	protected _renderer: TimeAxisViewRenderer = new TimeAxisViewRenderer();
+	protected _invalidated: boolean = true;
+	protected _model: ChartModel;
+
+	protected _rendererData: TimeAxisLabelRendererData = {
+		background: '',
+		coordinate: 0,
+		color: '',
+		text: '',
+		width: 0,
+		visible: false,
+		tickVisible: false,
+	};
+
+	public constructor(model: ChartModel, lineTool: LineTool, pointIndex: number) {
+		this._model = model;
+		this._source = lineTool;
+		this._pointIndex = pointIndex;
+		this._renderer.setData(this._rendererData);
+	}
+
+	public update(): void {
+		this._invalidated = true;
+	}
+
+	public renderer(): TimeAxisViewRenderer {
+		if (this._invalidated) { this._updateImpl(); }
+		this._invalidated = false;
+		return this._renderer;
+	}
+
+	protected _updateImpl(): void {
+		this._rendererData.visible = false;
+		if (this._model.timeScale().isEmpty()) { return; }
+
+		const background = this._getBackgroundColor();
+		if (background === null) { return; }
+
+		const timestamp = this._getTime();
+		if (timestamp === null) { return; }
+
+		const colors = generateContrastColors(background);
+		this._rendererData.background = colors.background;
+		this._rendererData.color = colors.foreground;
+
+		this._rendererData.coordinate = this._model.timeScale().timeToCoordinate({ timestamp });
+		this._rendererData.text = this._model.timeScale().formatDateTime({ timestamp });
+		this._rendererData.width = this._model.timeScale().width();
+		this._rendererData.visible = true;
+		this._invalidated = false;
+	}
+	
+	protected _getBackgroundColor(): string | null {
+		return this._source.timeAxisLabelColor();
+	}
+
+	protected _getTime(): UTCTimestamp | null {
+		const points = this._source.timeAxisPoints();
+		return points.length <= this._pointIndex ? null : points[this._pointIndex].timestamp as UTCTimestamp;
+	}
+}
